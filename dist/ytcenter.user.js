// ==UserScript==
// @id              YouTubeCenter
// @name            YouTube Center
// @namespace       http://www.facebook.com/YouTubeCenter
// @version         3.0.0
// @author          Jeppe Rune Mortensen <jepperm@gmail.com>
// @description     YouTube Center contains all kind of different useful functions which makes your visit on YouTube much more entertaining.
// @icon            https://raw.github.com/YePpHa/YouTubeCenter/master/assets/logo-48x48.png
// @icon64          https://raw.github.com/YePpHa/YouTubeCenter/master/assets/logo-64x64.png
// @domain          yeppha.github.io
// @domain          youtube.com
// @domain          www.youtube.com
// @domain          gdata.youtube.com
// @domain          apis.google.com
// @domain          plus.googleapis.com
// @domain          googleapis.com
// @domain          raw.github.com
// @domain          raw2.github.com
// @domain          s.ytimg.com
// @match           http://*.youtube.com/*
// @match           https://*.youtube.com/*
// @match           https://yeppha.github.io/downloads/YouTubeCenter.meta.js
// @match           http://s.ytimg.com/yts/jsbin/*
// @match           https://s.ytimg.com/yts/jsbin/*
// @match           https://raw.github.com/YePpHa/YouTubeCenter/master/*
// @match           http://apis.google.com/*/widget/render/comments?*
// @match           https://apis.google.com/*/widget/render/comments?*
// @match           http://plus.googleapis.com/*/widget/render/comments?*
// @match           https://plus.googleapis.com/*/widget/render/comments?*
// @include         http://*.youtube.com/*
// @include         https://*.youtube.com/*
// @include         http://apis.google.com/*/widget/render/comments?*
// @include         https://apis.google.com/*/widget/render/comments?*
// @include         http://plus.googleapis.com/*/widget/render/comments?*
// @include         https://plus.googleapis.com/*/widget/render/comments?*
// @exclude         http://apiblog.youtube.com/*
// @exclude         https://apiblog.youtube.com/*
// @exclude         http://*.youtube.com/subscribe_embed?*
// @exclude         https://*.youtube.com/subscribe_embed?*
// @grant           GM_getValue
// @grant           GM_setValue
// @grant           GM_deleteValue
// @grant           GM_xmlhttpRequest
// @grant           GM_log
// @grant           GM_registerMenuCommand
// @grant           unsafeWindow
// @updateURL       https://github.com/YePpHa/YouTubeCenter/raw/master/dist/YouTubeCenter.meta.js
// @downloadURL     https://github.com/YePpHa/YouTubeCenter/raw/master/dist/YouTubeCenter.user.js
// @updateVersion   1
// @run-at          document-start
// @priority        9001
// @contributionURL https://github.com/YePpHa/YouTubeCenter/wiki/Donate
// ==/UserScript==

(function(){
function mainPage(UserProxy_token, UserProxy_functions, globalSettings, consoleSessionToken) {
(function () {eval("/**\r\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/jrburke/almond for details\r\n */\r\n//Going sloppy to avoid \'use strict\' string cost, but strict practices should\r\n//be followed.\r\n/*jslint sloppy: true */\r\n/*global setTimeout: false */\r\n\r\nvar requirejs, require, define;\r\n(function (undef) {\r\n    var main, req, makeMap, handlers,\r\n        defined = {},\r\n        waiting = {},\r\n        config = {},\r\n        defining = {},\r\n        hasOwn = Object.prototype.hasOwnProperty,\r\n        aps = [].slice,\r\n        jsSuffixRegExp = /\\.js$/;\r\n\r\n    function hasProp(obj, prop) {\r\n        return hasOwn.call(obj, prop);\r\n    }\r\n\r\n    /**\r\n     * Given a relative module name, like ./something, normalize it to\r\n     * a real name that can be mapped to a path.\r\n     * @param {String} name the relative name\r\n     * @param {String} baseName a real name that the name arg is relative\r\n     * to.\r\n     * @returns {String} normalized name\r\n     */\r\n    function normalize(name, baseName) {\r\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\r\n            foundI, foundStarMap, starI, i, j, part,\r\n            baseParts = baseName && baseName.split(\"/\"),\r\n            map = config.map,\r\n            starMap = (map && map[\'*\']) || {};\r\n\r\n        //Adjust any relative paths.\r\n        if (name && name.charAt(0) === \".\") {\r\n            //If have a base name, try to normalize against it,\r\n            //otherwise, assume it is a top-level require that will\r\n            //be relative to baseUrl in the end.\r\n            if (baseName) {\r\n                //Convert baseName to array, and lop off the last part,\r\n                //so that . matches that \"directory\" and not name of the baseName\'s\r\n                //module. For instance, baseName of \"one/two/three\", maps to\r\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\r\n                //this normalization.\r\n                baseParts = baseParts.slice(0, baseParts.length - 1);\r\n                name = name.split(\'/\');\r\n                lastIndex = name.length - 1;\r\n\r\n                // Node .js allowance:\r\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\r\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, \'\');\r\n                }\r\n\r\n                name = baseParts.concat(name);\r\n\r\n                //start trimDots\r\n                for (i = 0; i < name.length; i += 1) {\r\n                    part = name[i];\r\n                    if (part === \".\") {\r\n                        name.splice(i, 1);\r\n                        i -= 1;\r\n                    } else if (part === \"..\") {\r\n                        if (i === 1 && (name[2] === \'..\' || name[0] === \'..\')) {\r\n                            //End of the line. Keep at least one non-dot\r\n                            //path segment at the front so it can be mapped\r\n                            //correctly to disk. Otherwise, there is likely\r\n                            //no path mapping for a path starting with \'..\'.\r\n                            //This can still fail, but catches the most reasonable\r\n                            //uses of ..\r\n                            break;\r\n                        } else if (i > 0) {\r\n                            name.splice(i - 1, 2);\r\n                            i -= 2;\r\n                        }\r\n                    }\r\n                }\r\n                //end trimDots\r\n\r\n                name = name.join(\"/\");\r\n            } else if (name.indexOf(\'./\') === 0) {\r\n                // No baseName, so this is ID is resolved relative\r\n                // to baseUrl, pull off the leading dot.\r\n                name = name.substring(2);\r\n            }\r\n        }\r\n\r\n        //Apply map config if available.\r\n        if ((baseParts || starMap) && map) {\r\n            nameParts = name.split(\'/\');\r\n\r\n            for (i = nameParts.length; i > 0; i -= 1) {\r\n                nameSegment = nameParts.slice(0, i).join(\"/\");\r\n\r\n                if (baseParts) {\r\n                    //Find the longest baseName segment match in the config.\r\n                    //So, do joins on the biggest to smallest lengths of baseParts.\r\n                    for (j = baseParts.length; j > 0; j -= 1) {\r\n                        mapValue = map[baseParts.slice(0, j).join(\'/\')];\r\n\r\n                        //baseName segment has  config, find if it has one for\r\n                        //this name.\r\n                        if (mapValue) {\r\n                            mapValue = mapValue[nameSegment];\r\n                            if (mapValue) {\r\n                                //Match, update name to the new value.\r\n                                foundMap = mapValue;\r\n                                foundI = i;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (foundMap) {\r\n                    break;\r\n                }\r\n\r\n                //Check for a star map match, but just hold on to it,\r\n                //if there is a shorter segment match later in a matching\r\n                //config, then favor over this star map.\r\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\r\n                    foundStarMap = starMap[nameSegment];\r\n                    starI = i;\r\n                }\r\n            }\r\n\r\n            if (!foundMap && foundStarMap) {\r\n                foundMap = foundStarMap;\r\n                foundI = starI;\r\n            }\r\n\r\n            if (foundMap) {\r\n                nameParts.splice(0, foundI, foundMap);\r\n                name = nameParts.join(\'/\');\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    function makeRequire(relName, forceSync) {\r\n        return function () {\r\n            //A version of a require function that passes a moduleName\r\n            //value for items that may need to\r\n            //look up paths relative to the moduleName\r\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\r\n        };\r\n    }\r\n\r\n    function makeNormalize(relName) {\r\n        return function (name) {\r\n            return normalize(name, relName);\r\n        };\r\n    }\r\n\r\n    function makeLoad(depName) {\r\n        return function (value) {\r\n            defined[depName] = value;\r\n        };\r\n    }\r\n\r\n    function callDep(name) {\r\n        if (hasProp(waiting, name)) {\r\n            var args = waiting[name];\r\n            delete waiting[name];\r\n            defining[name] = true;\r\n            main.apply(undef, args);\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\r\n            throw new Error(\'No \' + name);\r\n        }\r\n        return defined[name];\r\n    }\r\n\r\n    //Turns a plugin!resource to [plugin, resource]\r\n    //with the plugin being undefined if the name\r\n    //did not have a plugin prefix.\r\n    function splitPrefix(name) {\r\n        var prefix,\r\n            index = name ? name.indexOf(\'!\') : -1;\r\n        if (index > -1) {\r\n            prefix = name.substring(0, index);\r\n            name = name.substring(index + 1, name.length);\r\n        }\r\n        return [prefix, name];\r\n    }\r\n\r\n    /**\r\n     * Makes a name map, normalizing the name, and using a plugin\r\n     * for normalization if necessary. Grabs a ref to plugin\r\n     * too, as an optimization.\r\n     */\r\n    makeMap = function (name, relName) {\r\n        var plugin,\r\n            parts = splitPrefix(name),\r\n            prefix = parts[0];\r\n\r\n        name = parts[1];\r\n\r\n        if (prefix) {\r\n            prefix = normalize(prefix, relName);\r\n            plugin = callDep(prefix);\r\n        }\r\n\r\n        //Normalize according\r\n        if (prefix) {\r\n            if (plugin && plugin.normalize) {\r\n                name = plugin.normalize(name, makeNormalize(relName));\r\n            } else {\r\n                name = normalize(name, relName);\r\n            }\r\n        } else {\r\n            name = normalize(name, relName);\r\n            parts = splitPrefix(name);\r\n            prefix = parts[0];\r\n            name = parts[1];\r\n            if (prefix) {\r\n                plugin = callDep(prefix);\r\n            }\r\n        }\r\n\r\n        //Using ridiculous property names for space reasons\r\n        return {\r\n            f: prefix ? prefix + \'!\' + name : name, //fullName\r\n            n: name,\r\n            pr: prefix,\r\n            p: plugin\r\n        };\r\n    };\r\n\r\n    function makeConfig(name) {\r\n        return function () {\r\n            return (config && config.config && config.config[name]) || {};\r\n        };\r\n    }\r\n\r\n    handlers = {\r\n        require: function (name) {\r\n            return makeRequire(name);\r\n        },\r\n        exports: function (name) {\r\n            var e = defined[name];\r\n            if (typeof e !== \'undefined\') {\r\n                return e;\r\n            } else {\r\n                return (defined[name] = {});\r\n            }\r\n        },\r\n        module: function (name) {\r\n            return {\r\n                id: name,\r\n                uri: \'\',\r\n                exports: defined[name],\r\n                config: makeConfig(name)\r\n            };\r\n        }\r\n    };\r\n\r\n    main = function (name, deps, callback, relName) {\r\n        var cjsModule, depName, ret, map, i,\r\n            args = [],\r\n            callbackType = typeof callback,\r\n            usingExports;\r\n\r\n        //Use name if no relName\r\n        relName = relName || name;\r\n\r\n        //Call the callback to define the module, if necessary.\r\n        if (callbackType === \'undefined\' || callbackType === \'function\') {\r\n            //Pull out the defined dependencies and pass the ordered\r\n            //values to the callback.\r\n            //Default to [require, exports, module] if no deps\r\n            deps = !deps.length && callback.length ? [\'require\', \'exports\', \'module\'] : deps;\r\n            for (i = 0; i < deps.length; i += 1) {\r\n                map = makeMap(deps[i], relName);\r\n                depName = map.f;\r\n\r\n                //Fast path CommonJS standard dependencies.\r\n                if (depName === \"require\") {\r\n                    args[i] = handlers.require(name);\r\n                } else if (depName === \"exports\") {\r\n                    //CommonJS module spec 1.1\r\n                    args[i] = handlers.exports(name);\r\n                    usingExports = true;\r\n                } else if (depName === \"module\") {\r\n                    //CommonJS module spec 1.1\r\n                    cjsModule = args[i] = handlers.module(name);\r\n                } else if (hasProp(defined, depName) ||\r\n                           hasProp(waiting, depName) ||\r\n                           hasProp(defining, depName)) {\r\n                    args[i] = callDep(depName);\r\n                } else if (map.p) {\r\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\r\n                    args[i] = defined[depName];\r\n                } else {\r\n                    throw new Error(name + \' missing \' + depName);\r\n                }\r\n            }\r\n\r\n            ret = callback ? callback.apply(defined[name], args) : undefined;\r\n\r\n            if (name) {\r\n                //If setting exports via \"module\" is in play,\r\n                //favor that over return value and exports. After that,\r\n                //favor a non-undefined return value over exports use.\r\n                if (cjsModule && cjsModule.exports !== undef &&\r\n                        cjsModule.exports !== defined[name]) {\r\n                    defined[name] = cjsModule.exports;\r\n                } else if (ret !== undef || !usingExports) {\r\n                    //Use the return value from the function.\r\n                    defined[name] = ret;\r\n                }\r\n            }\r\n        } else if (name) {\r\n            //May just be an object definition for the module. Only\r\n            //worry about defining if have a module name.\r\n            defined[name] = callback;\r\n        }\r\n    };\r\n\r\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\r\n        if (typeof deps === \"string\") {\r\n            if (handlers[deps]) {\r\n                //callback in this case is really relName\r\n                return handlers[deps](callback);\r\n            }\r\n            //Just return the module wanted. In this scenario, the\r\n            //deps arg is the module name, and second arg (if passed)\r\n            //is just the relName.\r\n            //Normalize module name, if it contains . or ..\r\n            return callDep(makeMap(deps, callback).f);\r\n        } else if (!deps.splice) {\r\n            //deps is a config object, not an array.\r\n            config = deps;\r\n            if (config.deps) {\r\n                req(config.deps, config.callback);\r\n            }\r\n            if (!callback) {\r\n                return;\r\n            }\r\n\r\n            if (callback.splice) {\r\n                //callback is an array, which means it is a dependency list.\r\n                //Adjust args if there are dependencies\r\n                deps = callback;\r\n                callback = relName;\r\n                relName = null;\r\n            } else {\r\n                deps = undef;\r\n            }\r\n        }\r\n\r\n        //Support require([\'a\'])\r\n        callback = callback || function () {};\r\n\r\n        //If relName is a function, it is an errback handler,\r\n        //so remove it.\r\n        if (typeof relName === \'function\') {\r\n            relName = forceSync;\r\n            forceSync = alt;\r\n        }\r\n\r\n        //Simulate async callback;\r\n        if (forceSync) {\r\n            main(undef, deps, callback, relName);\r\n        } else {\r\n            //Using a non-zero value because of concern for what old browsers\r\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\r\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\r\n            //If want a value immediately, use require(\'id\') instead -- something\r\n            //that works in almond on the global level, but not guaranteed and\r\n            //unlikely to work in other AMD implementations.\r\n            setTimeout(function () {\r\n                main(undef, deps, callback, relName);\r\n            }, 4);\r\n        }\r\n\r\n        return req;\r\n    };\r\n\r\n    /**\r\n     * Just drops the config on the floor, but returns req in case\r\n     * the config return value is used.\r\n     */\r\n    req.config = function (cfg) {\r\n        return req(cfg);\r\n    };\r\n\r\n    /**\r\n     * Expose module registry for debugging and tooling\r\n     */\r\n    requirejs._defined = defined;\r\n\r\n    define = function (name, deps, callback) {\r\n\r\n        //This module may not have dependencies\r\n        if (!deps.splice) {\r\n            //deps is not an array, so probably means\r\n            //an object literal or factory function for\r\n            //the value. Adjust args.\r\n            callback = deps;\r\n            deps = [];\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\r\n            waiting[name] = [name, deps, callback];\r\n        }\r\n    };\r\n\r\n    define.amd = {\r\n        jQuery: true\r\n    };\r\n}());\r\n\n//# sourceURL=/../vendor/almond.js");

define("../vendor/almond", function(){});

eval("define(\'unsafeWindow\',[], function(){\r\n  return window;\r\n});\n//# sourceURL=/unsafeWindow.js");

eval("define(\'support\',[\"unsafeWindow\"], function(uw){\r\n  function localStorageTest() {\r\n    var mod = \"support.test\";\r\n    try {\r\n      localStorage.setItem(mod, mod);\r\n      localStorage.removeItem(mod);\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  var isWebkitURL = typeof uw.webkitURL === \"object\";\r\n  var isURL = typeof uw.URL === \"object\";\r\n  var isCreateObjectURL = false;\r\n  var isRevokeObjectURL = false;\r\n  \r\n  var maxthonRuntime = window && window.external && window.external.mxGetRuntime && typeof window.external.mxGetRuntime === \"function\";\r\n  \r\n  if (isWebkitURL) {\r\n    isCreateObjectURL = typeof uw.webkitURL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.webkitURL.revokeObjectURL === \"function\";\r\n  } else if (isURL) {\r\n    isCreateObjectURL = typeof uw.URL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.URL.revokeObjectURL === \"function\";\r\n  }\r\n  \r\n  return {\r\n    localStorage: localStorageTest(),\r\n    Greasemonkey: (typeof GM_setValue !== \"undefined\" && (typeof GM_setValue.toString === \"undefined\" || GM_setValue.toString().indexOf(\"not supported\") === -1)),\r\n    createObjectURL: isCreateObjectURL,\r\n    revokeObjectURL: isRevokeObjectURL,\r\n    webkitURL: isWebkitURL,\r\n    URL: isURL,\r\n    maxthonRuntime: maxthonRuntime,\r\n    maxthonRuntimeStorage: maxthonRuntime && window.external.mxGetRuntime() && window.external.mxGetRuntime().storage,\r\n    firefoxPort: this.port && typeof this.port.request === \"function\" && this.port.storage && typeof this.port.on === \"function\"\r\n  };\r\n});\n//# sourceURL=/support.js");

eval("define(\'utils\',[\"support\", \"unsafeWindow\"], function(support, uw){\r\n  function each(obj, callback) {\r\n    if (isArray(obj)) {\r\n      for (var i = 0; i < obj.length; i++) {\r\n        if (callback(i, obj[i]) === true) break;\r\n      }\r\n    } else {\r\n      for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          if (callback(key, obj[key]) === true) break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n  }\r\n  \r\n  function asyncCall(scope, callback) {\r\n    return setTimeout(bind.apply(null, [scope, callback].concat(Array.prototype.slice.call(arguments, 2))), 0);\r\n  }\r\n  \r\n  function bind(scope, func) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    return function(){\r\n      return func.apply(scope, args.concat(Array.prototype.slice.call(arguments)))\r\n    };\r\n  }\r\n  function trimLeft(obj){\r\n    return obj.replace(/^\\s+/, \"\");\r\n  }\r\n  function trimRight(obj){\r\n    return obj.replace(/\\s+$/, \"\");\r\n  }\r\n  function map(obj, callback, thisArg) {\r\n    for (var i = 0, n = obj.length, a = []; i < n; i++) {\r\n      if (i in obj) a[i] = callback.call(thisArg, obj[i]);\r\n    }\r\n    return a;\r\n  }\r\n  \r\n  function defineLockedProperty(obj, key, setter, getter) {\r\n    if (typeof obj !== \"object\") obj = {};\r\n    if (ie || typeof Object.defineProperty === \"function\") {\r\n      Object.defineProperty(obj, key, {\r\n        get: getter,\r\n        set: setter\r\n      });\r\n      return obj;\r\n    } else {\r\n      obj.__defineGetter__(key, getter);\r\n      obj.__defineSetter__(key, setter);\r\n      return obj;\r\n    }\r\n  }\r\n  \r\n  function addEventListener(elm, event, callback, useCapture) {\r\n    if (elm.addEventListener) {\r\n      elm.addEventListener(event, callback, useCapture || false);\r\n    } else if (elm.attachEvent) {\r\n      elm.attachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  function removeEventListener(elm, event, callback, useCapture) {\r\n    if (elm.removeEventListener) {\r\n      elm.removeEventListener(event, callback, useCapture || false);\r\n    } else if (elm.detachEvent) {\r\n      elm.detachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  var ie = (function(){\r\n    for (var v = 3, el = document.createElement(\'b\'), all = el.all || []; el.innerHTML = \'<!--[if gt IE \' + (++v) + \']><i><![endif]-->\', all[0];);\r\n    return v > 4 ? v : !!document.documentMode;\r\n  }());\r\n  \r\n  var now = Date.now || function () {\r\n    return +new Date;\r\n  };\r\n  \r\n  /* Cookies */\r\n  function setCookie(name, value, domain, path, expires) {\r\n    domain = domain ? \";domain=\" + encodeURIComponent(domain) : \"\";\r\n    path = path ? \";path=\" + encodeURIComponent(path) : \"\";\r\n    expires = 0 > expires ? \"\" : 0 == expires ? \";expires=\" + (new Date(1970, 1, 1)).toUTCString() : \";expires=\" + (new Date(now() + 1E3 * expires)).toUTCString();\r\n    \r\n    document.cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value) + domain + path + expires;\r\n  }\r\n  \r\n  function getCookie(key) {\r\n    return getCookies()[key];\r\n  }\r\n  \r\n  function getCookies() {\r\n    var c = document.cookie, v = 0, cookies = {};\r\n    if (document.cookie.match(/^\\s*\\$Version=(?:\"1\"|1);\\s*(.*)/)) {\r\n      c = RegExp.$1;\r\n      v = 1;\r\n    }\r\n    if (v === 0) {\r\n      map(c.split(/[,;]/), function(cookie) {\r\n        var parts = cookie.split(/=/, 2),\r\n            name = decodeURIComponent(trimLeft(parts[0])),\r\n            value = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;\r\n        cookies[name] = value;\r\n      });\r\n    } else {\r\n      map(c.match(/(?:^|\\s+)([!#$%&\'*+\\-.0-9A-Z^`a-z|~]+)=([!#$%&\'*+\\-.0-9A-Z^`a-z|~]*|\"(?:[\\x20-\\x7E\\x80\\xFF]|\\\\[\\x00-\\x7F])*\")(?=\\s*[,;]|$)/g), function($0, $1) {\r\n        var name = $0, value = $1.charAt(0) === \'\"\' ? $1.substr(1, -1).replace(/\\\\(.)/g, \"$1\") : $1;\r\n        cookies[name] = value;\r\n      });\r\n    }\r\n    return cookies;\r\n  }\r\n  \r\n  function endsWith(str, suffix) {\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n  }\r\n  \r\n  function inject(func) {\r\n    var script = document.createElement(\"script\"),\r\n        p = (document.body || document.head || document.documentElement);\r\n    if (!p) {\r\n      throw \"Could not inject!!!\";\r\n    }\r\n    script.setAttribute(\"type\", \"text/javascript\");\r\n    script.appendChild(document.createTextNode(\"(\" + func + \")(\" + buildArgumentList.apply(null, [false].concat(Array.prototype.slice.call(arguments, 1))) + \");\"));\r\n    p.appendChild(script);\r\n    p.removeChild(script);\r\n  }\r\n  \r\n  function buildArgumentList(wrap) {\r\n    var list = [];\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    \r\n    for (var i = 0, len = args.length; i < len; i++) {\r\n      if (typeof args[i] === \"string\") {\r\n        list.push(\"\\\"\" + args[i].replace(/\\\\/, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\");\r\n      } else if (typeof args[i] === \"object\") {\r\n        list.push(JSON.stringify(args[i]));\r\n      } else if (typeof args[i] === \"undefined\") {\r\n        list.push(\"null\");\r\n      } else {\r\n        list.push(args[i]);\r\n      }\r\n    }\r\n    if (wrap) {\r\n      return \"(\" + list.join(\",\") + \")\";\r\n    } else {\r\n      return list.join(\",\");\r\n    }\r\n  }\r\n  \r\n  function isJSONString(json) {\r\n    try {\r\n      JSON.parse(json);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function xhr(details) {\r\n    var xmlhttp;\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new XMLHttpRequest();\r\n    } else if (typeof opera !== \"undefined\" && typeof opera.XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new opera.XMLHttpRequest();\r\n    } else {\r\n      if (details[\"onerror\"]) {\r\n        details[\"onerror\"]();\r\n      }\r\n      \r\n      return;\r\n    }\r\n    xmlhttp.onreadystatechange = function(){\r\n      var responseState = {\r\n        responseXML:(xmlhttp.readyState == 4 ? xmlhttp.responseXML : \'\'),\r\n        responseText:(xmlhttp.readyState == 4 ? xmlhttp.responseText : \'\'),\r\n        readyState:xmlhttp.readyState,\r\n        responseHeaders:(xmlhttp.readyState == 4 ? xmlhttp.getAllResponseHeaders() : \'\'),\r\n        status:(xmlhttp.readyState == 4 ? xmlhttp.status : 0),\r\n        statusText:(xmlhttp.readyState == 4 ? xmlhttp.statusText : \'\'),\r\n        finalUrl:(xmlhttp.readyState == 4 ? xmlhttp.finalUrl : \'\')\r\n      };\r\n      if (details[\"onreadystatechange\"]) {\r\n        details[\"onreadystatechange\"](responseState);\r\n      }\r\n      if (xmlhttp.readyState == 4) {\r\n        if (details[\"onload\"] && xmlhttp.status >= 200 && xmlhttp.status < 300) {\r\n          details[\"onload\"](responseState);\r\n        }\r\n        if (details[\"onerror\"] && (xmlhttp.status < 200 || xmlhttp.status >= 300)) {\r\n          details[\"onerror\"](responseState);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      xmlhttp.open(details.method, details.url);\r\n    } catch(e) {\r\n      if(details[\"onerror\"]) {\r\n        details[\"onerror\"]({responseXML:\'\',responseText:\'\',readyState:4,responseHeaders:\'\',status:403,statusText:\'Forbidden\'});\r\n      }\r\n      return;\r\n    }\r\n    if (details.headers) {\r\n      for (var prop in details.headers) {\r\n        xmlhttp.setRequestHeader(prop, details.headers[prop]);\r\n      }\r\n    }\r\n    xmlhttp.send((typeof(details.data) != \'undefined\') ? details.data : null);\r\n  }\r\n  \r\n  // Used for the message module (should probably move to another place)\r\n  // It replaces a property in the obj to a predefined function, where the arguments will be callbackId, target, referer\r\n  function bindFunctionCallbacks(obj, func, target, referer) {\r\n    for (key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"obj\") {\r\n          bindFunctionCallbacks(obj[key]);\r\n        } else if (typeof obj[key] === \"string\") {\r\n          if (obj[key].indexOf(\"@/(message.callback)/\") === 0) {\r\n            var callbackId = obj[key].split(\"@/(message.callback)/\")[1];\r\n            obj[key] = bind(null, func, callbackId, target, referer);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function extend(obj, defaults, deep) {\r\n    if (typeof obj !== \"object\") throw new TypeError(\"Unsupported type for obj.\");\r\n    if (typeof defaults !== \"object\") throw new TypeError(\"Unsupported type for defaults.\");\r\n    \r\n    for (var key in defaults) {\r\n      if (defaults.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"object\" && typeof defaults[key] === \"object\" && deep) {\r\n          extend(obj[key], defaults[key], deep);\r\n        } else if (!obj.hasOwnProperty(key)) {\r\n          obj[key] = defaults[key];\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function inArray(key, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function listClasses(el) {\r\n    if (!el || !el.className) return [];\r\n    return el.className.split(\" \");\r\n  }\r\n  \r\n  function addClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var addList = className.split(\" \");\r\n    \r\n    for (var i = 0, len = addList.length; i < len; i++) {\r\n      if (!inArray(addList[i], classes)) {\r\n        el.className += \" \" + addList[i];\r\n      }\r\n    }\r\n    return el.className;\r\n  }\r\n  \r\n  function removeClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var removeList = className.split(\" \");\r\n    \r\n    var buffer = [];\r\n    for (var i = 0, len = classes.length; i < len; i++) {\r\n      if (!inArray(classes[i], removeList)) {\r\n        buffer.push(classes[i]);\r\n      }\r\n    }\r\n    return el.className = buffer.join(\" \");\r\n  }\r\n  \r\n  function hasClass(el, className) {\r\n    return inArray(className, listClasses(el));\r\n  }\r\n  \r\n  function throttle(func, delay, options){\r\n    function timeout() {\r\n      previous = options.leading === false ? 0 : new Date;\r\n      timer = null;\r\n      result = func.apply(context, args);\r\n    }\r\n    var context, args, result, timer = null, previous = 0;\r\n    options = options || {};\r\n    return function(){\r\n      var now = new Date, dt;\r\n      \r\n      context = this;\r\n      args = arguments;\r\n      \r\n      if (!previous && options.leading === false) previous = now;\r\n      dt = delay - (now - previous);\r\n      \r\n      if (dt <= 0) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n        previous = now;\r\n        result = func.apply(context, args);\r\n      } else if (!timer && options.trailing !== false) {\r\n        timer = setTimeout(timeout, dt);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n  \r\n  function clone(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n  \r\n  function removeDuplicates(arr) {\r\n    var uniqueArr = [];\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (!inArray(uniqueArr, arr[i])) {\r\n        uniqueArr.push(arr[i]);\r\n      }\r\n    }\r\n    \r\n    return uniqueArr;\r\n  }\r\n  \r\n  function escapeRegExp(str) {\r\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n  }\r\n  \r\n  function toBlob(bytes, contentType) {\r\n    contentType = contentType || \"text/plain\";\r\n    var sliceSize = 512;\r\n    \r\n    var bytesLength = bytes.length;\r\n    var slicesCount = Math.ceil(bytesLength / sliceSize);\r\n    \r\n    var byteArrays = new Array(slicesCount);\r\n    \r\n    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\r\n      var begin = sliceIndex * sliceSize;\r\n      var end = Math.min(begin + sliceSize, bytesLength);\r\n      \r\n      var sliceBytes = new Array(end - begin);\r\n      for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {\r\n        sliceBytes[i] = bytes[offset].charCodeAt(0);\r\n      }\r\n      byteArrays[sliceIndex] = new Uint8Array(sliceBytes);\r\n    }\r\n    \r\n    return new Blob(byteArrays, { type: contentType });\r\n  }\r\n  \r\n  function createObjectURL(blob) {\r\n    if (support.createObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.createObjectURL(blob);\r\n      } else {\r\n        return uw.URL.createObjectURL(blob);\r\n      }\r\n    } else {\r\n      throw \"createObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  function revokeObjectURL(url) {\r\n    if (support.revokeObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.revokeObjectURL(url);\r\n      } else {\r\n        return uw.URL.revokeObjectURL(url);\r\n      }\r\n    } else {\r\n      throw \"revokeObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  // Returns a random number between min and max\r\n  function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n  \r\n  // Returns a random integer between min (included) and max (excluded)\r\n  function getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n  \r\n  // Returns a random string of characters of chars with the length of length\r\n  function generateToken(chars, length) {\r\n    if (typeof chars !== \"string\") chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\";\r\n    if (typeof length !== \"number\") length = 64;\r\n    \r\n    var charsLength = chars.length;\r\n    \r\n    var token = \"\";\r\n    for (var i = 0; i < length; i++) {\r\n      token += chars[getRandomInt(0, charsLength)];\r\n    }\r\n    \r\n    return token;\r\n  }\r\n  \r\n  function escapeECMAVariable(key, defaultKey) {\r\n    key = key.replace(/[^0-9a-zA-Z_\\$]/g, \"\");\r\n    while (/$[0-9]/g.test(key) && key.length > 0) {\r\n      if (key === \"\") return defaultKey;\r\n      key = key.substring(1);\r\n    }\r\n    return key;\r\n  }\r\n  \r\n  function indexOfArray(value, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === value) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n  \r\n  function getKeys(obj) {\r\n    var keys = [];\r\n    each(obj, function(key){\r\n      keys.push(key);\r\n    });\r\n    return keys;\r\n  }\r\n  \r\n  function setProperty(target, path, value, createPath) {\r\n    var tokens = path.split(\".\");\r\n    for (var i = 0, len = tokens.length - 1; i < len; i++) {\r\n      if (target[tokens[i]]) {\r\n        target = target[tokens[i]];\r\n      } else {\r\n        if (createPath) {\r\n          target[tokens[i]] = {};\r\n          target = target[tokens[i]];\r\n        } else {\r\n          throw \"Path \" + path + \" does not exist for\", target;\r\n        }\r\n      }\r\n    }\r\n    target[tokens[tokens.length - 1]] = value;\r\n  }\r\n  \r\n  return {\r\n    hasClass: hasClass,\r\n    removeClass: removeClass,\r\n    addClass: addClass,\r\n    each: each,\r\n    isArray: isArray,\r\n    inArray: inArray,\r\n    bind: bind,\r\n    asyncCall: asyncCall,\r\n    defineLockedProperty: defineLockedProperty,\r\n    ie: ie,\r\n    addEventListener: addEventListener,\r\n    removeEventListener: removeEventListener,\r\n    now: now,\r\n    trimLeft: trimLeft,\r\n    trimRight: trimRight,\r\n    map: map,\r\n    setCookie: setCookie,\r\n    getCookie: getCookie,\r\n    getCookies: getCookies,\r\n    endsWith: endsWith,\r\n    inject: inject,\r\n    isJSONString: isJSONString,\r\n    xhr: xhr,\r\n    buildArgumentList: buildArgumentList,\r\n    bindFunctionCallbacks: bindFunctionCallbacks,\r\n    extend: extend,\r\n    throttle: throttle,\r\n    clone: clone,\r\n    removeDuplicates: removeDuplicates,\r\n    escapeRegExp: escapeRegExp,\r\n    toBlob: toBlob,\r\n    createObjectURL: createObjectURL,\r\n    revokeObjectURL: revokeObjectURL,\r\n    getRandomArbitrary: getRandomArbitrary,\r\n    getRandomInt: getRandomInt,\r\n    generateToken: generateToken,\r\n    escapeECMAVariable: escapeECMAVariable,\r\n    indexOfArray: indexOfArray,\r\n    getKeys: getKeys,\r\n    setProperty: setProperty\r\n  };\r\n});\n//# sourceURL=/utils.js");

eval("define(\'player/api\',[\"unsafeWindow\", \"utils\"], function(unsafeWindow, utils){\r\n  function getAPI() {\r\n    if (!apiCache) {\r\n      apiCache = bindPlayerAPI();\r\n    }\r\n    return apiCache;\r\n  }\r\n  function setAPI(api) {\r\n    apiCache = api;\r\n  }\r\n  function bindPlayerAPI() {\r\n    var player = document.getElementById(\"movie_player\");\r\n    var api = {};\r\n    \r\n    if (player && player.getApiInterface) {\r\n      var apiInterface = player.getApiInterface();\r\n      for (var i = 0, len = apiInterface.length; i < len; i++) {\r\n        api[apiInterface[i]] = utils.bind(player, player[apiInterface[i]]);\r\n      }\r\n    }\r\n    return api;\r\n  }\r\n  \r\n  var apiCache = null;\r\n  \r\n  return {\r\n    getAPI: getAPI,\r\n    setAPI: setAPI\r\n  };\r\n});\n//# sourceURL=/player/api.js");

eval("define(\'console\',[\"utils\"], function(utils){\r\n  function setEnabled(b) {\r\n    enabled = b;\r\n  }\r\n  \r\n  function log() {\r\n    if (!enabled) return function(){};\r\n    return console.log.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function error() {\r\n    if (!enabled) return function(){};\r\n    return console.error.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function warn() {\r\n    if (!enabled) return function(){};\r\n    return console.warn.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  var sessionToken = (typeof consoleSessionToken === \"string\" ? consoleSessionToken : utils.generateToken(null, 8));\r\n  \r\n  var enabled = true;\r\n  \r\n  var con = {};\r\n  \r\n  con.sessionToken = sessionToken;\r\n  \r\n  utils.defineLockedProperty(con, \"log\", function(){}, log);\r\n  utils.defineLockedProperty(con, \"error\", function(){}, error);\r\n  utils.defineLockedProperty(con, \"warn\", function(){}, warn);\r\n  \r\n  return con;\r\n});\n//# sourceURL=/console.js");

eval("define(\'player/config\',[\"utils\", \"unsafeWindow\", \"console\"], function(utils, uw, con){\r\n  function getConfig() {\r\n    return config;\r\n  }\r\n  \r\n  function setConfig(cfg, val) {\r\n    if (typeof cfg === \"string\") {\r\n      utils.setProperty(config, cfg, val, true);\r\n    } else {\r\n      config = cfg;\r\n    }\r\n  }\r\n  \r\n  function configSetter(cfg) {\r\n    setConfig(cfg); // set the configuration. Keep the reference\r\n  }\r\n  \r\n  function configGetter() {\r\n    var cfg = getConfig();\r\n    if (!cfg) return cfg;\r\n    cfg = utils.clone(cfg);\r\n    var persistentCfg = utils.clone(persistentConfig);\r\n    utils.extend(persistentCfg, cfg, true);\r\n    return persistentCfg;\r\n  }\r\n  \r\n  function setPersistentConfig(cfg, val) {\r\n    if (typeof cfg === \"string\") {\r\n      utils.setProperty(persistentConfig, cfg, val, true);\r\n    } else {\r\n      persistentConfig = cfg;\r\n    }\r\n  }\r\n  \r\n  function getPersistentConfig() {\r\n    return persistentConfig;\r\n  }\r\n  \r\n  var config = {};\r\n  var persistentConfig = {};\r\n  \r\n  // Make sure that ytplayer variable is set\r\n  uw.ytplayer = uw.ytplayer || {};\r\n  \r\n  config = uw.ytplayer.config || {};\r\n  \r\n  // Make sure that YouTube doesn\'t override the ytplayer variable or adding an unwanted property to ytplayer.\r\n  utils.defineLockedProperty(uw.ytplayer, \"config\", configSetter, configGetter);\r\n  \r\n  return {\r\n    getConfig: getConfig,\r\n    setConfig: setConfig,\r\n    setPersistentConfig: setPersistentConfig,\r\n    getPersistentConfig: getPersistentConfig\r\n  };\r\n});\n//# sourceURL=/player/config.js");

eval("define(\'unsafeYouTubeCenter\',[\"unsafeWindow\"], function(uw){\r\n  var ytcenter = {};\r\n  ytcenter.player = {};\r\n  \r\n  uw.ytcenter = ytcenter;\r\n  \r\n  return ytcenter;\r\n});\n//# sourceURL=/unsafeYouTubeCenter.js");

eval("define(\'player/onYouTubePlayerReady\',[\"exports\", \"unsafeWindow\", \"./api\", \"./config\", \"utils\", \"unsafeYouTubeCenter\", \"console\"], function(exports, uw, playerAPI, config, utils, uytc, con){\r\n  function onPlayerReady(api) {\r\n    playerAPI.setAPI(api);\r\n    \r\n    if (typeof api === \"object\") {\r\n      for (var i = 0, len = listeners.length; i < len; i++) {\r\n        listeners[i].apply(null, arguments);\r\n      }\r\n    }\r\n  }\r\n  \r\n  function addListener(callback) {\r\n    listeners.push(callback);\r\n  }\r\n  \r\n  function removeListener(callback) {\r\n    for (var i = 0, len = listeners.length; i < len; i++) {\r\n      if (listeners[i] === callback) {\r\n        listeners.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  var listeners = [];\r\n  \r\n  config.setPersistentConfig(\"args.jsapicallback\", \"ytcenter.player.onReady\");\r\n  uytc.player.onReady = utils.bind(this, onPlayerReady);\r\n  uw.onYouTubePlayerReady = onPlayerReady;\r\n  \r\n  exports.addListener = addListener;\r\n  exports.removeListener = removeListener;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/onYouTubePlayerReady.js");

eval("define(\'pageload\',[\"utils\", \"console\"], function(utils, con){\r\n  function addEventListener(event, callback) {\r\n    if (!listeners.hasOwnProperty(event)) {\r\n      listeners[event] = [];\r\n    }\r\n    listeners[event].push(callback);\r\n    \r\n    // Make sure the added event listener is executed!\r\n    var readyState = pageStates.indexOf(event);\r\n    if (readyState <= lastState) {\r\n      callback();\r\n    }\r\n  }\r\n  \r\n  function removeEventListener(event, callback) {\r\n    if (!listeners.hasOwnProperty(event)) {\r\n      return;\r\n    }\r\n    var l = listeners[event];\r\n    for (var i = 0, len = l.length; i < len; i++) {\r\n      if (l[i] === callback) {\r\n        l[i].splice(i, 1);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  \r\n  function callListeners(event) {\r\n    var list = listeners[event];\r\n    for (var i = 0, len = list.length; i < len; i++) {\r\n      list[i]();\r\n    }\r\n  }\r\n  \r\n  function update() {\r\n    var readyState = pageStates.indexOf(document.readyState);\r\n    \r\n    for (var i = 0, len = pageStates.length; i < len; i++) {\r\n      if (lastState < i && i <= readyState && utils.isArray(listeners[pageStates[i]])) {\r\n        callListeners(pageStates[i]);\r\n      }\r\n    }\r\n    \r\n    lastState = readyState;\r\n  }\r\n  \r\n  function init() {\r\n    utils.addEventListener(document, \"readystatechange\", update, true);\r\n    utils.addEventListener(document, \"DOMContentLoaded\", update, true);\r\n    update();\r\n  }\r\n  \r\n  var listeners = {};\r\n  var pageStates = [\"uninitialized\", \"loading\", \"interactive\", \"complete\"];\r\n  var lastState = -1;\r\n  \r\n  init();\r\n  \r\n  return {\r\n    addEventListener: addEventListener,\r\n    removeEventListener: removeEventListener\r\n  };\r\n});\n//# sourceURL=/pageload.js");

eval("define(\'ytready\',[\"exports\", \"./pageload\", \"unsafeWindow\"], function(exports, pageload, uw){\r\n  function addEventListener(path, callback) {\r\n    if (!paths[path]) paths[path] = [];\r\n    paths[path].push(callback);\r\n    \r\n    update();\r\n  }\r\n  \r\n  function removeEventListener(path, callback) {\r\n    if (!paths[path]) return;\r\n    for (var i = 0, len = paths[path].length; i < len; i++) {\r\n      if (paths[path][i] === callback) {\r\n        paths[path].splice(i, 1);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Checks if the path in unsafeWindow is defined.\r\n  *\r\n  * @method propertyExists\r\n  * @param {String} path The path to the property.\r\n  * @return {Boolean} Returns true if the property exists otherwise false.\r\n  **/\r\n  function propertyExists(path) {\r\n    var tokens = path.split(\".\");\r\n    \r\n    var target = uw;\r\n    \r\n    for (var i = 0, len = tokens.length; i < len; i++) {\r\n      if (target[tokens[i]]) {\r\n        target = target[tokens[i]];\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * Checks if the added path listeners exist\r\n  * and if they do then call the callbacks\r\n  * for that specific path listener.\r\n  *\r\n  * @method update\r\n  **/\r\n  function update() {\r\n    for (var path in paths) {\r\n      if (paths[path]) {\r\n        if (propertyExists(path)) {\r\n          var callbacks = paths[path];\r\n          for (var i = 0, len = callbacks.length; i < len; i++) {\r\n            callbacks[i]();\r\n          }\r\n          paths[path] = null;\r\n        }\r\n      }\r\n    }\r\n    timerUpdate();\r\n  }\r\n  \r\n  function isWorking() {\r\n    for (var path in paths) {\r\n      if (paths[path]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function timerUpdate() {\r\n    clearTimeout(timer);\r\n    if (isWorking()) {\r\n      setTimeout(update, timerInterval);\r\n    }\r\n  }\r\n  \r\n  var timerInterval = 1000;\r\n  \r\n  var timer = null;\r\n  var paths = { };\r\n  \r\n  // Attach the update to the page load.\r\n  pageload.addEventListener(\"uninitialized\", update);\r\n  pageload.addEventListener(\"loading\", update);\r\n  pageload.addEventListener(\"interactive\", update);\r\n  pageload.addEventListener(\"complete\", update);\r\n  \r\n  \r\n  /* Exports */\r\n  exports.addEventListener = addEventListener;\r\n  exports.removeEventListener = removeEventListener;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/ytready.js");

eval("define(\'player/listeners\',[\"exports\", \"utils\", \"./api\", \"unsafeWindow\", \"console\", \"./onYouTubePlayerReady\", \"ytready\"], function(exports, utils, playerAPI, uw, con, onReady, ytready){\r\n  // Get the YouTube listener for the passed event.\r\n  function getYouTubeListener(event) {\r\n    var ytEvent = getListenerName(event);\r\n    return ytListeners[ytEvent];\r\n  }\r\n  \r\n  // The latest player id registered in the global window.\r\n  function getPlayerListenerDetails() {\r\n    var id = 1;\r\n    var uid = null;\r\n    \r\n    utils.each(uw, function(key, value){\r\n      if (key.indexOf(\"ytPlayer\") === 0) {\r\n        if (key.indexOf(\"player_uid_\") !== -1) {\r\n          var uidMatch = key.match(/player_uid_([0-9]+)_([0-9]+)$/);\r\n          \r\n          uid = parseInt(uidMatch[1], 10);\r\n          i = parseInt(uidMatch[2], 10);\r\n          \r\n          if (i > id) {\r\n            id = i;\r\n          }\r\n        } else {\r\n          var idMatch = key.match(/player([0-9]+)$/);\r\n          i = parseInt(idMatch[1], 10);\r\n          if (i > id) {\r\n            id = i;\r\n          }\r\n        }\r\n      }\r\n    });\r\n    \r\n    return { id: id, uid: uid };\r\n  }\r\n  \r\n  function getListenerName(event) {\r\n    if (playerListenerDetails.uid !== null) {\r\n      return \"ytPlayer\" + event + \"player_uid_\" + playerListenerDetails.uid + \"_\" + playerListenerDetails.id;\r\n    } else {\r\n      return \"ytPlayer\" + event + \"player\" + playerListenerDetails.id;\r\n    }\r\n  }\r\n  \r\n  function ytListenerContainerSetter(event, func) {\r\n    var ytEvent = getListenerName(event);\r\n    ytListeners[ytEvent] = func;\r\n  }\r\n  function ytListenerContainerGetter(event, func) {\r\n    return utils.bind(null, callListener, event, ORIGIN_PROPERTY);\r\n  }\r\n  \r\n  /* Origin argument\r\n   * If origin is equal to 0 then the origin is directly from the player (only YouTube Center\'s listeners get executed if override is false).\r\n   * If origin is equal to 1 then the origin is from the global listeners (both YouTube\'s and YouTube Center\'s listeners get executed).\r\n   */\r\n  function callListener(event, origin) {\r\n    function generateThisObject() {\r\n      return {\r\n        getOriginalListener: utils.bind(null, getYouTubeListener, event)\r\n      };\r\n    }\r\n    \r\n    var ytEvent = getListenerName(event);\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    var returnVal = null;\r\n    \r\n    if (enabled && origin === ORIGIN_PLAYER && (!events.hasOwnProperty(event) || (events.hasOwnProperty(event) && !events[event].override))) {\r\n      /* Override is false and the origin is from the player; call the YouTube Center listeners */\r\n      if (events.hasOwnProperty(event)) {\r\n        for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n          returnVal = events[event].listeners[i].apply(null, args);\r\n        }\r\n      }\r\n    } else if (enabled && origin === ORIGIN_PROPERTY) {\r\n      if (events.hasOwnProperty(event) && events[event].override) {\r\n        /* Override is true and the origin is from the global window; call the YouTube Center listeners */\r\n        for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n          events[event].listeners[i].apply(generateThisObject(), args);\r\n        }\r\n      } else if (ytListeners[ytEvent]) {\r\n        if (apiNotAvailable) {\r\n          /* API is not available therefore call YouTube Center listeners as YouTube listener is called  */\r\n          for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n            returnVal = events[event].listeners[i].apply(null, args);\r\n          }\r\n        }\r\n        \r\n        /* Override is false and the origin is from the global window; call the YouTube listener */\r\n        returnVal = ytListeners[ytEvent].apply(uw, args);\r\n      }\r\n    } else if (!enabled) {\r\n      /* Everything is disabled; call the YouTube listener */\r\n      returnVal = ytListeners[ytEvent].apply(uw, args);\r\n    }\r\n    return returnVal;\r\n  }\r\n  \r\n  function addPlayerListener() {\r\n    var api = playerAPI.getAPI();\r\n    var event;\r\n    \r\n    if (api && api.addEventListener) {\r\n      apiNotAvailable = false;\r\n      for (event in events) {\r\n        if (events.hasOwnProperty(event)) {\r\n          playerListener[event] = utils.bind(null, callListener, event, ORIGIN_PLAYER);\r\n          api.addEventListener(event, playerListener[event]);\r\n        }\r\n      }\r\n    } else {\r\n      apiNotAvailable = true;\r\n      con.error(\"[Player Listener] Player API is not available!\");\r\n    }\r\n  }\r\n  \r\n  function initGlobalListeners() {\r\n    if (globalListenersInitialized) return; // Make sure that this function is only called once.\r\n    globalListenersInitialized = true;\r\n    for (var event in events) {\r\n      if (events.hasOwnProperty(event)) {\r\n        var ytEvent = getListenerName(event);\r\n        if (uw[ytEvent]) {\r\n          ytListeners[ytEvent] = uw[ytEvent];\r\n        }\r\n        utils.defineLockedProperty(uw, ytEvent,\r\n          utils.bind(null, ytListenerContainerSetter, event),\r\n          utils.bind(null, ytListenerContainerGetter, event)\r\n        );\r\n      }\r\n    }\r\n  }\r\n  \r\n  function init() {\r\n    if (enabled) return;\r\n    var api = playerAPI.getAPI();\r\n    playerListenerDetails = getPlayerListenerDetails();\r\n    \r\n    enabled = true; // Indicate that the it\'s active.\r\n\r\n    // Add the listeners normally to the player\r\n    addPlayerListener();\r\n    \r\n    // Replace the global listeners with custom listeners in case the override property is set to true\r\n    initGlobalListeners();\r\n  }\r\n  \r\n  function addEventListener(event, listener) {\r\n    if (!events.hasOwnProperty(event)) return;\r\n    \r\n    removeEventListener(event, listener); // Make sure that there is only one instance of the listener registered.\r\n    events[event].listeners.push(listener);\r\n  }\r\n      \r\n  function removeEventListener(event, listener) {\r\n    if (!events.hasOwnProperty(event)) return;\r\n    for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n      if (events[event].listeners[i] === listener) {\r\n        return events[event].listeners.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n  \r\n  function setOverride(event, override) {\r\n    if (!events.hasOwnProperty(event)) return;\r\n    events[event].override = !!override;\r\n  }\r\n  \r\n  function unloadPlayerListeners() {\r\n    var api = playerAPI.getAPI();\r\n    var event;\r\n    \r\n    if (api && api.removeEventListener) {\r\n      for (event in events) {\r\n        if (events.hasOwnProperty(event)) {\r\n          api.removeEventListener(event, playerListener[event]);\r\n          delete playerListener[event];\r\n        }\r\n      }\r\n    } else {\r\n      con.error(\"[Player Listener] Player API is not available!\");\r\n    }\r\n  }\r\n  \r\n  function unload() {\r\n    unloadPlayerListeners();\r\n    enabled = false;\r\n    apiNotAvailable = true;\r\n  }\r\n  \r\n  var ORIGIN_PLAYER = 0;\r\n  var ORIGIN_PROPERTY = 1;\r\n  \r\n  var playerListenerDetails = { id: 1, uid: null };\r\n  var ytListeners = {};\r\n  var playerListener = {}; // Reference for unload\r\n  var enabled = false;\r\n  var globalListenersInitialized = false;\r\n  var apiNotAvailable = true;\r\n  \r\n  var events = {\r\n    \"onApiChange\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onCueRangeEnter\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onCueRangeExit\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onError\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onNavigate\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onPlaybackQualityChange\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onStateChange\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onTabOrderChange\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onVolumeChange\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onAdStart\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onReady\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"RATE_SENTIMENT\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"SHARE_CLICKED\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"SIZE_CLICKED\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"WATCH_LATER\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"AdvertiserVideoView\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"captionschanged\": {\r\n      override: false,\r\n      listeners: []\r\n    },\r\n    \"onRemoteReceiverSelected\": {\r\n      override: false,\r\n      listeners: []\r\n    }\r\n  };\r\n  \r\n  // Intialize the player listeners at player on ready.\r\n  onReady.addListener(init);\r\n  \r\n  /* Exports */\r\n  exports.addEventListener = addEventListener;\r\n  exports.removeEventListener = removeEventListener;\r\n  exports.setOverride = setOverride;\r\n  exports.init = init;\r\n  exports.unload = unload;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/listeners.js");

eval("define(\'window\',[], function(){\r\n  function getInnerWidth() {\r\n    return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r\n  }\r\n  function getInnerHeight() {\r\n    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\r\n  }\r\n  \r\n  function getClientWidth() {\r\n    return document.documentElement.clientWidth || window.innerWidth || document.body.clientWidth;\r\n  }\r\n  \r\n  function getClientHeight() {\r\n    return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;\r\n  }\r\n  \r\n  function addEventListener(event, callback, capture) {\r\n    window.addEventListener(event, callback, capture);\r\n  }\r\n  \r\n  return {\r\n    getClientWidth: getClientWidth,\r\n    getClientHeight: getClientHeight,\r\n    getInnerWidth: getInnerWidth,\r\n    getInnerHeight: getInnerHeight,\r\n    addEventListener: addEventListener\r\n  }\r\n});\n//# sourceURL=/window.js");

eval("define(\'player/size\',[\"exports\", \"./listeners\", \"./player\", \"window\", \"utils\"], function(exports, listeners, player, win, utils){\r\n  function onPlayerSizeChange(large) {\r\n    if (large) {\r\n      setSize(largeSize);\r\n    } else {\r\n      setSize(smallSize);\r\n    }\r\n    update();\r\n  }\r\n  \r\n  function setSize(nSize) {\r\n    size = nSize;\r\n    update();\r\n  }\r\n  \r\n  function update() {\r\n    var playerEl = document.getElementById(\"player\");\r\n    var playerAPIEl = document.getElementById(\"player-api\");\r\n    var playerTheaterBackgroundEl = document.getElementById(\"theater-background\");\r\n    \r\n    utils.removeClass(playerEl, \"watch-small watch-medium watch-large\");\r\n    if (size.large) {\r\n      utils.addClass(playerEl, \"watch-large\");\r\n    } else {\r\n      utils.addClass(playerEl, \"watch-small\");\r\n    }\r\n    \r\n    var dim = getPlayerDimension();\r\n    if (size.large) {\r\n      playerEl.style.width = dim.width + \"px\";\r\n    } else {\r\n      playerEl.style.width = \"auto\";\r\n    }\r\n    playerTheaterBackgroundEl.style.height = dim.height + \"px\";\r\n    \r\n    playerAPIEl.style.width = dim.width + \"px\";\r\n    playerAPIEl.style.height = dim.height + \"px\";\r\n    \r\n    var contentContainerEl = document.getElementById(\"watch7-container\");\r\n    if (size.large) {\r\n      utils.addClass(contentContainerEl, \"watch-wide\");\r\n    } else {\r\n      utils.removeClass(contentContainerEl, \"watch-wide\");\r\n    }\r\n    \r\n    var sidebarEl = document.getElementById(\"watch7-sidebar\");\r\n    if (size.large) {\r\n      sidebarEl.style.top = \"\";\r\n    } else {\r\n      sidebarEl.style.top = \"-\" + dim.height + \"px\";\r\n    }\r\n  }\r\n  \r\n  function getPlayerDimension() {\r\n    var playerEl = document.getElementById(\"player\");\r\n    \r\n    var width = null;\r\n    var height = null;\r\n    \r\n    if (typeof size.width === \"number\") {\r\n      if (size.widthUnit === \"%\") {\r\n        width = size.width/100*win.getClientWidth();\r\n      } else {\r\n        width = size.width;\r\n      }\r\n    }\r\n    \r\n    if (typeof size.width === \"number\") {\r\n      if (size.heightUnit === \"%\") {\r\n        height = size.height/100*win.getClientHeight();\r\n        // if (something.isTopBar())\r\n        height -= 50;\r\n      } else {\r\n        height = size.height;\r\n      }\r\n    }\r\n    \r\n    var ratio = getRatio();\r\n    \r\n    if (typeof width !== \"number\") {\r\n      if (typeof height === \"number\") {\r\n        width = height*ratio;\r\n      } else {\r\n        width = getDefaultWidth();\r\n      }\r\n    }\r\n    \r\n    if (typeof height !== \"number\") {\r\n      if (typeof width === \"number\") {\r\n        height = width/ratio;\r\n      } else {\r\n        height = getDefaultHeight();\r\n      }\r\n    }\r\n    \r\n    // Controlbar + Progressbar height\r\n    var controlbarHeight = player.getControlbarHeight();\r\n    height += controlbarHeight;\r\n    \r\n    // Multi camera additional height\r\n    if (utils.hasClass(playerEl, \"watch-multicamera\") && player.getType === \"flash\") {\r\n      height += 80;\r\n    }\r\n    \r\n    return {\r\n      width: Math.floor(width),\r\n      height: Math.floor(height)\r\n    };\r\n  }\r\n  \r\n  function setSmallPlayerSize(small) {\r\n    smallSize = small;\r\n  }\r\n  \r\n  function setLargePlayerSize(large) {\r\n    largeSize = large;\r\n  }\r\n  \r\n  function getRatio() {\r\n    return 16/9;\r\n  }\r\n  \r\n  function getDefaultWidth() {\r\n    return 640;\r\n  }\r\n  \r\n  function getDefaultHeight() {\r\n    return getDefaultWidth()/getRatio();\r\n  }\r\n  \r\n  var smallSize = {\r\n    width: 1280,\r\n    widthUnit: \"px\",\r\n    large: true\r\n  };\r\n  var largeSize = {\r\n    width: 1920,\r\n    widthUnit: \"px\",\r\n    large: true\r\n  };\r\n  \r\n  var size = {\r\n    width: 1280,\r\n    height: 720,\r\n    widthUnit: \"px\",\r\n    heightUnit: \"px\",\r\n    large: true\r\n  };\r\n  \r\n  listeners.setOverride(\"SIZE_CLICKED\", true);\r\n  listeners.addEventListener(\"SIZE_CLICKED\", onPlayerSizeChange);\r\n  \r\n  win.addEventListener(\"resize\", utils.throttle(update, 100));\r\n  \r\n  /* Exports */\r\n  exports.setSize = setSize;\r\n  exports.getRatio = getRatio;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/size.js");

eval("define(\'player/player\',[\"exports\", \"player/api\", \"player/config\", \"unsafeWindow\", \"player/size\"], function(exports, playerAPI, playerConfig, uw, size){\r\n  /**\r\n  * Get the current player type, which can either be HTML5 or flash.\r\n  *\r\n  * @method getType\r\n  * @return {String} The player type.\r\n  **/\r\n  function getType() {\r\n    var api = playerAPI.getAPI();\r\n    if (api && typeof api.getPlayerType === \"function\") {\r\n      return api.getPlayerType();\r\n    }\r\n    var cfg = playerConfig.getConfig();\r\n    if (cfg.html5) {\r\n      return \"html5\";\r\n    } else {\r\n      return \"flash\";\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Setting the player type to either HTML5 or flash\r\n  *\r\n  * @method setType\r\n  * @param {String} type The desired player type (HTML5 or flash).\r\n  **/\r\n  function setType(type) {\r\n    var currentType = getType();\r\n    if (type === currentType) {\r\n      return; // Do nothing as it\'s already the desired player type\r\n    } else {\r\n      var api = playerAPI.getAPI();\r\n      playerConfig.setConfig(\"html5\", (type === \"html5\" ? true : false)); // Setting the property html5 to either true or false\r\n      \r\n      // Soft-reloading the player. If YouTube detects that the html5 property has changed it will change the player.\r\n      if (api && typeof api.loadNewVideoConfig === \"function\") {\r\n        api.loadNewVideoConfig(uw.ytplayer.config);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Get the controlbar height.\r\n  *\r\n  * @method getControlbarHeight\r\n  * @return {Number} The height of the controlbar on the player.\r\n  **/\r\n  function getControlbarHeight() {\r\n    var none = 0;\r\n    var onlyControlbar = 3;\r\n    var onlyProgressbar = 30;\r\n    var both = 35;\r\n    \r\n    var cfg = playerConfig.getConfig();\r\n    var autohide = null;\r\n    \r\n    if (cfg && cfg.args && typeof cfg.args.autohide === \"string\") {\r\n      autohide = cfg.args.autohide;\r\n    } else if (getType() === \"html5\") {\r\n      var ratio = size.getRatio();\r\n      if (ratio < 1.35) {\r\n        autohide = \"3\";\r\n      }\r\n    }\r\n    \r\n    switch (autohide) {\r\n      case \"0\": return both;\r\n      case \"1\": return none;\r\n      case \"3\": return onlyControlbar;\r\n      case \"2\": default: return onlyProgressbar;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Calling yt.player.Application.create to tell YouTube to\r\n  * create the YouTube player again and dispose of the old\r\n  * player.\r\n  *\r\n  * @method reload\r\n  **/\r\n  function reload() {\r\n    if (uw && uw.yt && uw.yt.player && uw.yt.player.Application && typeof uw.yt.player.Application.create === \"function\") {\r\n      uw.yt.player.Application.create(\"player-api\", playerConfig.getConfig());\r\n    }\r\n  }\r\n  \r\n  exports.getType = getType;\r\n  exports.setType = setType;\r\n  exports.getControlbarHeight = getControlbarHeight;\r\n  exports.getAPI = playerAPI.getAPI;\r\n  exports.getConfig = playerConfig.getConfig;\r\n  exports.setConfig = playerConfig.setConfig;\r\n  exports.reload = reload;\r\n  return exports;\r\n});\n//# sourceURL=/player/player.js");

eval("define(\'main\',[\"player/player\", \"unsafeWindow\"], function(player, uw){\r\n  uw.player = player;\r\n});\n//# sourceURL=/main.js");


require(["main"]);
}());
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJtYWluLWFsbC5qcyIsCiAgInNvdXJjZXMiOiBbCiAgICAiLi4vdmVuZG9yL2FsbW9uZC5qcyIsCiAgICAidW5zYWZlV2luZG93LmpzIiwKICAgICJzdXBwb3J0LmpzIiwKICAgICJ1dGlscy5qcyIsCiAgICAicGxheWVyL2FwaS5qcyIsCiAgICAiY29uc29sZS5qcyIsCiAgICAicGxheWVyL2NvbmZpZy5qcyIsCiAgICAidW5zYWZlWW91VHViZUNlbnRlci5qcyIsCiAgICAicGxheWVyL29uWW91VHViZVBsYXllclJlYWR5LmpzIiwKICAgICJwYWdlbG9hZC5qcyIsCiAgICAieXRyZWFkeS5qcyIsCiAgICAicGxheWVyL2xpc3RlbmVycy5qcyIsCiAgICAid2luZG93LmpzIiwKICAgICJwbGF5ZXIvc2l6ZS5qcyIsCiAgICAicGxheWVyL3BsYXllci5qcyIsCiAgICAibWFpbi5qcyIKICBdLAogICJuYW1lcyI6IFtdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUNKQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EiLAogICJzb3VyY2VzQ29udGVudCI6IFsKICAgICJldmFsKFwiLyoqXFxyXFxuICogQGxpY2Vuc2UgYWxtb25kIDAuMi45IENvcHlyaWdodCAoYykgMjAxMS0yMDE0LCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxyXFxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cXHJcXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYWxtb25kIGZvciBkZXRhaWxzXFxyXFxuICovXFxyXFxuLy9Hb2luZyBzbG9wcHkgdG8gYXZvaWQgXFwndXNlIHN0cmljdFxcJyBzdHJpbmcgY29zdCwgYnV0IHN0cmljdCBwcmFjdGljZXMgc2hvdWxkXFxyXFxuLy9iZSBmb2xsb3dlZC5cXHJcXG4vKmpzbGludCBzbG9wcHk6IHRydWUgKi9cXHJcXG4vKmdsb2JhbCBzZXRUaW1lb3V0OiBmYWxzZSAqL1xcclxcblxcclxcbnZhciByZXF1aXJlanMsIHJlcXVpcmUsIGRlZmluZTtcXHJcXG4oZnVuY3Rpb24gKHVuZGVmKSB7XFxyXFxuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxcclxcbiAgICAgICAgZGVmaW5lZCA9IHt9LFxcclxcbiAgICAgICAgd2FpdGluZyA9IHt9LFxcclxcbiAgICAgICAgY29uZmlnID0ge30sXFxyXFxuICAgICAgICBkZWZpbmluZyA9IHt9LFxcclxcbiAgICAgICAgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcXHJcXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxcclxcbiAgICAgICAganNTdWZmaXhSZWdFeHAgPSAvXFxcXC5qcyQvO1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgcHJvcCkge1xcclxcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEdpdmVuIGEgcmVsYXRpdmUgbW9kdWxlIG5hbWUsIGxpa2UgLi9zb21ldGhpbmcsIG5vcm1hbGl6ZSBpdCB0b1xcclxcbiAgICAgKiBhIHJlYWwgbmFtZSB0aGF0IGNhbiBiZSBtYXBwZWQgdG8gYSBwYXRoLlxcclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxcclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZU5hbWUgYSByZWFsIG5hbWUgdGhhdCB0aGUgbmFtZSBhcmcgaXMgcmVsYXRpdmVcXHJcXG4gICAgICogdG8uXFxyXFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxcclxcbiAgICAgKi9cXHJcXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XFxyXFxuICAgICAgICB2YXIgbmFtZVBhcnRzLCBuYW1lU2VnbWVudCwgbWFwVmFsdWUsIGZvdW5kTWFwLCBsYXN0SW5kZXgsXFxyXFxuICAgICAgICAgICAgZm91bmRJLCBmb3VuZFN0YXJNYXAsIHN0YXJJLCBpLCBqLCBwYXJ0LFxcclxcbiAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lICYmIGJhc2VOYW1lLnNwbGl0KFxcXCIvXFxcIiksXFxyXFxuICAgICAgICAgICAgbWFwID0gY29uZmlnLm1hcCxcXHJcXG4gICAgICAgICAgICBzdGFyTWFwID0gKG1hcCAmJiBtYXBbXFwnKlxcJ10pIHx8IHt9O1xcclxcblxcclxcbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxcclxcbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09IFxcXCIuXFxcIikge1xcclxcbiAgICAgICAgICAgIC8vSWYgaGF2ZSBhIGJhc2UgbmFtZSwgdHJ5IHRvIG5vcm1hbGl6ZSBhZ2FpbnN0IGl0LFxcclxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcXHJcXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cXHJcXG4gICAgICAgICAgICBpZiAoYmFzZU5hbWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IGJhc2VOYW1lIHRvIGFycmF5LCBhbmQgbG9wIG9mZiB0aGUgbGFzdCBwYXJ0LFxcclxcbiAgICAgICAgICAgICAgICAvL3NvIHRoYXQgLiBtYXRjaGVzIHRoYXQgXFxcImRpcmVjdG9yeVxcXCIgYW5kIG5vdCBuYW1lIG9mIHRoZSBiYXNlTmFtZVxcJ3NcXHJcXG4gICAgICAgICAgICAgICAgLy9tb2R1bGUuIEZvciBpbnN0YW5jZSwgYmFzZU5hbWUgb2YgXFxcIm9uZS90d28vdGhyZWVcXFwiLCBtYXBzIHRvXFxyXFxuICAgICAgICAgICAgICAgIC8vXFxcIm9uZS90d28vdGhyZWUuanNcXFwiLCBidXQgd2Ugd2FudCB0aGUgZGlyZWN0b3J5LCBcXFwib25lL3R3b1xcXCIgZm9yXFxyXFxuICAgICAgICAgICAgICAgIC8vdGhpcyBub3JtYWxpemF0aW9uLlxcclxcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdChcXCcvXFwnKTtcXHJcXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBOb2RlIC5qcyBhbGxvd2FuY2U6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubm9kZUlkQ29tcGF0ICYmIGpzU3VmZml4UmVnRXhwLnRlc3QobmFtZVtsYXN0SW5kZXhdKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVtsYXN0SW5kZXhdID0gbmFtZVtsYXN0SW5kZXhdLnJlcGxhY2UoanNTdWZmaXhSZWdFeHAsIFxcJ1xcJyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IGJhc2VQYXJ0cy5jb25jYXQobmFtZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vc3RhcnQgdHJpbURvdHNcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpICs9IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBuYW1lW2ldO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09IFxcXCIuXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXFxcIi4uXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChuYW1lWzJdID09PSBcXCcuLlxcJyB8fCBuYW1lWzBdID09PSBcXCcuLlxcJykpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoIFxcJy4uXFwnLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2FuIHN0aWxsIGZhaWwsIGJ1dCBjYXRjaGVzIHRoZSBtb3N0IHJlYXNvbmFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91c2VzIG9mIC4uXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSAtIDEsIDIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC8vZW5kIHRyaW1Eb3RzXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmpvaW4oXFxcIi9cXFwiKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcXCcuL1xcJykgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gTm8gYmFzZU5hbWUsIHNvIHRoaXMgaXMgSUQgaXMgcmVzb2x2ZWQgcmVsYXRpdmVcXHJcXG4gICAgICAgICAgICAgICAgLy8gdG8gYmFzZVVybCwgcHVsbCBvZmYgdGhlIGxlYWRpbmcgZG90LlxcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMik7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy9BcHBseSBtYXAgY29uZmlnIGlmIGF2YWlsYWJsZS5cXHJcXG4gICAgICAgIGlmICgoYmFzZVBhcnRzIHx8IHN0YXJNYXApICYmIG1hcCkge1xcclxcbiAgICAgICAgICAgIG5hbWVQYXJ0cyA9IG5hbWUuc3BsaXQoXFwnL1xcJyk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChpID0gbmFtZVBhcnRzLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lU2VnbWVudCA9IG5hbWVQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFxcXCIvXFxcIik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUGFydHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbG9uZ2VzdCBiYXNlTmFtZSBzZWdtZW50IG1hdGNoIGluIHRoZSBjb25maWcuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvL1NvLCBkbyBqb2lucyBvbiB0aGUgYmlnZ2VzdCB0byBzbWFsbGVzdCBsZW5ndGhzIG9mIGJhc2VQYXJ0cy5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGJhc2VQYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFtiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbihcXCcvXFwnKV07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlTmFtZSBzZWdtZW50IGhhcyAgY29uZmlnLCBmaW5kIGlmIGl0IGhhcyBvbmUgZm9yXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIG5hbWUuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwVmFsdWVbbmFtZVNlZ21lbnRdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0Y2gsIHVwZGF0ZSBuYW1lIHRvIHRoZSBuZXcgdmFsdWUuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IG1hcFZhbHVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJID0gaTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy9DaGVjayBmb3IgYSBzdGFyIG1hcCBtYXRjaCwgYnV0IGp1c3QgaG9sZCBvbiB0byBpdCxcXHJcXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBhIHNob3J0ZXIgc2VnbWVudCBtYXRjaCBsYXRlciBpbiBhIG1hdGNoaW5nXFxyXFxuICAgICAgICAgICAgICAgIC8vY29uZmlnLCB0aGVuIGZhdm9yIG92ZXIgdGhpcyBzdGFyIG1hcC5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJNYXAgJiYgc3Rhck1hcCAmJiBzdGFyTWFwW25hbWVTZWdtZW50XSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFyTWFwID0gc3Rhck1hcFtuYW1lU2VnbWVudF07XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdGFySSA9IGk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKCFmb3VuZE1hcCAmJiBmb3VuZFN0YXJNYXApIHtcXHJcXG4gICAgICAgICAgICAgICAgZm91bmRNYXAgPSBmb3VuZFN0YXJNYXA7XFxyXFxuICAgICAgICAgICAgICAgIGZvdW5kSSA9IHN0YXJJO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZVBhcnRzLnNwbGljZSgwLCBmb3VuZEksIGZvdW5kTWFwKTtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVQYXJ0cy5qb2luKFxcJy9cXCcpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHJldHVybiBuYW1lO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIG1ha2VSZXF1aXJlKHJlbE5hbWUsIGZvcmNlU3luYykge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICAvL0EgdmVyc2lvbiBvZiBhIHJlcXVpcmUgZnVuY3Rpb24gdGhhdCBwYXNzZXMgYSBtb2R1bGVOYW1lXFxyXFxuICAgICAgICAgICAgLy92YWx1ZSBmb3IgaXRlbXMgdGhhdCBtYXkgbmVlZCB0b1xcclxcbiAgICAgICAgICAgIC8vbG9vayB1cCBwYXRocyByZWxhdGl2ZSB0byB0aGUgbW9kdWxlTmFtZVxcclxcbiAgICAgICAgICAgIHJldHVybiByZXEuYXBwbHkodW5kZWYsIGFwcy5jYWxsKGFyZ3VtZW50cywgMCkuY29uY2F0KFtyZWxOYW1lLCBmb3JjZVN5bmNdKSk7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoZGVwTmFtZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xcclxcbiAgICAgICAgICAgIGRlZmluZWRbZGVwTmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gY2FsbERlcChuYW1lKSB7XFxyXFxuICAgICAgICBpZiAoaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xcclxcbiAgICAgICAgICAgIHZhciBhcmdzID0gd2FpdGluZ1tuYW1lXTtcXHJcXG4gICAgICAgICAgICBkZWxldGUgd2FpdGluZ1tuYW1lXTtcXHJcXG4gICAgICAgICAgICBkZWZpbmluZ1tuYW1lXSA9IHRydWU7XFxyXFxuICAgICAgICAgICAgbWFpbi5hcHBseSh1bmRlZiwgYXJncyk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3AoZGVmaW5pbmcsIG5hbWUpKSB7XFxyXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcJ05vIFxcJyArIG5hbWUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGRlZmluZWRbbmFtZV07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy9UdXJucyBhIHBsdWdpbiFyZXNvdXJjZSB0byBbcGx1Z2luLCByZXNvdXJjZV1cXHJcXG4gICAgLy93aXRoIHRoZSBwbHVnaW4gYmVpbmcgdW5kZWZpbmVkIGlmIHRoZSBuYW1lXFxyXFxuICAgIC8vZGlkIG5vdCBoYXZlIGEgcGx1Z2luIHByZWZpeC5cXHJcXG4gICAgZnVuY3Rpb24gc3BsaXRQcmVmaXgobmFtZSkge1xcclxcbiAgICAgICAgdmFyIHByZWZpeCxcXHJcXG4gICAgICAgICAgICBpbmRleCA9IG5hbWUgPyBuYW1lLmluZGV4T2YoXFwnIVxcJykgOiAtMTtcXHJcXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XFxyXFxuICAgICAgICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xcclxcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhpbmRleCArIDEsIG5hbWUubGVuZ3RoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogTWFrZXMgYSBuYW1lIG1hcCwgbm9ybWFsaXppbmcgdGhlIG5hbWUsIGFuZCB1c2luZyBhIHBsdWdpblxcclxcbiAgICAgKiBmb3Igbm9ybWFsaXphdGlvbiBpZiBuZWNlc3NhcnkuIEdyYWJzIGEgcmVmIHRvIHBsdWdpblxcclxcbiAgICAgKiB0b28sIGFzIGFuIG9wdGltaXphdGlvbi5cXHJcXG4gICAgICovXFxyXFxuICAgIG1ha2VNYXAgPSBmdW5jdGlvbiAobmFtZSwgcmVsTmFtZSkge1xcclxcbiAgICAgICAgdmFyIHBsdWdpbixcXHJcXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpLFxcclxcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xcclxcblxcclxcbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xcclxcblxcclxcbiAgICAgICAgaWYgKHByZWZpeCkge1xcclxcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vTm9ybWFsaXplIGFjY29yZGluZ1xcclxcbiAgICAgICAgaWYgKHByZWZpeCkge1xcclxcbiAgICAgICAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luLm5vcm1hbGl6ZSkge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luLm5vcm1hbGl6ZShuYW1lLCBtYWtlTm9ybWFsaXplKHJlbE5hbWUpKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcXHJcXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpO1xcclxcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xcclxcbiAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcXHJcXG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XFxyXFxuICAgICAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL1VzaW5nIHJpZGljdWxvdXMgcHJvcGVydHkgbmFtZXMgZm9yIHNwYWNlIHJlYXNvbnNcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgZjogcHJlZml4ID8gcHJlZml4ICsgXFwnIVxcJyArIG5hbWUgOiBuYW1lLCAvL2Z1bGxOYW1lXFxyXFxuICAgICAgICAgICAgbjogbmFtZSxcXHJcXG4gICAgICAgICAgICBwcjogcHJlZml4LFxcclxcbiAgICAgICAgICAgIHA6IHBsdWdpblxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbWFrZUNvbmZpZyhuYW1lKSB7XFxyXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiAoY29uZmlnICYmIGNvbmZpZy5jb25maWcgJiYgY29uZmlnLmNvbmZpZ1tuYW1lXSkgfHwge307XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGhhbmRsZXJzID0ge1xcclxcbiAgICAgICAgcmVxdWlyZTogZnVuY3Rpb24gKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUobmFtZSk7XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgZXhwb3J0czogZnVuY3Rpb24gKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgZSA9IGRlZmluZWRbbmFtZV07XFxyXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlICE9PSBcXCd1bmRlZmluZWRcXCcpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkZWZpbmVkW25hbWVdID0ge30pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb2R1bGU6IGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgaWQ6IG5hbWUsXFxyXFxuICAgICAgICAgICAgICAgIHVyaTogXFwnXFwnLFxcclxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBkZWZpbmVkW25hbWVdLFxcclxcbiAgICAgICAgICAgICAgICBjb25maWc6IG1ha2VDb25maWcobmFtZSlcXHJcXG4gICAgICAgICAgICB9O1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICBtYWluID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKSB7XFxyXFxuICAgICAgICB2YXIgY2pzTW9kdWxlLCBkZXBOYW1lLCByZXQsIG1hcCwgaSxcXHJcXG4gICAgICAgICAgICBhcmdzID0gW10sXFxyXFxuICAgICAgICAgICAgY2FsbGJhY2tUeXBlID0gdHlwZW9mIGNhbGxiYWNrLFxcclxcbiAgICAgICAgICAgIHVzaW5nRXhwb3J0cztcXHJcXG5cXHJcXG4gICAgICAgIC8vVXNlIG5hbWUgaWYgbm8gcmVsTmFtZVxcclxcbiAgICAgICAgcmVsTmFtZSA9IHJlbE5hbWUgfHwgbmFtZTtcXHJcXG5cXHJcXG4gICAgICAgIC8vQ2FsbCB0aGUgY2FsbGJhY2sgdG8gZGVmaW5lIHRoZSBtb2R1bGUsIGlmIG5lY2Vzc2FyeS5cXHJcXG4gICAgICAgIGlmIChjYWxsYmFja1R5cGUgPT09IFxcJ3VuZGVmaW5lZFxcJyB8fCBjYWxsYmFja1R5cGUgPT09IFxcJ2Z1bmN0aW9uXFwnKSB7XFxyXFxuICAgICAgICAgICAgLy9QdWxsIG91dCB0aGUgZGVmaW5lZCBkZXBlbmRlbmNpZXMgYW5kIHBhc3MgdGhlIG9yZGVyZWRcXHJcXG4gICAgICAgICAgICAvL3ZhbHVlcyB0byB0aGUgY2FsbGJhY2suXFxyXFxuICAgICAgICAgICAgLy9EZWZhdWx0IHRvIFtyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGVdIGlmIG5vIGRlcHNcXHJcXG4gICAgICAgICAgICBkZXBzID0gIWRlcHMubGVuZ3RoICYmIGNhbGxiYWNrLmxlbmd0aCA/IFtcXCdyZXF1aXJlXFwnLCBcXCdleHBvcnRzXFwnLCBcXCdtb2R1bGVcXCddIDogZGVwcztcXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkgKz0gMSkge1xcclxcbiAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTWFwKGRlcHNbaV0sIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gbWFwLmY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vRmFzdCBwYXRoIENvbW1vbkpTIHN0YW5kYXJkIGRlcGVuZGVuY2llcy5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGRlcE5hbWUgPT09IFxcXCJyZXF1aXJlXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLnJlcXVpcmUobmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXFxcImV4cG9ydHNcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxcclxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLmV4cG9ydHMobmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB1c2luZ0V4cG9ydHMgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFxcXCJtb2R1bGVcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxcclxcbiAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlID0gYXJnc1tpXSA9IGhhbmRsZXJzLm1vZHVsZShuYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNQcm9wKGRlZmluZWQsIGRlcE5hbWUpIHx8XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcCh3YWl0aW5nLCBkZXBOYW1lKSB8fFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb3AoZGVmaW5pbmcsIGRlcE5hbWUpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gY2FsbERlcChkZXBOYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAucCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWFwLnAubG9hZChtYXAubiwgbWFrZVJlcXVpcmUocmVsTmFtZSwgdHJ1ZSksIG1ha2VMb2FkKGRlcE5hbWUpLCB7fSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gZGVmaW5lZFtkZXBOYW1lXTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXFwnIG1pc3NpbmcgXFwnICsgZGVwTmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0ID0gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseShkZWZpbmVkW25hbWVdLCBhcmdzKSA6IHVuZGVmaW5lZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobmFtZSkge1xcclxcbiAgICAgICAgICAgICAgICAvL0lmIHNldHRpbmcgZXhwb3J0cyB2aWEgXFxcIm1vZHVsZVxcXCIgaXMgaW4gcGxheSxcXHJcXG4gICAgICAgICAgICAgICAgLy9mYXZvciB0aGF0IG92ZXIgcmV0dXJuIHZhbHVlIGFuZCBleHBvcnRzLiBBZnRlciB0aGF0LFxcclxcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIGEgbm9uLXVuZGVmaW5lZCByZXR1cm4gdmFsdWUgb3ZlciBleHBvcnRzIHVzZS5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNqc01vZHVsZSAmJiBjanNNb2R1bGUuZXhwb3J0cyAhPT0gdW5kZWYgJiZcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUuZXhwb3J0cyAhPT0gZGVmaW5lZFtuYW1lXSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNqc01vZHVsZS5leHBvcnRzO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gdW5kZWYgfHwgIXVzaW5nRXhwb3J0cykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy9Vc2UgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSByZXQ7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICAvL01heSBqdXN0IGJlIGFuIG9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgbW9kdWxlLiBPbmx5XFxyXFxuICAgICAgICAgICAgLy93b3JyeSBhYm91dCBkZWZpbmluZyBpZiBoYXZlIGEgbW9kdWxlIG5hbWUuXFxyXFxuICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNhbGxiYWNrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICByZXF1aXJlanMgPSByZXF1aXJlID0gcmVxID0gZnVuY3Rpb24gKGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lLCBmb3JjZVN5bmMsIGFsdCkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1tkZXBzXSkge1xcclxcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGluIHRoaXMgY2FzZSBpcyByZWFsbHkgcmVsTmFtZVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnNbZGVwc10oY2FsbGJhY2spO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAvL0p1c3QgcmV0dXJuIHRoZSBtb2R1bGUgd2FudGVkLiBJbiB0aGlzIHNjZW5hcmlvLCB0aGVcXHJcXG4gICAgICAgICAgICAvL2RlcHMgYXJnIGlzIHRoZSBtb2R1bGUgbmFtZSwgYW5kIHNlY29uZCBhcmcgKGlmIHBhc3NlZClcXHJcXG4gICAgICAgICAgICAvL2lzIGp1c3QgdGhlIHJlbE5hbWUuXFxyXFxuICAgICAgICAgICAgLy9Ob3JtYWxpemUgbW9kdWxlIG5hbWUsIGlmIGl0IGNvbnRhaW5zIC4gb3IgLi5cXHJcXG4gICAgICAgICAgICByZXR1cm4gY2FsbERlcChtYWtlTWFwKGRlcHMsIGNhbGxiYWNrKS5mKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoIWRlcHMuc3BsaWNlKSB7XFxyXFxuICAgICAgICAgICAgLy9kZXBzIGlzIGEgY29uZmlnIG9iamVjdCwgbm90IGFuIGFycmF5LlxcclxcbiAgICAgICAgICAgIGNvbmZpZyA9IGRlcHM7XFxyXFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZXBzKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJlcShjb25maWcuZGVwcywgY29uZmlnLmNhbGxiYWNrKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5zcGxpY2UpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpcyBhbiBhcnJheSwgd2hpY2ggbWVhbnMgaXQgaXMgYSBkZXBlbmRlbmN5IGxpc3QuXFxyXFxuICAgICAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xcclxcbiAgICAgICAgICAgICAgICBkZXBzID0gY2FsbGJhY2s7XFxyXFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcmVsTmFtZTtcXHJcXG4gICAgICAgICAgICAgICAgcmVsTmFtZSA9IG51bGw7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgZGVwcyA9IHVuZGVmO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vU3VwcG9ydCByZXF1aXJlKFtcXCdhXFwnXSlcXHJcXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XFxyXFxuXFxyXFxuICAgICAgICAvL0lmIHJlbE5hbWUgaXMgYSBmdW5jdGlvbiwgaXQgaXMgYW4gZXJyYmFjayBoYW5kbGVyLFxcclxcbiAgICAgICAgLy9zbyByZW1vdmUgaXQuXFxyXFxuICAgICAgICBpZiAodHlwZW9mIHJlbE5hbWUgPT09IFxcJ2Z1bmN0aW9uXFwnKSB7XFxyXFxuICAgICAgICAgICAgcmVsTmFtZSA9IGZvcmNlU3luYztcXHJcXG4gICAgICAgICAgICBmb3JjZVN5bmMgPSBhbHQ7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL1NpbXVsYXRlIGFzeW5jIGNhbGxiYWNrO1xcclxcbiAgICAgICAgaWYgKGZvcmNlU3luYykge1xcclxcbiAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgLy9Vc2luZyBhIG5vbi16ZXJvIHZhbHVlIGJlY2F1c2Ugb2YgY29uY2VybiBmb3Igd2hhdCBvbGQgYnJvd3NlcnNcXHJcXG4gICAgICAgICAgICAvL2RvLCBhbmQgbGF0ZXN0IGJyb3dzZXJzIFxcXCJ1cGdyYWRlXFxcIiB0byA0IGlmIGxvd2VyIHZhbHVlIGlzIHVzZWQ6XFxyXFxuICAgICAgICAgICAgLy9odHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aW1lcnMuaHRtbCNkb20td2luZG93dGltZXJzLXNldHRpbWVvdXQ6XFxyXFxuICAgICAgICAgICAgLy9JZiB3YW50IGEgdmFsdWUgaW1tZWRpYXRlbHksIHVzZSByZXF1aXJlKFxcJ2lkXFwnKSBpbnN0ZWFkIC0tIHNvbWV0aGluZ1xcclxcbiAgICAgICAgICAgIC8vdGhhdCB3b3JrcyBpbiBhbG1vbmQgb24gdGhlIGdsb2JhbCBsZXZlbCwgYnV0IG5vdCBndWFyYW50ZWVkIGFuZFxcclxcbiAgICAgICAgICAgIC8vdW5saWtlbHkgdG8gd29yayBpbiBvdGhlciBBTUQgaW1wbGVtZW50YXRpb25zLlxcclxcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XFxyXFxuICAgICAgICAgICAgfSwgNCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICByZXR1cm4gcmVxO1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogSnVzdCBkcm9wcyB0aGUgY29uZmlnIG9uIHRoZSBmbG9vciwgYnV0IHJldHVybnMgcmVxIGluIGNhc2VcXHJcXG4gICAgICogdGhlIGNvbmZpZyByZXR1cm4gdmFsdWUgaXMgdXNlZC5cXHJcXG4gICAgICovXFxyXFxuICAgIHJlcS5jb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XFxyXFxuICAgICAgICByZXR1cm4gcmVxKGNmZyk7XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBFeHBvc2UgbW9kdWxlIHJlZ2lzdHJ5IGZvciBkZWJ1Z2dpbmcgYW5kIHRvb2xpbmdcXHJcXG4gICAgICovXFxyXFxuICAgIHJlcXVpcmVqcy5fZGVmaW5lZCA9IGRlZmluZWQ7XFxyXFxuXFxyXFxuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xcclxcblxcclxcbiAgICAgICAgLy9UaGlzIG1vZHVsZSBtYXkgbm90IGhhdmUgZGVwZW5kZW5jaWVzXFxyXFxuICAgICAgICBpZiAoIWRlcHMuc3BsaWNlKSB7XFxyXFxuICAgICAgICAgICAgLy9kZXBzIGlzIG5vdCBhbiBhcnJheSwgc28gcHJvYmFibHkgbWVhbnNcXHJcXG4gICAgICAgICAgICAvL2FuIG9iamVjdCBsaXRlcmFsIG9yIGZhY3RvcnkgZnVuY3Rpb24gZm9yXFxyXFxuICAgICAgICAgICAgLy90aGUgdmFsdWUuIEFkanVzdCBhcmdzLlxcclxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcXHJcXG4gICAgICAgICAgICBkZXBzID0gW107XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcXHJcXG4gICAgICAgICAgICB3YWl0aW5nW25hbWVdID0gW25hbWUsIGRlcHMsIGNhbGxiYWNrXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgZGVmaW5lLmFtZCA9IHtcXHJcXG4gICAgICAgIGpRdWVyeTogdHJ1ZVxcclxcbiAgICB9O1xcclxcbn0oKSk7XFxyXFxuXFxuLy8jIHNvdXJjZVVSTD0vLi4vdmVuZG9yL2FsbW9uZC5qc1wiKTtcblxuZGVmaW5lKFwiLi4vdmVuZG9yL2FsbW9uZFwiLCBmdW5jdGlvbigpe30pO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwndW5zYWZlV2luZG93XFwnLFtdLCBmdW5jdGlvbigpe1xcclxcbiAgcmV0dXJuIHdpbmRvdztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS91bnNhZmVXaW5kb3cuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdzdXBwb3J0XFwnLFtcXFwidW5zYWZlV2luZG93XFxcIl0sIGZ1bmN0aW9uKHV3KXtcXHJcXG4gIGZ1bmN0aW9uIGxvY2FsU3RvcmFnZVRlc3QoKSB7XFxyXFxuICAgIHZhciBtb2QgPSBcXFwic3VwcG9ydC50ZXN0XFxcIjtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XFxyXFxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcXHJcXG4gICAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgaXNXZWJraXRVUkwgPSB0eXBlb2YgdXcud2Via2l0VVJMID09PSBcXFwib2JqZWN0XFxcIjtcXHJcXG4gIHZhciBpc1VSTCA9IHR5cGVvZiB1dy5VUkwgPT09IFxcXCJvYmplY3RcXFwiO1xcclxcbiAgdmFyIGlzQ3JlYXRlT2JqZWN0VVJMID0gZmFsc2U7XFxyXFxuICB2YXIgaXNSZXZva2VPYmplY3RVUkwgPSBmYWxzZTtcXHJcXG4gIFxcclxcbiAgdmFyIG1heHRob25SdW50aW1lID0gd2luZG93ICYmIHdpbmRvdy5leHRlcm5hbCAmJiB3aW5kb3cuZXh0ZXJuYWwubXhHZXRSdW50aW1lICYmIHR5cGVvZiB3aW5kb3cuZXh0ZXJuYWwubXhHZXRSdW50aW1lID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgXFxyXFxuICBpZiAoaXNXZWJraXRVUkwpIHtcXHJcXG4gICAgaXNDcmVhdGVPYmplY3RVUkwgPSB0eXBlb2YgdXcud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gICAgaXNSZXZva2VPYmplY3RVUkwgPSB0eXBlb2YgdXcud2Via2l0VVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gIH0gZWxzZSBpZiAoaXNVUkwpIHtcXHJcXG4gICAgaXNDcmVhdGVPYmplY3RVUkwgPSB0eXBlb2YgdXcuVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gICAgaXNSZXZva2VPYmplY3RVUkwgPSB0eXBlb2YgdXcuVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgbG9jYWxTdG9yYWdlOiBsb2NhbFN0b3JhZ2VUZXN0KCksXFxyXFxuICAgIEdyZWFzZW1vbmtleTogKHR5cGVvZiBHTV9zZXRWYWx1ZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgKHR5cGVvZiBHTV9zZXRWYWx1ZS50b1N0cmluZyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgR01fc2V0VmFsdWUudG9TdHJpbmcoKS5pbmRleE9mKFxcXCJub3Qgc3VwcG9ydGVkXFxcIikgPT09IC0xKSksXFxyXFxuICAgIGNyZWF0ZU9iamVjdFVSTDogaXNDcmVhdGVPYmplY3RVUkwsXFxyXFxuICAgIHJldm9rZU9iamVjdFVSTDogaXNSZXZva2VPYmplY3RVUkwsXFxyXFxuICAgIHdlYmtpdFVSTDogaXNXZWJraXRVUkwsXFxyXFxuICAgIFVSTDogaXNVUkwsXFxyXFxuICAgIG1heHRob25SdW50aW1lOiBtYXh0aG9uUnVudGltZSxcXHJcXG4gICAgbWF4dGhvblJ1bnRpbWVTdG9yYWdlOiBtYXh0aG9uUnVudGltZSAmJiB3aW5kb3cuZXh0ZXJuYWwubXhHZXRSdW50aW1lKCkgJiYgd2luZG93LmV4dGVybmFsLm14R2V0UnVudGltZSgpLnN0b3JhZ2UsXFxyXFxuICAgIGZpcmVmb3hQb3J0OiB0aGlzLnBvcnQgJiYgdHlwZW9mIHRoaXMucG9ydC5yZXF1ZXN0ID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHRoaXMucG9ydC5zdG9yYWdlICYmIHR5cGVvZiB0aGlzLnBvcnQub24gPT09IFxcXCJmdW5jdGlvblxcXCJcXHJcXG4gIH07XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vc3VwcG9ydC5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3V0aWxzXFwnLFtcXFwic3VwcG9ydFxcXCIsIFxcXCJ1bnNhZmVXaW5kb3dcXFwiXSwgZnVuY3Rpb24oc3VwcG9ydCwgdXcpe1xcclxcbiAgZnVuY3Rpb24gZWFjaChvYmosIGNhbGxiYWNrKSB7XFxyXFxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgaWYgKGNhbGxiYWNrKGksIG9ialtpXSkgPT09IHRydWUpIGJyZWFrO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxyXFxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGtleSwgb2JqW2tleV0pID09PSB0cnVlKSBicmVhaztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcXHJcXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcXFwiW29iamVjdCBBcnJheV1cXFwiO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBhc3luY0NhbGwoc2NvcGUsIGNhbGxiYWNrKSB7XFxyXFxuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmQuYXBwbHkobnVsbCwgW3Njb3BlLCBjYWxsYmFja10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKSwgMCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGJpbmQoc2NvcGUsIGZ1bmMpIHtcXHJcXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcXHJcXG4gICAgICByZXR1cm4gZnVuYy5hcHBseShzY29wZSwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpXFxyXFxuICAgIH07XFxyXFxuICB9XFxyXFxuICBmdW5jdGlvbiB0cmltTGVmdChvYmope1xcclxcbiAgICByZXR1cm4gb2JqLnJlcGxhY2UoL15cXFxccysvLCBcXFwiXFxcIik7XFxyXFxuICB9XFxyXFxuICBmdW5jdGlvbiB0cmltUmlnaHQob2JqKXtcXHJcXG4gICAgcmV0dXJuIG9iai5yZXBsYWNlKC9cXFxccyskLywgXFxcIlxcXCIpO1xcclxcbiAgfVxcclxcbiAgZnVuY3Rpb24gbWFwKG9iaiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvYmoubGVuZ3RoLCBhID0gW107IGkgPCBuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoaSBpbiBvYmopIGFbaV0gPSBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIG9ialtpXSk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGE7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGRlZmluZUxvY2tlZFByb3BlcnR5KG9iaiwga2V5LCBzZXR0ZXIsIGdldHRlcikge1xcclxcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXFxcIm9iamVjdFxcXCIpIG9iaiA9IHt9O1xcclxcbiAgICBpZiAoaWUgfHwgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xcclxcbiAgICAgICAgZ2V0OiBnZXR0ZXIsXFxyXFxuICAgICAgICBzZXQ6IHNldHRlclxcclxcbiAgICAgIH0pO1xcclxcbiAgICAgIHJldHVybiBvYmo7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBnZXR0ZXIpO1xcclxcbiAgICAgIG9iai5fX2RlZmluZVNldHRlcl9fKGtleSwgc2V0dGVyKTtcXHJcXG4gICAgICByZXR1cm4gb2JqO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWxtLCBldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcXHJcXG4gICAgaWYgKGVsbS5hZGRFdmVudExpc3RlbmVyKSB7XFxyXFxuICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcXHJcXG4gICAgfSBlbHNlIGlmIChlbG0uYXR0YWNoRXZlbnQpIHtcXHJcXG4gICAgICBlbG0uYXR0YWNoRXZlbnQoXFxcIm9uXFxcIiArIGV2ZW50LCBjYWxsYmFjayk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbG0sIGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xcclxcbiAgICBpZiAoZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXHJcXG4gICAgICBlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xcclxcbiAgICB9IGVsc2UgaWYgKGVsbS5kZXRhY2hFdmVudCkge1xcclxcbiAgICAgIGVsbS5kZXRhY2hFdmVudChcXFwib25cXFwiICsgZXZlbnQsIGNhbGxiYWNrKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgaWUgPSAoZnVuY3Rpb24oKXtcXHJcXG4gICAgZm9yICh2YXIgdiA9IDMsIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXCdiXFwnKSwgYWxsID0gZWwuYWxsIHx8IFtdOyBlbC5pbm5lckhUTUwgPSBcXCc8IS0tW2lmIGd0IElFIFxcJyArICgrK3YpICsgXFwnXT48aT48IVtlbmRpZl0tLT5cXCcsIGFsbFswXTspO1xcclxcbiAgICByZXR1cm4gdiA+IDQgPyB2IDogISFkb2N1bWVudC5kb2N1bWVudE1vZGU7XFxyXFxuICB9KCkpO1xcclxcbiAgXFxyXFxuICB2YXIgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xcclxcbiAgICByZXR1cm4gK25ldyBEYXRlO1xcclxcbiAgfTtcXHJcXG4gIFxcclxcbiAgLyogQ29va2llcyAqL1xcclxcbiAgZnVuY3Rpb24gc2V0Q29va2llKG5hbWUsIHZhbHVlLCBkb21haW4sIHBhdGgsIGV4cGlyZXMpIHtcXHJcXG4gICAgZG9tYWluID0gZG9tYWluID8gXFxcIjtkb21haW49XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChkb21haW4pIDogXFxcIlxcXCI7XFxyXFxuICAgIHBhdGggPSBwYXRoID8gXFxcIjtwYXRoPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQocGF0aCkgOiBcXFwiXFxcIjtcXHJcXG4gICAgZXhwaXJlcyA9IDAgPiBleHBpcmVzID8gXFxcIlxcXCIgOiAwID09IGV4cGlyZXMgPyBcXFwiO2V4cGlyZXM9XFxcIiArIChuZXcgRGF0ZSgxOTcwLCAxLCAxKSkudG9VVENTdHJpbmcoKSA6IFxcXCI7ZXhwaXJlcz1cXFwiICsgKG5ldyBEYXRlKG5vdygpICsgMUUzICogZXhwaXJlcykpLnRvVVRDU3RyaW5nKCk7XFxyXFxuICAgIFxcclxcbiAgICBkb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyBcXFwiPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZG9tYWluICsgcGF0aCArIGV4cGlyZXM7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldENvb2tpZShrZXkpIHtcXHJcXG4gICAgcmV0dXJuIGdldENvb2tpZXMoKVtrZXldO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRDb29raWVzKCkge1xcclxcbiAgICB2YXIgYyA9IGRvY3VtZW50LmNvb2tpZSwgdiA9IDAsIGNvb2tpZXMgPSB7fTtcXHJcXG4gICAgaWYgKGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvXlxcXFxzKlxcXFwkVmVyc2lvbj0oPzpcXFwiMVxcXCJ8MSk7XFxcXHMqKC4qKS8pKSB7XFxyXFxuICAgICAgYyA9IFJlZ0V4cC4kMTtcXHJcXG4gICAgICB2ID0gMTtcXHJcXG4gICAgfVxcclxcbiAgICBpZiAodiA9PT0gMCkge1xcclxcbiAgICAgIG1hcChjLnNwbGl0KC9bLDtdLyksIGZ1bmN0aW9uKGNvb2tpZSkge1xcclxcbiAgICAgICAgdmFyIHBhcnRzID0gY29va2llLnNwbGl0KC89LywgMiksXFxyXFxuICAgICAgICAgICAgbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0cmltTGVmdChwYXJ0c1swXSkpLFxcclxcbiAgICAgICAgICAgIHZhbHVlID0gcGFydHMubGVuZ3RoID4gMSA/IGRlY29kZVVSSUNvbXBvbmVudCh0cmltUmlnaHQocGFydHNbMV0pKSA6IG51bGw7XFxyXFxuICAgICAgICBjb29raWVzW25hbWVdID0gdmFsdWU7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgbWFwKGMubWF0Y2goLyg/Ol58XFxcXHMrKShbISMkJSZcXCcqK1xcXFwtLjAtOUEtWl5gYS16fH5dKyk9KFshIyQlJlxcJyorXFxcXC0uMC05QS1aXmBhLXp8fl0qfFxcXCIoPzpbXFxcXHgyMC1cXFxceDdFXFxcXHg4MFxcXFx4RkZdfFxcXFxcXFxcW1xcXFx4MDAtXFxcXHg3Rl0pKlxcXCIpKD89XFxcXHMqWyw7XXwkKS9nKSwgZnVuY3Rpb24oJDAsICQxKSB7XFxyXFxuICAgICAgICB2YXIgbmFtZSA9ICQwLCB2YWx1ZSA9ICQxLmNoYXJBdCgwKSA9PT0gXFwnXFxcIlxcJyA/ICQxLnN1YnN0cigxLCAtMSkucmVwbGFjZSgvXFxcXFxcXFwoLikvZywgXFxcIiQxXFxcIikgOiAkMTtcXHJcXG4gICAgICAgIGNvb2tpZXNbbmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gY29va2llcztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcXHJcXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaW5qZWN0KGZ1bmMpIHtcXHJcXG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLFxcclxcbiAgICAgICAgcCA9IChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcXHJcXG4gICAgaWYgKCFwKSB7XFxyXFxuICAgICAgdGhyb3cgXFxcIkNvdWxkIG5vdCBpbmplY3QhISFcXFwiO1xcclxcbiAgICB9XFxyXFxuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwidGV4dC9qYXZhc2NyaXB0XFxcIik7XFxyXFxuICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcXFwiKFxcXCIgKyBmdW5jICsgXFxcIikoXFxcIiArIGJ1aWxkQXJndW1lbnRMaXN0LmFwcGx5KG51bGwsIFtmYWxzZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKSArIFxcXCIpO1xcXCIpKTtcXHJcXG4gICAgcC5hcHBlbmRDaGlsZChzY3JpcHQpO1xcclxcbiAgICBwLnJlbW92ZUNoaWxkKHNjcmlwdCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGJ1aWxkQXJndW1lbnRMaXN0KHdyYXApIHtcXHJcXG4gICAgdmFyIGxpc3QgPSBbXTtcXHJcXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goXFxcIlxcXFxcXFwiXFxcIiArIGFyZ3NbaV0ucmVwbGFjZSgvXFxcXFxcXFwvLCBcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcXCIvZywgXFxcIlxcXFxcXFxcXFxcXFxcXCJcXFwiKSArIFxcXCJcXFxcXFxcIlxcXCIpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goSlNPTi5zdHJpbmdpZnkoYXJnc1tpXSkpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goXFxcIm51bGxcXFwiKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgbGlzdC5wdXNoKGFyZ3NbaV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBpZiAod3JhcCkge1xcclxcbiAgICAgIHJldHVybiBcXFwiKFxcXCIgKyBsaXN0LmpvaW4oXFxcIixcXFwiKSArIFxcXCIpXFxcIjtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICByZXR1cm4gbGlzdC5qb2luKFxcXCIsXFxcIik7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaXNKU09OU3RyaW5nKGpzb24pIHtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICBKU09OLnBhcnNlKGpzb24pO1xcclxcbiAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiB0cnVlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB4aHIoZGV0YWlscykge1xcclxcbiAgICB2YXIgeG1saHR0cDtcXHJcXG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXHJcXG4gICAgICB4bWxodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxyXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wZXJhICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0eXBlb2Ygb3BlcmEuWE1MSHR0cFJlcXVlc3QgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxyXFxuICAgICAgeG1saHR0cCA9IG5ldyBvcGVyYS5YTUxIdHRwUmVxdWVzdCgpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGlmIChkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0pIHtcXHJcXG4gICAgICAgIGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSgpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICBcXHJcXG4gICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG4gICAgeG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xcclxcbiAgICAgIHZhciByZXNwb25zZVN0YXRlID0ge1xcclxcbiAgICAgICAgcmVzcG9uc2VYTUw6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5yZXNwb25zZVhNTCA6IFxcJ1xcJyksXFxyXFxuICAgICAgICByZXNwb25zZVRleHQ6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5yZXNwb25zZVRleHQgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgcmVhZHlTdGF0ZTp4bWxodHRwLnJlYWR5U3RhdGUsXFxyXFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSA6IFxcJ1xcJyksXFxyXFxuICAgICAgICBzdGF0dXM6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5zdGF0dXMgOiAwKSxcXHJcXG4gICAgICAgIHN0YXR1c1RleHQ6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5zdGF0dXNUZXh0IDogXFwnXFwnKSxcXHJcXG4gICAgICAgIGZpbmFsVXJsOih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuZmluYWxVcmwgOiBcXCdcXCcpXFxyXFxuICAgICAgfTtcXHJcXG4gICAgICBpZiAoZGV0YWlsc1tcXFwib25yZWFkeXN0YXRlY2hhbmdlXFxcIl0pIHtcXHJcXG4gICAgICAgIGRldGFpbHNbXFxcIm9ucmVhZHlzdGF0ZWNoYW5nZVxcXCJdKHJlc3BvbnNlU3RhdGUpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICBpZiAoeG1saHR0cC5yZWFkeVN0YXRlID09IDQpIHtcXHJcXG4gICAgICAgIGlmIChkZXRhaWxzW1xcXCJvbmxvYWRcXFwiXSAmJiB4bWxodHRwLnN0YXR1cyA+PSAyMDAgJiYgeG1saHR0cC5zdGF0dXMgPCAzMDApIHtcXHJcXG4gICAgICAgICAgZGV0YWlsc1tcXFwib25sb2FkXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAoZGV0YWlsc1tcXFwib25lcnJvclxcXCJdICYmICh4bWxodHRwLnN0YXR1cyA8IDIwMCB8fCB4bWxodHRwLnN0YXR1cyA+PSAzMDApKSB7XFxyXFxuICAgICAgICAgIGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH07XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgeG1saHR0cC5vcGVuKGRldGFpbHMubWV0aG9kLCBkZXRhaWxzLnVybCk7XFxyXFxuICAgIH0gY2F0Y2goZSkge1xcclxcbiAgICAgIGlmKGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSkge1xcclxcbiAgICAgICAgZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKHtyZXNwb25zZVhNTDpcXCdcXCcscmVzcG9uc2VUZXh0OlxcJ1xcJyxyZWFkeVN0YXRlOjQscmVzcG9uc2VIZWFkZXJzOlxcJ1xcJyxzdGF0dXM6NDAzLHN0YXR1c1RleHQ6XFwnRm9yYmlkZGVuXFwnfSk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcbiAgICBpZiAoZGV0YWlscy5oZWFkZXJzKSB7XFxyXFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZXRhaWxzLmhlYWRlcnMpIHtcXHJcXG4gICAgICAgIHhtbGh0dHAuc2V0UmVxdWVzdEhlYWRlcihwcm9wLCBkZXRhaWxzLmhlYWRlcnNbcHJvcF0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB4bWxodHRwLnNlbmQoKHR5cGVvZihkZXRhaWxzLmRhdGEpICE9IFxcJ3VuZGVmaW5lZFxcJykgPyBkZXRhaWxzLmRhdGEgOiBudWxsKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gVXNlZCBmb3IgdGhlIG1lc3NhZ2UgbW9kdWxlIChzaG91bGQgcHJvYmFibHkgbW92ZSB0byBhbm90aGVyIHBsYWNlKVxcclxcbiAgLy8gSXQgcmVwbGFjZXMgYSBwcm9wZXJ0eSBpbiB0aGUgb2JqIHRvIGEgcHJlZGVmaW5lZCBmdW5jdGlvbiwgd2hlcmUgdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGNhbGxiYWNrSWQsIHRhcmdldCwgcmVmZXJlclxcclxcbiAgZnVuY3Rpb24gYmluZEZ1bmN0aW9uQ2FsbGJhY2tzKG9iaiwgZnVuYywgdGFyZ2V0LCByZWZlcmVyKSB7XFxyXFxuICAgIGZvciAoa2V5IGluIG9iaikge1xcclxcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXFxcIm9ialxcXCIpIHtcXHJcXG4gICAgICAgICAgYmluZEZ1bmN0aW9uQ2FsbGJhY2tzKG9ialtrZXldKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgICBpZiAob2JqW2tleV0uaW5kZXhPZihcXFwiQC8obWVzc2FnZS5jYWxsYmFjaykvXFxcIikgPT09IDApIHtcXHJcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tJZCA9IG9ialtrZXldLnNwbGl0KFxcXCJALyhtZXNzYWdlLmNhbGxiYWNrKS9cXFwiKVsxXTtcXHJcXG4gICAgICAgICAgICBvYmpba2V5XSA9IGJpbmQobnVsbCwgZnVuYywgY2FsbGJhY2tJZCwgdGFyZ2V0LCByZWZlcmVyKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBleHRlbmQob2JqLCBkZWZhdWx0cywgZGVlcCkge1xcclxcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIG9iai5cXFwiKTtcXHJcXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0cyAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIGRlZmF1bHRzLlxcXCIpO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XFxyXFxuICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBkZWZhdWx0c1trZXldID09PSBcXFwib2JqZWN0XFxcIiAmJiBkZWVwKSB7XFxyXFxuICAgICAgICAgIGV4dGVuZChvYmpba2V5XSwgZGVmYXVsdHNba2V5XSwgZGVlcCk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBvYmo7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluQXJyYXkoa2V5LCBhcnIpIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChhcnJbaV0gPT09IGtleSkge1xcclxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBmYWxzZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbGlzdENsYXNzZXMoZWwpIHtcXHJcXG4gICAgaWYgKCFlbCB8fCAhZWwuY2xhc3NOYW1lKSByZXR1cm4gW107XFxyXFxuICAgIHJldHVybiBlbC5jbGFzc05hbWUuc3BsaXQoXFxcIiBcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xcclxcbiAgICB2YXIgY2xhc3NlcyA9IGxpc3RDbGFzc2VzKGVsKTtcXHJcXG4gICAgdmFyIGFkZExpc3QgPSBjbGFzc05hbWUuc3BsaXQoXFxcIiBcXFwiKTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhZGRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKCFpbkFycmF5KGFkZExpc3RbaV0sIGNsYXNzZXMpKSB7XFxyXFxuICAgICAgICBlbC5jbGFzc05hbWUgKz0gXFxcIiBcXFwiICsgYWRkTGlzdFtpXTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xcclxcbiAgICB2YXIgY2xhc3NlcyA9IGxpc3RDbGFzc2VzKGVsKTtcXHJcXG4gICAgdmFyIHJlbW92ZUxpc3QgPSBjbGFzc05hbWUuc3BsaXQoXFxcIiBcXFwiKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBidWZmZXIgPSBbXTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoIWluQXJyYXkoY2xhc3Nlc1tpXSwgcmVtb3ZlTGlzdCkpIHtcXHJcXG4gICAgICAgIGJ1ZmZlci5wdXNoKGNsYXNzZXNbaV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lID0gYnVmZmVyLmpvaW4oXFxcIiBcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xcclxcbiAgICByZXR1cm4gaW5BcnJheShjbGFzc05hbWUsIGxpc3RDbGFzc2VzKGVsKSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGRlbGF5LCBvcHRpb25zKXtcXHJcXG4gICAgZnVuY3Rpb24gdGltZW91dCgpIHtcXHJcXG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogbmV3IERhdGU7XFxyXFxuICAgICAgdGltZXIgPSBudWxsO1xcclxcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XFxyXFxuICAgIH1cXHJcXG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdCwgdGltZXIgPSBudWxsLCBwcmV2aW91cyA9IDA7XFxyXFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcXHJcXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUsIGR0O1xcclxcbiAgICAgIFxcclxcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xcclxcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XFxyXFxuICAgICAgXFxyXFxuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcXHJcXG4gICAgICBkdCA9IGRlbGF5IC0gKG5vdyAtIHByZXZpb3VzKTtcXHJcXG4gICAgICBcXHJcXG4gICAgICBpZiAoZHQgPD0gMCkge1xcclxcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXHJcXG4gICAgICAgIHRpbWVyID0gbnVsbDtcXHJcXG4gICAgICAgIHByZXZpb3VzID0gbm93O1xcclxcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKCF0aW1lciAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xcclxcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVvdXQsIGR0KTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgfTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XFxyXFxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycikge1xcclxcbiAgICB2YXIgdW5pcXVlQXJyID0gW107XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoIWluQXJyYXkodW5pcXVlQXJyLCBhcnJbaV0pKSB7XFxyXFxuICAgICAgICB1bmlxdWVBcnIucHVzaChhcnJbaV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHVuaXF1ZUFycjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xcclxcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXFxcLVxcXFxbXFxcXF1cXFxcL1xcXFx7XFxcXH1cXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFw/XFxcXC5cXFxcXFxcXFxcXFxeXFxcXCRcXFxcfF0vZywgXFxcIlxcXFxcXFxcJCZcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdG9CbG9iKGJ5dGVzLCBjb250ZW50VHlwZSkge1xcclxcbiAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8IFxcXCJ0ZXh0L3BsYWluXFxcIjtcXHJcXG4gICAgdmFyIHNsaWNlU2l6ZSA9IDUxMjtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBieXRlc0xlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcXHJcXG4gICAgdmFyIHNsaWNlc0NvdW50ID0gTWF0aC5jZWlsKGJ5dGVzTGVuZ3RoIC8gc2xpY2VTaXplKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBieXRlQXJyYXlzID0gbmV3IEFycmF5KHNsaWNlc0NvdW50KTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIHNsaWNlSW5kZXggPSAwOyBzbGljZUluZGV4IDwgc2xpY2VzQ291bnQ7ICsrc2xpY2VJbmRleCkge1xcclxcbiAgICAgIHZhciBiZWdpbiA9IHNsaWNlSW5kZXggKiBzbGljZVNpemU7XFxyXFxuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGJlZ2luICsgc2xpY2VTaXplLCBieXRlc0xlbmd0aCk7XFxyXFxuICAgICAgXFxyXFxuICAgICAgdmFyIHNsaWNlQnl0ZXMgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pO1xcclxcbiAgICAgIGZvciAodmFyIG9mZnNldCA9IGJlZ2luLCBpID0gMCA7IG9mZnNldCA8IGVuZDsgKytpLCArK29mZnNldCkge1xcclxcbiAgICAgICAgc2xpY2VCeXRlc1tpXSA9IGJ5dGVzW29mZnNldF0uY2hhckNvZGVBdCgwKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgYnl0ZUFycmF5c1tzbGljZUluZGV4XSA9IG5ldyBVaW50OEFycmF5KHNsaWNlQnl0ZXMpO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBjb250ZW50VHlwZSB9KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKGJsb2IpIHtcXHJcXG4gICAgaWYgKHN1cHBvcnQuY3JlYXRlT2JqZWN0VVJMKSB7XFxyXFxuICAgICAgaWYgKHN1cHBvcnQud2Via2l0VVJMKSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIHV3LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHRocm93IFxcXCJjcmVhdGVPYmplY3RVUkwgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciFcXFwiO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJldm9rZU9iamVjdFVSTCh1cmwpIHtcXHJcXG4gICAgaWYgKHN1cHBvcnQucmV2b2tlT2JqZWN0VVJMKSB7XFxyXFxuICAgICAgaWYgKHN1cHBvcnQud2Via2l0VVJMKSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcud2Via2l0VVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB0aHJvdyBcXFwicmV2b2tlT2JqZWN0VVJMIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIhXFxcIjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvLyBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XFxyXFxuICBmdW5jdGlvbiBnZXRSYW5kb21BcmJpdHJhcnkobWluLCBtYXgpIHtcXHJcXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIChpbmNsdWRlZCkgYW5kIG1heCAoZXhjbHVkZWQpXFxyXFxuICBmdW5jdGlvbiBnZXRSYW5kb21JbnQobWluLCBtYXgpIHtcXHJcXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gUmV0dXJucyBhIHJhbmRvbSBzdHJpbmcgb2YgY2hhcmFjdGVycyBvZiBjaGFycyB3aXRoIHRoZSBsZW5ndGggb2YgbGVuZ3RoXFxyXFxuICBmdW5jdGlvbiBnZW5lcmF0ZVRva2VuKGNoYXJzLCBsZW5ndGgpIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBjaGFycyAhPT0gXFxcInN0cmluZ1xcXCIpIGNoYXJzID0gXFxcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5LV9cXFwiO1xcclxcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gXFxcIm51bWJlclxcXCIpIGxlbmd0aCA9IDY0O1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIHRva2VuID0gXFxcIlxcXCI7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICB0b2tlbiArPSBjaGFyc1tnZXRSYW5kb21JbnQoMCwgY2hhcnNMZW5ndGgpXTtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHRva2VuO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBlc2NhcGVFQ01BVmFyaWFibGUoa2V5LCBkZWZhdWx0S2V5KSB7XFxyXFxuICAgIGtleSA9IGtleS5yZXBsYWNlKC9bXjAtOWEtekEtWl9cXFxcJF0vZywgXFxcIlxcXCIpO1xcclxcbiAgICB3aGlsZSAoLyRbMC05XS9nLnRlc3Qoa2V5KSAmJiBrZXkubGVuZ3RoID4gMCkge1xcclxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJcXFwiKSByZXR1cm4gZGVmYXVsdEtleTtcXHJcXG4gICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDEpO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBrZXk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluZGV4T2ZBcnJheSh2YWx1ZSwgYXJyKSB7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoYXJyW2ldID09PSB2YWx1ZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiAtMTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0S2V5cyhvYmopIHtcXHJcXG4gICAgdmFyIGtleXMgPSBbXTtcXHJcXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKGtleSl7XFxyXFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxyXFxuICAgIH0pO1xcclxcbiAgICByZXR1cm4ga2V5cztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0UHJvcGVydHkodGFyZ2V0LCBwYXRoLCB2YWx1ZSwgY3JlYXRlUGF0aCkge1xcclxcbiAgICB2YXIgdG9rZW5zID0gcGF0aC5zcGxpdChcXFwiLlxcXCIpO1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmICh0YXJnZXRbdG9rZW5zW2ldXSkge1xcclxcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3Rva2Vuc1tpXV07XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGlmIChjcmVhdGVQYXRoKSB7XFxyXFxuICAgICAgICAgIHRhcmdldFt0b2tlbnNbaV1dID0ge307XFxyXFxuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFt0b2tlbnNbaV1dO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgdGhyb3cgXFxcIlBhdGggXFxcIiArIHBhdGggKyBcXFwiIGRvZXMgbm90IGV4aXN0IGZvclxcXCIsIHRhcmdldDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgdGFyZ2V0W3Rva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1dID0gdmFsdWU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcXHJcXG4gICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxcclxcbiAgICBhZGRDbGFzczogYWRkQ2xhc3MsXFxyXFxuICAgIGVhY2g6IGVhY2gsXFxyXFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXFxyXFxuICAgIGluQXJyYXk6IGluQXJyYXksXFxyXFxuICAgIGJpbmQ6IGJpbmQsXFxyXFxuICAgIGFzeW5jQ2FsbDogYXN5bmNDYWxsLFxcclxcbiAgICBkZWZpbmVMb2NrZWRQcm9wZXJ0eTogZGVmaW5lTG9ja2VkUHJvcGVydHksXFxyXFxuICAgIGllOiBpZSxcXHJcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lcixcXHJcXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRXZlbnRMaXN0ZW5lcixcXHJcXG4gICAgbm93OiBub3csXFxyXFxuICAgIHRyaW1MZWZ0OiB0cmltTGVmdCxcXHJcXG4gICAgdHJpbVJpZ2h0OiB0cmltUmlnaHQsXFxyXFxuICAgIG1hcDogbWFwLFxcclxcbiAgICBzZXRDb29raWU6IHNldENvb2tpZSxcXHJcXG4gICAgZ2V0Q29va2llOiBnZXRDb29raWUsXFxyXFxuICAgIGdldENvb2tpZXM6IGdldENvb2tpZXMsXFxyXFxuICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcXHJcXG4gICAgaW5qZWN0OiBpbmplY3QsXFxyXFxuICAgIGlzSlNPTlN0cmluZzogaXNKU09OU3RyaW5nLFxcclxcbiAgICB4aHI6IHhocixcXHJcXG4gICAgYnVpbGRBcmd1bWVudExpc3Q6IGJ1aWxkQXJndW1lbnRMaXN0LFxcclxcbiAgICBiaW5kRnVuY3Rpb25DYWxsYmFja3M6IGJpbmRGdW5jdGlvbkNhbGxiYWNrcyxcXHJcXG4gICAgZXh0ZW5kOiBleHRlbmQsXFxyXFxuICAgIHRocm90dGxlOiB0aHJvdHRsZSxcXHJcXG4gICAgY2xvbmU6IGNsb25lLFxcclxcbiAgICByZW1vdmVEdXBsaWNhdGVzOiByZW1vdmVEdXBsaWNhdGVzLFxcclxcbiAgICBlc2NhcGVSZWdFeHA6IGVzY2FwZVJlZ0V4cCxcXHJcXG4gICAgdG9CbG9iOiB0b0Jsb2IsXFxyXFxuICAgIGNyZWF0ZU9iamVjdFVSTDogY3JlYXRlT2JqZWN0VVJMLFxcclxcbiAgICByZXZva2VPYmplY3RVUkw6IHJldm9rZU9iamVjdFVSTCxcXHJcXG4gICAgZ2V0UmFuZG9tQXJiaXRyYXJ5OiBnZXRSYW5kb21BcmJpdHJhcnksXFxyXFxuICAgIGdldFJhbmRvbUludDogZ2V0UmFuZG9tSW50LFxcclxcbiAgICBnZW5lcmF0ZVRva2VuOiBnZW5lcmF0ZVRva2VuLFxcclxcbiAgICBlc2NhcGVFQ01BVmFyaWFibGU6IGVzY2FwZUVDTUFWYXJpYWJsZSxcXHJcXG4gICAgaW5kZXhPZkFycmF5OiBpbmRleE9mQXJyYXksXFxyXFxuICAgIGdldEtleXM6IGdldEtleXMsXFxyXFxuICAgIHNldFByb3BlcnR5OiBzZXRQcm9wZXJ0eVxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS91dGlscy5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9hcGlcXCcsW1xcXCJ1bnNhZmVXaW5kb3dcXFwiLCBcXFwidXRpbHNcXFwiXSwgZnVuY3Rpb24odW5zYWZlV2luZG93LCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBnZXRBUEkoKSB7XFxyXFxuICAgIGlmICghYXBpQ2FjaGUpIHtcXHJcXG4gICAgICBhcGlDYWNoZSA9IGJpbmRQbGF5ZXJBUEkoKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gYXBpQ2FjaGU7XFxyXFxuICB9XFxyXFxuICBmdW5jdGlvbiBzZXRBUEkoYXBpKSB7XFxyXFxuICAgIGFwaUNhY2hlID0gYXBpO1xcclxcbiAgfVxcclxcbiAgZnVuY3Rpb24gYmluZFBsYXllckFQSSgpIHtcXHJcXG4gICAgdmFyIHBsYXllciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJtb3ZpZV9wbGF5ZXJcXFwiKTtcXHJcXG4gICAgdmFyIGFwaSA9IHt9O1xcclxcbiAgICBcXHJcXG4gICAgaWYgKHBsYXllciAmJiBwbGF5ZXIuZ2V0QXBpSW50ZXJmYWNlKSB7XFxyXFxuICAgICAgdmFyIGFwaUludGVyZmFjZSA9IHBsYXllci5nZXRBcGlJbnRlcmZhY2UoKTtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXBpSW50ZXJmYWNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICBhcGlbYXBpSW50ZXJmYWNlW2ldXSA9IHV0aWxzLmJpbmQocGxheWVyLCBwbGF5ZXJbYXBpSW50ZXJmYWNlW2ldXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBhcGk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBhcGlDYWNoZSA9IG51bGw7XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGdldEFQSTogZ2V0QVBJLFxcclxcbiAgICBzZXRBUEk6IHNldEFQSVxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvYXBpLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnY29uc29sZVxcJyxbXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKHV0aWxzKXtcXHJcXG4gIGZ1bmN0aW9uIHNldEVuYWJsZWQoYikge1xcclxcbiAgICBlbmFibGVkID0gYjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbG9nKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsIFxcXCJpbmplY3RlZFtcXFwiICsgc2Vzc2lvblRva2VuICsgXFxcIl1cXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXJyb3IoKSB7XFxyXFxuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcXHJcXG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlLCBcXFwiaW5qZWN0ZWRbXFxcIiArIHNlc3Npb25Ub2tlbiArIFxcXCJdXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHdhcm4oKSB7XFxyXFxuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcXHJcXG4gICAgcmV0dXJuIGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUsIFxcXCJpbmplY3RlZFtcXFwiICsgc2Vzc2lvblRva2VuICsgXFxcIl1cXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIHNlc3Npb25Ub2tlbiA9ICh0eXBlb2YgY29uc29sZVNlc3Npb25Ub2tlbiA9PT0gXFxcInN0cmluZ1xcXCIgPyBjb25zb2xlU2Vzc2lvblRva2VuIDogdXRpbHMuZ2VuZXJhdGVUb2tlbihudWxsLCA4KSk7XFxyXFxuICBcXHJcXG4gIHZhciBlbmFibGVkID0gdHJ1ZTtcXHJcXG4gIFxcclxcbiAgdmFyIGNvbiA9IHt9O1xcclxcbiAgXFxyXFxuICBjb24uc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xcclxcbiAgXFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShjb24sIFxcXCJsb2dcXFwiLCBmdW5jdGlvbigpe30sIGxvZyk7XFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShjb24sIFxcXCJlcnJvclxcXCIsIGZ1bmN0aW9uKCl7fSwgZXJyb3IpO1xcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkoY29uLCBcXFwid2FyblxcXCIsIGZ1bmN0aW9uKCl7fSwgd2Fybik7XFxyXFxuICBcXHJcXG4gIHJldHVybiBjb247XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vY29uc29sZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9jb25maWdcXCcsW1xcXCJ1dGlsc1xcXCIsIFxcXCJ1bnNhZmVXaW5kb3dcXFwiLCBcXFwiY29uc29sZVxcXCJdLCBmdW5jdGlvbih1dGlscywgdXcsIGNvbil7XFxyXFxuICBmdW5jdGlvbiBnZXRDb25maWcoKSB7XFxyXFxuICAgIHJldHVybiBjb25maWc7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHNldENvbmZpZyhjZmcsIHZhbCkge1xcclxcbiAgICBpZiAodHlwZW9mIGNmZyA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICB1dGlscy5zZXRQcm9wZXJ0eShjb25maWcsIGNmZywgdmFsLCB0cnVlKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBjb25maWcgPSBjZmc7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gY29uZmlnU2V0dGVyKGNmZykge1xcclxcbiAgICBzZXRDb25maWcoY2ZnKTsgLy8gc2V0IHRoZSBjb25maWd1cmF0aW9uLiBLZWVwIHRoZSByZWZlcmVuY2VcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gY29uZmlnR2V0dGVyKCkge1xcclxcbiAgICB2YXIgY2ZnID0gZ2V0Q29uZmlnKCk7XFxyXFxuICAgIGlmICghY2ZnKSByZXR1cm4gY2ZnO1xcclxcbiAgICBjZmcgPSB1dGlscy5jbG9uZShjZmcpO1xcclxcbiAgICB2YXIgcGVyc2lzdGVudENmZyA9IHV0aWxzLmNsb25lKHBlcnNpc3RlbnRDb25maWcpO1xcclxcbiAgICB1dGlscy5leHRlbmQocGVyc2lzdGVudENmZywgY2ZnLCB0cnVlKTtcXHJcXG4gICAgcmV0dXJuIHBlcnNpc3RlbnRDZmc7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHNldFBlcnNpc3RlbnRDb25maWcoY2ZnLCB2YWwpIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBjZmcgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgdXRpbHMuc2V0UHJvcGVydHkocGVyc2lzdGVudENvbmZpZywgY2ZnLCB2YWwsIHRydWUpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHBlcnNpc3RlbnRDb25maWcgPSBjZmc7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVudENvbmZpZygpIHtcXHJcXG4gICAgcmV0dXJuIHBlcnNpc3RlbnRDb25maWc7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBjb25maWcgPSB7fTtcXHJcXG4gIHZhciBwZXJzaXN0ZW50Q29uZmlnID0ge307XFxyXFxuICBcXHJcXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IHl0cGxheWVyIHZhcmlhYmxlIGlzIHNldFxcclxcbiAgdXcueXRwbGF5ZXIgPSB1dy55dHBsYXllciB8fCB7fTtcXHJcXG4gIFxcclxcbiAgY29uZmlnID0gdXcueXRwbGF5ZXIuY29uZmlnIHx8IHt9O1xcclxcbiAgXFxyXFxuICAvLyBNYWtlIHN1cmUgdGhhdCBZb3VUdWJlIGRvZXNuXFwndCBvdmVycmlkZSB0aGUgeXRwbGF5ZXIgdmFyaWFibGUgb3IgYWRkaW5nIGFuIHVud2FudGVkIHByb3BlcnR5IHRvIHl0cGxheWVyLlxcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkodXcueXRwbGF5ZXIsIFxcXCJjb25maWdcXFwiLCBjb25maWdTZXR0ZXIsIGNvbmZpZ0dldHRlcik7XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGdldENvbmZpZzogZ2V0Q29uZmlnLFxcclxcbiAgICBzZXRDb25maWc6IHNldENvbmZpZyxcXHJcXG4gICAgc2V0UGVyc2lzdGVudENvbmZpZzogc2V0UGVyc2lzdGVudENvbmZpZyxcXHJcXG4gICAgZ2V0UGVyc2lzdGVudENvbmZpZzogZ2V0UGVyc2lzdGVudENvbmZpZ1xcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvY29uZmlnLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwndW5zYWZlWW91VHViZUNlbnRlclxcJyxbXFxcInVuc2FmZVdpbmRvd1xcXCJdLCBmdW5jdGlvbih1dyl7XFxyXFxuICB2YXIgeXRjZW50ZXIgPSB7fTtcXHJcXG4gIHl0Y2VudGVyLnBsYXllciA9IHt9O1xcclxcbiAgXFxyXFxuICB1dy55dGNlbnRlciA9IHl0Y2VudGVyO1xcclxcbiAgXFxyXFxuICByZXR1cm4geXRjZW50ZXI7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vdW5zYWZlWW91VHViZUNlbnRlci5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9vbllvdVR1YmVQbGF5ZXJSZWFkeVxcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwidW5zYWZlV2luZG93XFxcIiwgXFxcIi4vYXBpXFxcIiwgXFxcIi4vY29uZmlnXFxcIiwgXFxcInV0aWxzXFxcIiwgXFxcInVuc2FmZVlvdVR1YmVDZW50ZXJcXFwiLCBcXFwiY29uc29sZVxcXCJdLCBmdW5jdGlvbihleHBvcnRzLCB1dywgcGxheWVyQVBJLCBjb25maWcsIHV0aWxzLCB1eXRjLCBjb24pe1xcclxcbiAgZnVuY3Rpb24gb25QbGF5ZXJSZWFkeShhcGkpIHtcXHJcXG4gICAgcGxheWVyQVBJLnNldEFQSShhcGkpO1xcclxcbiAgICBcXHJcXG4gICAgaWYgKHR5cGVvZiBhcGkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGNhbGxiYWNrKSB7XFxyXFxuICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2spIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGNhbGxiYWNrKSB7XFxyXFxuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcXHJcXG4gIFxcclxcbiAgY29uZmlnLnNldFBlcnNpc3RlbnRDb25maWcoXFxcImFyZ3MuanNhcGljYWxsYmFja1xcXCIsIFxcXCJ5dGNlbnRlci5wbGF5ZXIub25SZWFkeVxcXCIpO1xcclxcbiAgdXl0Yy5wbGF5ZXIub25SZWFkeSA9IHV0aWxzLmJpbmQodGhpcywgb25QbGF5ZXJSZWFkeSk7XFxyXFxuICB1dy5vbllvdVR1YmVQbGF5ZXJSZWFkeSA9IG9uUGxheWVyUmVhZHk7XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcXHJcXG4gIGV4cG9ydHMucmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lcjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGxheWVyL29uWW91VHViZVBsYXllclJlYWR5LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwncGFnZWxvYWRcXCcsW1xcXCJ1dGlsc1xcXCIsIFxcXCJjb25zb2xlXFxcIl0sIGZ1bmN0aW9uKHV0aWxzLCBjb24pe1xcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spIHtcXHJcXG4gICAgaWYgKCFsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xcclxcbiAgICB9XFxyXFxuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFkZGVkIGV2ZW50IGxpc3RlbmVyIGlzIGV4ZWN1dGVkIVxcclxcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHBhZ2VTdGF0ZXMuaW5kZXhPZihldmVudCk7XFxyXFxuICAgIGlmIChyZWFkeVN0YXRlIDw9IGxhc3RTdGF0ZSkge1xcclxcbiAgICAgIGNhbGxiYWNrKCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spIHtcXHJcXG4gICAgaWYgKCFsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgcmV0dXJuO1xcclxcbiAgICB9XFxyXFxuICAgIHZhciBsID0gbGlzdGVuZXJzW2V2ZW50XTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAobFtpXSA9PT0gY2FsbGJhY2spIHtcXHJcXG4gICAgICAgIGxbaV0uc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBjYWxsTGlzdGVuZXJzKGV2ZW50KSB7XFxyXFxuICAgIHZhciBsaXN0ID0gbGlzdGVuZXJzW2V2ZW50XTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBsaXN0W2ldKCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHBhZ2VTdGF0ZXMuaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWdlU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGxhc3RTdGF0ZSA8IGkgJiYgaSA8PSByZWFkeVN0YXRlICYmIHV0aWxzLmlzQXJyYXkobGlzdGVuZXJzW3BhZ2VTdGF0ZXNbaV1dKSkge1xcclxcbiAgICAgICAgY2FsbExpc3RlbmVycyhwYWdlU3RhdGVzW2ldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIGxhc3RTdGF0ZSA9IHJlYWR5U3RhdGU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluaXQoKSB7XFxyXFxuICAgIHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJyZWFkeXN0YXRlY2hhbmdlXFxcIiwgdXBkYXRlLCB0cnVlKTtcXHJcXG4gICAgdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCB1cGRhdGUsIHRydWUpO1xcclxcbiAgICB1cGRhdGUoKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIGxpc3RlbmVycyA9IHt9O1xcclxcbiAgdmFyIHBhZ2VTdGF0ZXMgPSBbXFxcInVuaW5pdGlhbGl6ZWRcXFwiLCBcXFwibG9hZGluZ1xcXCIsIFxcXCJpbnRlcmFjdGl2ZVxcXCIsIFxcXCJjb21wbGV0ZVxcXCJdO1xcclxcbiAgdmFyIGxhc3RTdGF0ZSA9IC0xO1xcclxcbiAgXFxyXFxuICBpbml0KCk7XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXFxyXFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXJcXHJcXG4gIH07XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGFnZWxvYWQuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCd5dHJlYWR5XFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCIuL3BhZ2Vsb2FkXFxcIiwgXFxcInVuc2FmZVdpbmRvd1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCBwYWdlbG9hZCwgdXcpe1xcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihwYXRoLCBjYWxsYmFjaykge1xcclxcbiAgICBpZiAoIXBhdGhzW3BhdGhdKSBwYXRoc1twYXRoXSA9IFtdO1xcclxcbiAgICBwYXRoc1twYXRoXS5wdXNoKGNhbGxiYWNrKTtcXHJcXG4gICAgXFxyXFxuICAgIHVwZGF0ZSgpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHBhdGgsIGNhbGxiYWNrKSB7XFxyXFxuICAgIGlmICghcGF0aHNbcGF0aF0pIHJldHVybjtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGhzW3BhdGhdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKHBhdGhzW3BhdGhdW2ldID09PSBjYWxsYmFjaykge1xcclxcbiAgICAgICAgcGF0aHNbcGF0aF0uc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tzIGlmIHRoZSBwYXRoIGluIHVuc2FmZVdpbmRvdyBpcyBkZWZpbmVkLlxcclxcbiAgKlxcclxcbiAgKiBAbWV0aG9kIHByb3BlcnR5RXhpc3RzXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBwcm9wZXJ0eS5cXHJcXG4gICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgb3RoZXJ3aXNlIGZhbHNlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBwcm9wZXJ0eUV4aXN0cyhwYXRoKSB7XFxyXFxuICAgIHZhciB0b2tlbnMgPSBwYXRoLnNwbGl0KFxcXCIuXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgdGFyZ2V0ID0gdXc7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKHRhcmdldFt0b2tlbnNbaV1dKSB7XFxyXFxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zW2ldXTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNrcyBpZiB0aGUgYWRkZWQgcGF0aCBsaXN0ZW5lcnMgZXhpc3RcXHJcXG4gICogYW5kIGlmIHRoZXkgZG8gdGhlbiBjYWxsIHRoZSBjYWxsYmFja3NcXHJcXG4gICogZm9yIHRoYXQgc3BlY2lmaWMgcGF0aCBsaXN0ZW5lci5cXHJcXG4gICpcXHJcXG4gICogQG1ldGhvZCB1cGRhdGVcXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcbiAgICBmb3IgKHZhciBwYXRoIGluIHBhdGhzKSB7XFxyXFxuICAgICAgaWYgKHBhdGhzW3BhdGhdKSB7XFxyXFxuICAgICAgICBpZiAocHJvcGVydHlFeGlzdHMocGF0aCkpIHtcXHJcXG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHBhdGhzW3BhdGhdO1xcclxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgY2FsbGJhY2tzW2ldKCk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgcGF0aHNbcGF0aF0gPSBudWxsO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB0aW1lclVwZGF0ZSgpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpc1dvcmtpbmcoKSB7XFxyXFxuICAgIGZvciAodmFyIHBhdGggaW4gcGF0aHMpIHtcXHJcXG4gICAgICBpZiAocGF0aHNbcGF0aF0pIHtcXHJcXG4gICAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gZmFsc2U7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRpbWVyVXBkYXRlKCkge1xcclxcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcclxcbiAgICBpZiAoaXNXb3JraW5nKCkpIHtcXHJcXG4gICAgICBzZXRUaW1lb3V0KHVwZGF0ZSwgdGltZXJJbnRlcnZhbCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIHRpbWVySW50ZXJ2YWwgPSAxMDAwO1xcclxcbiAgXFxyXFxuICB2YXIgdGltZXIgPSBudWxsO1xcclxcbiAgdmFyIHBhdGhzID0geyB9O1xcclxcbiAgXFxyXFxuICAvLyBBdHRhY2ggdGhlIHVwZGF0ZSB0byB0aGUgcGFnZSBsb2FkLlxcclxcbiAgcGFnZWxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcXFwidW5pbml0aWFsaXplZFxcXCIsIHVwZGF0ZSk7XFxyXFxuICBwYWdlbG9hZC5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkaW5nXFxcIiwgdXBkYXRlKTtcXHJcXG4gIHBhZ2Vsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXFxcImludGVyYWN0aXZlXFxcIiwgdXBkYXRlKTtcXHJcXG4gIHBhZ2Vsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNvbXBsZXRlXFxcIiwgdXBkYXRlKTtcXHJcXG4gIFxcclxcbiAgXFxyXFxuICAvKiBFeHBvcnRzICovXFxyXFxuICBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xcclxcbiAgZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0veXRyZWFkeS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9saXN0ZW5lcnNcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcInV0aWxzXFxcIiwgXFxcIi4vYXBpXFxcIiwgXFxcInVuc2FmZVdpbmRvd1xcXCIsIFxcXCJjb25zb2xlXFxcIiwgXFxcIi4vb25Zb3VUdWJlUGxheWVyUmVhZHlcXFwiLCBcXFwieXRyZWFkeVxcXCJdLCBmdW5jdGlvbihleHBvcnRzLCB1dGlscywgcGxheWVyQVBJLCB1dywgY29uLCBvblJlYWR5LCB5dHJlYWR5KXtcXHJcXG4gIC8vIEdldCB0aGUgWW91VHViZSBsaXN0ZW5lciBmb3IgdGhlIHBhc3NlZCBldmVudC5cXHJcXG4gIGZ1bmN0aW9uIGdldFlvdVR1YmVMaXN0ZW5lcihldmVudCkge1xcclxcbiAgICB2YXIgeXRFdmVudCA9IGdldExpc3RlbmVyTmFtZShldmVudCk7XFxyXFxuICAgIHJldHVybiB5dExpc3RlbmVyc1t5dEV2ZW50XTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gVGhlIGxhdGVzdCBwbGF5ZXIgaWQgcmVnaXN0ZXJlZCBpbiB0aGUgZ2xvYmFsIHdpbmRvdy5cXHJcXG4gIGZ1bmN0aW9uIGdldFBsYXllckxpc3RlbmVyRGV0YWlscygpIHtcXHJcXG4gICAgdmFyIGlkID0gMTtcXHJcXG4gICAgdmFyIHVpZCA9IG51bGw7XFxyXFxuICAgIFxcclxcbiAgICB1dGlscy5lYWNoKHV3LCBmdW5jdGlvbihrZXksIHZhbHVlKXtcXHJcXG4gICAgICBpZiAoa2V5LmluZGV4T2YoXFxcInl0UGxheWVyXFxcIikgPT09IDApIHtcXHJcXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcXFwicGxheWVyX3VpZF9cXFwiKSAhPT0gLTEpIHtcXHJcXG4gICAgICAgICAgdmFyIHVpZE1hdGNoID0ga2V5Lm1hdGNoKC9wbGF5ZXJfdWlkXyhbMC05XSspXyhbMC05XSspJC8pO1xcclxcbiAgICAgICAgICBcXHJcXG4gICAgICAgICAgdWlkID0gcGFyc2VJbnQodWlkTWF0Y2hbMV0sIDEwKTtcXHJcXG4gICAgICAgICAgaSA9IHBhcnNlSW50KHVpZE1hdGNoWzJdLCAxMCk7XFxyXFxuICAgICAgICAgIFxcclxcbiAgICAgICAgICBpZiAoaSA+IGlkKSB7XFxyXFxuICAgICAgICAgICAgaWQgPSBpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB2YXIgaWRNYXRjaCA9IGtleS5tYXRjaCgvcGxheWVyKFswLTldKykkLyk7XFxyXFxuICAgICAgICAgIGkgPSBwYXJzZUludChpZE1hdGNoWzFdLCAxMCk7XFxyXFxuICAgICAgICAgIGlmIChpID4gaWQpIHtcXHJcXG4gICAgICAgICAgICBpZCA9IGk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0pO1xcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHsgaWQ6IGlkLCB1aWQ6IHVpZCB9O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lck5hbWUoZXZlbnQpIHtcXHJcXG4gICAgaWYgKHBsYXllckxpc3RlbmVyRGV0YWlscy51aWQgIT09IG51bGwpIHtcXHJcXG4gICAgICByZXR1cm4gXFxcInl0UGxheWVyXFxcIiArIGV2ZW50ICsgXFxcInBsYXllcl91aWRfXFxcIiArIHBsYXllckxpc3RlbmVyRGV0YWlscy51aWQgKyBcXFwiX1xcXCIgKyBwbGF5ZXJMaXN0ZW5lckRldGFpbHMuaWQ7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCJ5dFBsYXllclxcXCIgKyBldmVudCArIFxcXCJwbGF5ZXJcXFwiICsgcGxheWVyTGlzdGVuZXJEZXRhaWxzLmlkO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHl0TGlzdGVuZXJDb250YWluZXJTZXR0ZXIoZXZlbnQsIGZ1bmMpIHtcXHJcXG4gICAgdmFyIHl0RXZlbnQgPSBnZXRMaXN0ZW5lck5hbWUoZXZlbnQpO1xcclxcbiAgICB5dExpc3RlbmVyc1t5dEV2ZW50XSA9IGZ1bmM7XFxyXFxuICB9XFxyXFxuICBmdW5jdGlvbiB5dExpc3RlbmVyQ29udGFpbmVyR2V0dGVyKGV2ZW50LCBmdW5jKSB7XFxyXFxuICAgIHJldHVybiB1dGlscy5iaW5kKG51bGwsIGNhbGxMaXN0ZW5lciwgZXZlbnQsIE9SSUdJTl9QUk9QRVJUWSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qIE9yaWdpbiBhcmd1bWVudFxcclxcbiAgICogSWYgb3JpZ2luIGlzIGVxdWFsIHRvIDAgdGhlbiB0aGUgb3JpZ2luIGlzIGRpcmVjdGx5IGZyb20gdGhlIHBsYXllciAob25seSBZb3VUdWJlIENlbnRlclxcJ3MgbGlzdGVuZXJzIGdldCBleGVjdXRlZCBpZiBvdmVycmlkZSBpcyBmYWxzZSkuXFxyXFxuICAgKiBJZiBvcmlnaW4gaXMgZXF1YWwgdG8gMSB0aGVuIHRoZSBvcmlnaW4gaXMgZnJvbSB0aGUgZ2xvYmFsIGxpc3RlbmVycyAoYm90aCBZb3VUdWJlXFwncyBhbmQgWW91VHViZSBDZW50ZXJcXCdzIGxpc3RlbmVycyBnZXQgZXhlY3V0ZWQpLlxcclxcbiAgICovXFxyXFxuICBmdW5jdGlvbiBjYWxsTGlzdGVuZXIoZXZlbnQsIG9yaWdpbikge1xcclxcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVRoaXNPYmplY3QoKSB7XFxyXFxuICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgIGdldE9yaWdpbmFsTGlzdGVuZXI6IHV0aWxzLmJpbmQobnVsbCwgZ2V0WW91VHViZUxpc3RlbmVyLCBldmVudClcXHJcXG4gICAgICB9O1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICB2YXIgeXRFdmVudCA9IGdldExpc3RlbmVyTmFtZShldmVudCk7XFxyXFxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcXHJcXG4gICAgdmFyIHJldHVyblZhbCA9IG51bGw7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoZW5hYmxlZCAmJiBvcmlnaW4gPT09IE9SSUdJTl9QTEFZRVIgJiYgKCFldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpIHx8IChldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpICYmICFldmVudHNbZXZlbnRdLm92ZXJyaWRlKSkpIHtcXHJcXG4gICAgICAvKiBPdmVycmlkZSBpcyBmYWxzZSBhbmQgdGhlIG9yaWdpbiBpcyBmcm9tIHRoZSBwbGF5ZXI7IGNhbGwgdGhlIFlvdVR1YmUgQ2VudGVyIGxpc3RlbmVycyAqL1xcclxcbiAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgcmV0dXJuVmFsID0gZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2UgaWYgKGVuYWJsZWQgJiYgb3JpZ2luID09PSBPUklHSU5fUFJPUEVSVFkpIHtcXHJcXG4gICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSAmJiBldmVudHNbZXZlbnRdLm92ZXJyaWRlKSB7XFxyXFxuICAgICAgICAvKiBPdmVycmlkZSBpcyB0cnVlIGFuZCB0aGUgb3JpZ2luIGlzIGZyb20gdGhlIGdsb2JhbCB3aW5kb3c7IGNhbGwgdGhlIFlvdVR1YmUgQ2VudGVyIGxpc3RlbmVycyAqL1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgIGV2ZW50c1tldmVudF0ubGlzdGVuZXJzW2ldLmFwcGx5KGdlbmVyYXRlVGhpc09iamVjdCgpLCBhcmdzKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9IGVsc2UgaWYgKHl0TGlzdGVuZXJzW3l0RXZlbnRdKSB7XFxyXFxuICAgICAgICBpZiAoYXBpTm90QXZhaWxhYmxlKSB7XFxyXFxuICAgICAgICAgIC8qIEFQSSBpcyBub3QgYXZhaWxhYmxlIHRoZXJlZm9yZSBjYWxsIFlvdVR1YmUgQ2VudGVyIGxpc3RlbmVycyBhcyBZb3VUdWJlIGxpc3RlbmVyIGlzIGNhbGxlZCAgKi9cXHJcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuVmFsID0gZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIFxcclxcbiAgICAgICAgLyogT3ZlcnJpZGUgaXMgZmFsc2UgYW5kIHRoZSBvcmlnaW4gaXMgZnJvbSB0aGUgZ2xvYmFsIHdpbmRvdzsgY2FsbCB0aGUgWW91VHViZSBsaXN0ZW5lciAqL1xcclxcbiAgICAgICAgcmV0dXJuVmFsID0geXRMaXN0ZW5lcnNbeXRFdmVudF0uYXBwbHkodXcsIGFyZ3MpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIGlmICghZW5hYmxlZCkge1xcclxcbiAgICAgIC8qIEV2ZXJ5dGhpbmcgaXMgZGlzYWJsZWQ7IGNhbGwgdGhlIFlvdVR1YmUgbGlzdGVuZXIgKi9cXHJcXG4gICAgICByZXR1cm5WYWwgPSB5dExpc3RlbmVyc1t5dEV2ZW50XS5hcHBseSh1dywgYXJncyk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHJldHVyblZhbDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYWRkUGxheWVyTGlzdGVuZXIoKSB7XFxyXFxuICAgIHZhciBhcGkgPSBwbGF5ZXJBUEkuZ2V0QVBJKCk7XFxyXFxuICAgIHZhciBldmVudDtcXHJcXG4gICAgXFxyXFxuICAgIGlmIChhcGkgJiYgYXBpLmFkZEV2ZW50TGlzdGVuZXIpIHtcXHJcXG4gICAgICBhcGlOb3RBdmFpbGFibGUgPSBmYWxzZTtcXHJcXG4gICAgICBmb3IgKGV2ZW50IGluIGV2ZW50cykge1xcclxcbiAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcXHJcXG4gICAgICAgICAgcGxheWVyTGlzdGVuZXJbZXZlbnRdID0gdXRpbHMuYmluZChudWxsLCBjYWxsTGlzdGVuZXIsIGV2ZW50LCBPUklHSU5fUExBWUVSKTtcXHJcXG4gICAgICAgICAgYXBpLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHBsYXllckxpc3RlbmVyW2V2ZW50XSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGFwaU5vdEF2YWlsYWJsZSA9IHRydWU7XFxyXFxuICAgICAgY29uLmVycm9yKFxcXCJbUGxheWVyIExpc3RlbmVyXSBQbGF5ZXIgQVBJIGlzIG5vdCBhdmFpbGFibGUhXFxcIik7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaW5pdEdsb2JhbExpc3RlbmVycygpIHtcXHJcXG4gICAgaWYgKGdsb2JhbExpc3RlbmVyc0luaXRpYWxpemVkKSByZXR1cm47IC8vIE1ha2Ugc3VyZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgb25jZS5cXHJcXG4gICAgZ2xvYmFsTGlzdGVuZXJzSW5pdGlhbGl6ZWQgPSB0cnVlO1xcclxcbiAgICBmb3IgKHZhciBldmVudCBpbiBldmVudHMpIHtcXHJcXG4gICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xcclxcbiAgICAgICAgdmFyIHl0RXZlbnQgPSBnZXRMaXN0ZW5lck5hbWUoZXZlbnQpO1xcclxcbiAgICAgICAgaWYgKHV3W3l0RXZlbnRdKSB7XFxyXFxuICAgICAgICAgIHl0TGlzdGVuZXJzW3l0RXZlbnRdID0gdXdbeXRFdmVudF07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eSh1dywgeXRFdmVudCxcXHJcXG4gICAgICAgICAgdXRpbHMuYmluZChudWxsLCB5dExpc3RlbmVyQ29udGFpbmVyU2V0dGVyLCBldmVudCksXFxyXFxuICAgICAgICAgIHV0aWxzLmJpbmQobnVsbCwgeXRMaXN0ZW5lckNvbnRhaW5lckdldHRlciwgZXZlbnQpXFxyXFxuICAgICAgICApO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpbml0KCkge1xcclxcbiAgICBpZiAoZW5hYmxlZCkgcmV0dXJuO1xcclxcbiAgICB2YXIgYXBpID0gcGxheWVyQVBJLmdldEFQSSgpO1xcclxcbiAgICBwbGF5ZXJMaXN0ZW5lckRldGFpbHMgPSBnZXRQbGF5ZXJMaXN0ZW5lckRldGFpbHMoKTtcXHJcXG4gICAgXFxyXFxuICAgIGVuYWJsZWQgPSB0cnVlOyAvLyBJbmRpY2F0ZSB0aGF0IHRoZSBpdFxcJ3MgYWN0aXZlLlxcclxcblxcclxcbiAgICAvLyBBZGQgdGhlIGxpc3RlbmVycyBub3JtYWxseSB0byB0aGUgcGxheWVyXFxyXFxuICAgIGFkZFBsYXllckxpc3RlbmVyKCk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBSZXBsYWNlIHRoZSBnbG9iYWwgbGlzdGVuZXJzIHdpdGggY3VzdG9tIGxpc3RlbmVycyBpbiBjYXNlIHRoZSBvdmVycmlkZSBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZVxcclxcbiAgICBpbml0R2xvYmFsTGlzdGVuZXJzKCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XFxyXFxuICAgIGlmICghZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkgcmV0dXJuO1xcclxcbiAgICBcXHJcXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpOyAvLyBNYWtlIHN1cmUgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGUgbGlzdGVuZXIgcmVnaXN0ZXJlZC5cXHJcXG4gICAgZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XFxyXFxuICB9XFxyXFxuICAgICAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xcclxcbiAgICBpZiAoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHJldHVybjtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGV2ZW50c1tldmVudF0ubGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xcclxcbiAgICAgICAgcmV0dXJuIGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0T3ZlcnJpZGUoZXZlbnQsIG92ZXJyaWRlKSB7XFxyXFxuICAgIGlmICghZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkgcmV0dXJuO1xcclxcbiAgICBldmVudHNbZXZlbnRdLm92ZXJyaWRlID0gISFvdmVycmlkZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdW5sb2FkUGxheWVyTGlzdGVuZXJzKCkge1xcclxcbiAgICB2YXIgYXBpID0gcGxheWVyQVBJLmdldEFQSSgpO1xcclxcbiAgICB2YXIgZXZlbnQ7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoYXBpICYmIGFwaS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XFxyXFxuICAgICAgZm9yIChldmVudCBpbiBldmVudHMpIHtcXHJcXG4gICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgICAgIGFwaS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBwbGF5ZXJMaXN0ZW5lcltldmVudF0pO1xcclxcbiAgICAgICAgICBkZWxldGUgcGxheWVyTGlzdGVuZXJbZXZlbnRdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBjb24uZXJyb3IoXFxcIltQbGF5ZXIgTGlzdGVuZXJdIFBsYXllciBBUEkgaXMgbm90IGF2YWlsYWJsZSFcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB1bmxvYWQoKSB7XFxyXFxuICAgIHVubG9hZFBsYXllckxpc3RlbmVycygpO1xcclxcbiAgICBlbmFibGVkID0gZmFsc2U7XFxyXFxuICAgIGFwaU5vdEF2YWlsYWJsZSA9IHRydWU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBPUklHSU5fUExBWUVSID0gMDtcXHJcXG4gIHZhciBPUklHSU5fUFJPUEVSVFkgPSAxO1xcclxcbiAgXFxyXFxuICB2YXIgcGxheWVyTGlzdGVuZXJEZXRhaWxzID0geyBpZDogMSwgdWlkOiBudWxsIH07XFxyXFxuICB2YXIgeXRMaXN0ZW5lcnMgPSB7fTtcXHJcXG4gIHZhciBwbGF5ZXJMaXN0ZW5lciA9IHt9OyAvLyBSZWZlcmVuY2UgZm9yIHVubG9hZFxcclxcbiAgdmFyIGVuYWJsZWQgPSBmYWxzZTtcXHJcXG4gIHZhciBnbG9iYWxMaXN0ZW5lcnNJbml0aWFsaXplZCA9IGZhbHNlO1xcclxcbiAgdmFyIGFwaU5vdEF2YWlsYWJsZSA9IHRydWU7XFxyXFxuICBcXHJcXG4gIHZhciBldmVudHMgPSB7XFxyXFxuICAgIFxcXCJvbkFwaUNoYW5nZVxcXCI6IHtcXHJcXG4gICAgICBvdmVycmlkZTogZmFsc2UsXFxyXFxuICAgICAgbGlzdGVuZXJzOiBbXVxcclxcbiAgICB9LFxcclxcbiAgICBcXFwib25DdWVSYW5nZUVudGVyXFxcIjoge1xcclxcbiAgICAgIG92ZXJyaWRlOiBmYWxzZSxcXHJcXG4gICAgICBsaXN0ZW5lcnM6IFtdXFxyXFxuICAgIH0sXFxyXFxuICAgIFxcXCJvbkN1ZVJhbmdlRXhpdFxcXCI6IHtcXHJcXG4gICAgICBvdmVycmlkZTogZmFsc2UsXFxyXFxuICAgICAgbGlzdGVuZXJzOiBbXVxcclxcbiAgICB9LFxcclxcbiAgICBcXFwib25FcnJvclxcXCI6IHtcXHJcXG4gICAgICBvdmVycmlkZTogZmFsc2UsXFxyXFxuICAgICAgbGlzdGVuZXJzOiBbXVxcclxcbiAgICB9LFxcclxcbiAgICBcXFwib25OYXZpZ2F0ZVxcXCI6IHtcXHJcXG4gICAgICBvdmVycmlkZTogZmFsc2UsXFxyXFxuICAgICAgbGlzdGVuZXJzOiBbXVxcclxcbiAgICB9LFxcclxcbiAgICBcXFwib25QbGF5YmFja1F1YWxpdHlDaGFuZ2VcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIm9uU3RhdGVDaGFuZ2VcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIm9uVGFiT3JkZXJDaGFuZ2VcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIm9uVm9sdW1lQ2hhbmdlXFxcIjoge1xcclxcbiAgICAgIG92ZXJyaWRlOiBmYWxzZSxcXHJcXG4gICAgICBsaXN0ZW5lcnM6IFtdXFxyXFxuICAgIH0sXFxyXFxuICAgIFxcXCJvbkFkU3RhcnRcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIm9uUmVhZHlcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIlJBVEVfU0VOVElNRU5UXFxcIjoge1xcclxcbiAgICAgIG92ZXJyaWRlOiBmYWxzZSxcXHJcXG4gICAgICBsaXN0ZW5lcnM6IFtdXFxyXFxuICAgIH0sXFxyXFxuICAgIFxcXCJTSEFSRV9DTElDS0VEXFxcIjoge1xcclxcbiAgICAgIG92ZXJyaWRlOiBmYWxzZSxcXHJcXG4gICAgICBsaXN0ZW5lcnM6IFtdXFxyXFxuICAgIH0sXFxyXFxuICAgIFxcXCJTSVpFX0NMSUNLRURcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIldBVENIX0xBVEVSXFxcIjoge1xcclxcbiAgICAgIG92ZXJyaWRlOiBmYWxzZSxcXHJcXG4gICAgICBsaXN0ZW5lcnM6IFtdXFxyXFxuICAgIH0sXFxyXFxuICAgIFxcXCJBZHZlcnRpc2VyVmlkZW9WaWV3XFxcIjoge1xcclxcbiAgICAgIG92ZXJyaWRlOiBmYWxzZSxcXHJcXG4gICAgICBsaXN0ZW5lcnM6IFtdXFxyXFxuICAgIH0sXFxyXFxuICAgIFxcXCJjYXB0aW9uc2NoYW5nZWRcXFwiOiB7XFxyXFxuICAgICAgb3ZlcnJpZGU6IGZhbHNlLFxcclxcbiAgICAgIGxpc3RlbmVyczogW11cXHJcXG4gICAgfSxcXHJcXG4gICAgXFxcIm9uUmVtb3RlUmVjZWl2ZXJTZWxlY3RlZFxcXCI6IHtcXHJcXG4gICAgICBvdmVycmlkZTogZmFsc2UsXFxyXFxuICAgICAgbGlzdGVuZXJzOiBbXVxcclxcbiAgICB9XFxyXFxuICB9O1xcclxcbiAgXFxyXFxuICAvLyBJbnRpYWxpemUgdGhlIHBsYXllciBsaXN0ZW5lcnMgYXQgcGxheWVyIG9uIHJlYWR5LlxcclxcbiAgb25SZWFkeS5hZGRMaXN0ZW5lcihpbml0KTtcXHJcXG4gIFxcclxcbiAgLyogRXhwb3J0cyAqL1xcclxcbiAgZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcXHJcXG4gIGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XFxyXFxuICBleHBvcnRzLnNldE92ZXJyaWRlID0gc2V0T3ZlcnJpZGU7XFxyXFxuICBleHBvcnRzLmluaXQgPSBpbml0O1xcclxcbiAgZXhwb3J0cy51bmxvYWQgPSB1bmxvYWQ7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3BsYXllci9saXN0ZW5lcnMuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCd3aW5kb3dcXCcsW10sIGZ1bmN0aW9uKCl7XFxyXFxuICBmdW5jdGlvbiBnZXRJbm5lcldpZHRoKCkge1xcclxcbiAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XFxyXFxuICB9XFxyXFxuICBmdW5jdGlvbiBnZXRJbm5lckhlaWdodCgpIHtcXHJcXG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRDbGllbnRXaWR0aCgpIHtcXHJcXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRDbGllbnRIZWlnaHQoKSB7XFxyXFxuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIGNhcHR1cmUpIHtcXHJcXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCBjYXB0dXJlKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgZ2V0Q2xpZW50V2lkdGg6IGdldENsaWVudFdpZHRoLFxcclxcbiAgICBnZXRDbGllbnRIZWlnaHQ6IGdldENsaWVudEhlaWdodCxcXHJcXG4gICAgZ2V0SW5uZXJXaWR0aDogZ2V0SW5uZXJXaWR0aCxcXHJcXG4gICAgZ2V0SW5uZXJIZWlnaHQ6IGdldElubmVySGVpZ2h0LFxcclxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyXFxyXFxuICB9XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vd2luZG93LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwncGxheWVyL3NpemVcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcIi4vbGlzdGVuZXJzXFxcIiwgXFxcIi4vcGxheWVyXFxcIiwgXFxcIndpbmRvd1xcXCIsIFxcXCJ1dGlsc1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCBsaXN0ZW5lcnMsIHBsYXllciwgd2luLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBvblBsYXllclNpemVDaGFuZ2UobGFyZ2UpIHtcXHJcXG4gICAgaWYgKGxhcmdlKSB7XFxyXFxuICAgICAgc2V0U2l6ZShsYXJnZVNpemUpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHNldFNpemUoc21hbGxTaXplKTtcXHJcXG4gICAgfVxcclxcbiAgICB1cGRhdGUoKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0U2l6ZShuU2l6ZSkge1xcclxcbiAgICBzaXplID0gblNpemU7XFxyXFxuICAgIHVwZGF0ZSgpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XFxyXFxuICAgIHZhciBwbGF5ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJwbGF5ZXJcXFwiKTtcXHJcXG4gICAgdmFyIHBsYXllckFQSUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcInBsYXllci1hcGlcXFwiKTtcXHJcXG4gICAgdmFyIHBsYXllclRoZWF0ZXJCYWNrZ3JvdW5kRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXFwidGhlYXRlci1iYWNrZ3JvdW5kXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICB1dGlscy5yZW1vdmVDbGFzcyhwbGF5ZXJFbCwgXFxcIndhdGNoLXNtYWxsIHdhdGNoLW1lZGl1bSB3YXRjaC1sYXJnZVxcXCIpO1xcclxcbiAgICBpZiAoc2l6ZS5sYXJnZSkge1xcclxcbiAgICAgIHV0aWxzLmFkZENsYXNzKHBsYXllckVsLCBcXFwid2F0Y2gtbGFyZ2VcXFwiKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB1dGlscy5hZGRDbGFzcyhwbGF5ZXJFbCwgXFxcIndhdGNoLXNtYWxsXFxcIik7XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHZhciBkaW0gPSBnZXRQbGF5ZXJEaW1lbnNpb24oKTtcXHJcXG4gICAgaWYgKHNpemUubGFyZ2UpIHtcXHJcXG4gICAgICBwbGF5ZXJFbC5zdHlsZS53aWR0aCA9IGRpbS53aWR0aCArIFxcXCJweFxcXCI7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgcGxheWVyRWwuc3R5bGUud2lkdGggPSBcXFwiYXV0b1xcXCI7XFxyXFxuICAgIH1cXHJcXG4gICAgcGxheWVyVGhlYXRlckJhY2tncm91bmRFbC5zdHlsZS5oZWlnaHQgPSBkaW0uaGVpZ2h0ICsgXFxcInB4XFxcIjtcXHJcXG4gICAgXFxyXFxuICAgIHBsYXllckFQSUVsLnN0eWxlLndpZHRoID0gZGltLndpZHRoICsgXFxcInB4XFxcIjtcXHJcXG4gICAgcGxheWVyQVBJRWwuc3R5bGUuaGVpZ2h0ID0gZGltLmhlaWdodCArIFxcXCJweFxcXCI7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgY29udGVudENvbnRhaW5lckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcIndhdGNoNy1jb250YWluZXJcXFwiKTtcXHJcXG4gICAgaWYgKHNpemUubGFyZ2UpIHtcXHJcXG4gICAgICB1dGlscy5hZGRDbGFzcyhjb250ZW50Q29udGFpbmVyRWwsIFxcXCJ3YXRjaC13aWRlXFxcIik7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdXRpbHMucmVtb3ZlQ2xhc3MoY29udGVudENvbnRhaW5lckVsLCBcXFwid2F0Y2gtd2lkZVxcXCIpO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICB2YXIgc2lkZWJhckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcIndhdGNoNy1zaWRlYmFyXFxcIik7XFxyXFxuICAgIGlmIChzaXplLmxhcmdlKSB7XFxyXFxuICAgICAgc2lkZWJhckVsLnN0eWxlLnRvcCA9IFxcXCJcXFwiO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHNpZGViYXJFbC5zdHlsZS50b3AgPSBcXFwiLVxcXCIgKyBkaW0uaGVpZ2h0ICsgXFxcInB4XFxcIjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRQbGF5ZXJEaW1lbnNpb24oKSB7XFxyXFxuICAgIHZhciBwbGF5ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJwbGF5ZXJcXFwiKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciB3aWR0aCA9IG51bGw7XFxyXFxuICAgIHZhciBoZWlnaHQgPSBudWxsO1xcclxcbiAgICBcXHJcXG4gICAgaWYgKHR5cGVvZiBzaXplLndpZHRoID09PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgIGlmIChzaXplLndpZHRoVW5pdCA9PT0gXFxcIiVcXFwiKSB7XFxyXFxuICAgICAgICB3aWR0aCA9IHNpemUud2lkdGgvMTAwKndpbi5nZXRDbGllbnRXaWR0aCgpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICB3aWR0aCA9IHNpemUud2lkdGg7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICBpZiAodHlwZW9mIHNpemUud2lkdGggPT09IFxcXCJudW1iZXJcXFwiKSB7XFxyXFxuICAgICAgaWYgKHNpemUuaGVpZ2h0VW5pdCA9PT0gXFxcIiVcXFwiKSB7XFxyXFxuICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodC8xMDAqd2luLmdldENsaWVudEhlaWdodCgpO1xcclxcbiAgICAgICAgLy8gaWYgKHNvbWV0aGluZy5pc1RvcEJhcigpKVxcclxcbiAgICAgICAgaGVpZ2h0IC09IDUwO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodDtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHZhciByYXRpbyA9IGdldFJhdGlvKCk7XFxyXFxuICAgIFxcclxcbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ID09PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgICAgd2lkdGggPSBoZWlnaHQqcmF0aW87XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHdpZHRoID0gZ2V0RGVmYXVsdFdpZHRoKCk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gXFxcIm51bWJlclxcXCIpIHtcXHJcXG4gICAgICBpZiAodHlwZW9mIHdpZHRoID09PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgICAgaGVpZ2h0ID0gd2lkdGgvcmF0aW87XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGhlaWdodCA9IGdldERlZmF1bHRIZWlnaHQoKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIC8vIENvbnRyb2xiYXIgKyBQcm9ncmVzc2JhciBoZWlnaHRcXHJcXG4gICAgdmFyIGNvbnRyb2xiYXJIZWlnaHQgPSBwbGF5ZXIuZ2V0Q29udHJvbGJhckhlaWdodCgpO1xcclxcbiAgICBoZWlnaHQgKz0gY29udHJvbGJhckhlaWdodDtcXHJcXG4gICAgXFxyXFxuICAgIC8vIE11bHRpIGNhbWVyYSBhZGRpdGlvbmFsIGhlaWdodFxcclxcbiAgICBpZiAodXRpbHMuaGFzQ2xhc3MocGxheWVyRWwsIFxcXCJ3YXRjaC1tdWx0aWNhbWVyYVxcXCIpICYmIHBsYXllci5nZXRUeXBlID09PSBcXFwiZmxhc2hcXFwiKSB7XFxyXFxuICAgICAgaGVpZ2h0ICs9IDgwO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4ge1xcclxcbiAgICAgIHdpZHRoOiBNYXRoLmZsb29yKHdpZHRoKSxcXHJcXG4gICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoaGVpZ2h0KVxcclxcbiAgICB9O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBzZXRTbWFsbFBsYXllclNpemUoc21hbGwpIHtcXHJcXG4gICAgc21hbGxTaXplID0gc21hbGw7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHNldExhcmdlUGxheWVyU2l6ZShsYXJnZSkge1xcclxcbiAgICBsYXJnZVNpemUgPSBsYXJnZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0UmF0aW8oKSB7XFxyXFxuICAgIHJldHVybiAxNi85O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXREZWZhdWx0V2lkdGgoKSB7XFxyXFxuICAgIHJldHVybiA2NDA7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRIZWlnaHQoKSB7XFxyXFxuICAgIHJldHVybiBnZXREZWZhdWx0V2lkdGgoKS9nZXRSYXRpbygpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgc21hbGxTaXplID0ge1xcclxcbiAgICB3aWR0aDogMTI4MCxcXHJcXG4gICAgd2lkdGhVbml0OiBcXFwicHhcXFwiLFxcclxcbiAgICBsYXJnZTogdHJ1ZVxcclxcbiAgfTtcXHJcXG4gIHZhciBsYXJnZVNpemUgPSB7XFxyXFxuICAgIHdpZHRoOiAxOTIwLFxcclxcbiAgICB3aWR0aFVuaXQ6IFxcXCJweFxcXCIsXFxyXFxuICAgIGxhcmdlOiB0cnVlXFxyXFxuICB9O1xcclxcbiAgXFxyXFxuICB2YXIgc2l6ZSA9IHtcXHJcXG4gICAgd2lkdGg6IDEyODAsXFxyXFxuICAgIGhlaWdodDogNzIwLFxcclxcbiAgICB3aWR0aFVuaXQ6IFxcXCJweFxcXCIsXFxyXFxuICAgIGhlaWdodFVuaXQ6IFxcXCJweFxcXCIsXFxyXFxuICAgIGxhcmdlOiB0cnVlXFxyXFxuICB9O1xcclxcbiAgXFxyXFxuICBsaXN0ZW5lcnMuc2V0T3ZlcnJpZGUoXFxcIlNJWkVfQ0xJQ0tFRFxcXCIsIHRydWUpO1xcclxcbiAgbGlzdGVuZXJzLmFkZEV2ZW50TGlzdGVuZXIoXFxcIlNJWkVfQ0xJQ0tFRFxcXCIsIG9uUGxheWVyU2l6ZUNoYW5nZSk7XFxyXFxuICBcXHJcXG4gIHdpbi5hZGRFdmVudExpc3RlbmVyKFxcXCJyZXNpemVcXFwiLCB1dGlscy50aHJvdHRsZSh1cGRhdGUsIDEwMCkpO1xcclxcbiAgXFxyXFxuICAvKiBFeHBvcnRzICovXFxyXFxuICBleHBvcnRzLnNldFNpemUgPSBzZXRTaXplO1xcclxcbiAgZXhwb3J0cy5nZXRSYXRpbyA9IGdldFJhdGlvO1xcclxcbiAgXFxyXFxuICByZXR1cm4gZXhwb3J0cztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvc2l6ZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9wbGF5ZXJcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcInBsYXllci9hcGlcXFwiLCBcXFwicGxheWVyL2NvbmZpZ1xcXCIsIFxcXCJ1bnNhZmVXaW5kb3dcXFwiLCBcXFwicGxheWVyL3NpemVcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgcGxheWVyQVBJLCBwbGF5ZXJDb25maWcsIHV3LCBzaXplKXtcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIGN1cnJlbnQgcGxheWVyIHR5cGUsIHdoaWNoIGNhbiBlaXRoZXIgYmUgSFRNTDUgb3IgZmxhc2guXFxyXFxuICAqXFxyXFxuICAqIEBtZXRob2QgZ2V0VHlwZVxcclxcbiAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwbGF5ZXIgdHlwZS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0VHlwZSgpIHtcXHJcXG4gICAgdmFyIGFwaSA9IHBsYXllckFQSS5nZXRBUEkoKTtcXHJcXG4gICAgaWYgKGFwaSAmJiB0eXBlb2YgYXBpLmdldFBsYXllclR5cGUgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICByZXR1cm4gYXBpLmdldFBsYXllclR5cGUoKTtcXHJcXG4gICAgfVxcclxcbiAgICB2YXIgY2ZnID0gcGxheWVyQ29uZmlnLmdldENvbmZpZygpO1xcclxcbiAgICBpZiAoY2ZnLmh0bWw1KSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCJodG1sNVxcXCI7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCJmbGFzaFxcXCI7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFNldHRpbmcgdGhlIHBsYXllciB0eXBlIHRvIGVpdGhlciBIVE1MNSBvciBmbGFzaFxcclxcbiAgKlxcclxcbiAgKiBAbWV0aG9kIHNldFR5cGVcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGRlc2lyZWQgcGxheWVyIHR5cGUgKEhUTUw1IG9yIGZsYXNoKS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gc2V0VHlwZSh0eXBlKSB7XFxyXFxuICAgIHZhciBjdXJyZW50VHlwZSA9IGdldFR5cGUoKTtcXHJcXG4gICAgaWYgKHR5cGUgPT09IGN1cnJlbnRUeXBlKSB7XFxyXFxuICAgICAgcmV0dXJuOyAvLyBEbyBub3RoaW5nIGFzIGl0XFwncyBhbHJlYWR5IHRoZSBkZXNpcmVkIHBsYXllciB0eXBlXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdmFyIGFwaSA9IHBsYXllckFQSS5nZXRBUEkoKTtcXHJcXG4gICAgICBwbGF5ZXJDb25maWcuc2V0Q29uZmlnKFxcXCJodG1sNVxcXCIsICh0eXBlID09PSBcXFwiaHRtbDVcXFwiID8gdHJ1ZSA6IGZhbHNlKSk7IC8vIFNldHRpbmcgdGhlIHByb3BlcnR5IGh0bWw1IHRvIGVpdGhlciB0cnVlIG9yIGZhbHNlXFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gU29mdC1yZWxvYWRpbmcgdGhlIHBsYXllci4gSWYgWW91VHViZSBkZXRlY3RzIHRoYXQgdGhlIGh0bWw1IHByb3BlcnR5IGhhcyBjaGFuZ2VkIGl0IHdpbGwgY2hhbmdlIHRoZSBwbGF5ZXIuXFxyXFxuICAgICAgaWYgKGFwaSAmJiB0eXBlb2YgYXBpLmxvYWROZXdWaWRlb0NvbmZpZyA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgICAgYXBpLmxvYWROZXdWaWRlb0NvbmZpZyh1dy55dHBsYXllci5jb25maWcpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogR2V0IHRoZSBjb250cm9sYmFyIGhlaWdodC5cXHJcXG4gICpcXHJcXG4gICogQG1ldGhvZCBnZXRDb250cm9sYmFySGVpZ2h0XFxyXFxuICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgY29udHJvbGJhciBvbiB0aGUgcGxheWVyLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBnZXRDb250cm9sYmFySGVpZ2h0KCkge1xcclxcbiAgICB2YXIgbm9uZSA9IDA7XFxyXFxuICAgIHZhciBvbmx5Q29udHJvbGJhciA9IDM7XFxyXFxuICAgIHZhciBvbmx5UHJvZ3Jlc3NiYXIgPSAzMDtcXHJcXG4gICAgdmFyIGJvdGggPSAzNTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBjZmcgPSBwbGF5ZXJDb25maWcuZ2V0Q29uZmlnKCk7XFxyXFxuICAgIHZhciBhdXRvaGlkZSA9IG51bGw7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoY2ZnICYmIGNmZy5hcmdzICYmIHR5cGVvZiBjZmcuYXJncy5hdXRvaGlkZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICBhdXRvaGlkZSA9IGNmZy5hcmdzLmF1dG9oaWRlO1xcclxcbiAgICB9IGVsc2UgaWYgKGdldFR5cGUoKSA9PT0gXFxcImh0bWw1XFxcIikge1xcclxcbiAgICAgIHZhciByYXRpbyA9IHNpemUuZ2V0UmF0aW8oKTtcXHJcXG4gICAgICBpZiAocmF0aW8gPCAxLjM1KSB7XFxyXFxuICAgICAgICBhdXRvaGlkZSA9IFxcXCIzXFxcIjtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHN3aXRjaCAoYXV0b2hpZGUpIHtcXHJcXG4gICAgICBjYXNlIFxcXCIwXFxcIjogcmV0dXJuIGJvdGg7XFxyXFxuICAgICAgY2FzZSBcXFwiMVxcXCI6IHJldHVybiBub25lO1xcclxcbiAgICAgIGNhc2UgXFxcIjNcXFwiOiByZXR1cm4gb25seUNvbnRyb2xiYXI7XFxyXFxuICAgICAgY2FzZSBcXFwiMlxcXCI6IGRlZmF1bHQ6IHJldHVybiBvbmx5UHJvZ3Jlc3NiYXI7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENhbGxpbmcgeXQucGxheWVyLkFwcGxpY2F0aW9uLmNyZWF0ZSB0byB0ZWxsIFlvdVR1YmUgdG9cXHJcXG4gICogY3JlYXRlIHRoZSBZb3VUdWJlIHBsYXllciBhZ2FpbiBhbmQgZGlzcG9zZSBvZiB0aGUgb2xkXFxyXFxuICAqIHBsYXllci5cXHJcXG4gICpcXHJcXG4gICogQG1ldGhvZCByZWxvYWRcXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gcmVsb2FkKCkge1xcclxcbiAgICBpZiAodXcgJiYgdXcueXQgJiYgdXcueXQucGxheWVyICYmIHV3Lnl0LnBsYXllci5BcHBsaWNhdGlvbiAmJiB0eXBlb2YgdXcueXQucGxheWVyLkFwcGxpY2F0aW9uLmNyZWF0ZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgIHV3Lnl0LnBsYXllci5BcHBsaWNhdGlvbi5jcmVhdGUoXFxcInBsYXllci1hcGlcXFwiLCBwbGF5ZXJDb25maWcuZ2V0Q29uZmlnKCkpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuZ2V0VHlwZSA9IGdldFR5cGU7XFxyXFxuICBleHBvcnRzLnNldFR5cGUgPSBzZXRUeXBlO1xcclxcbiAgZXhwb3J0cy5nZXRDb250cm9sYmFySGVpZ2h0ID0gZ2V0Q29udHJvbGJhckhlaWdodDtcXHJcXG4gIGV4cG9ydHMuZ2V0QVBJID0gcGxheWVyQVBJLmdldEFQSTtcXHJcXG4gIGV4cG9ydHMuZ2V0Q29uZmlnID0gcGxheWVyQ29uZmlnLmdldENvbmZpZztcXHJcXG4gIGV4cG9ydHMuc2V0Q29uZmlnID0gcGxheWVyQ29uZmlnLnNldENvbmZpZztcXHJcXG4gIGV4cG9ydHMucmVsb2FkID0gcmVsb2FkO1xcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGxheWVyL3BsYXllci5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ21haW5cXCcsW1xcXCJwbGF5ZXIvcGxheWVyXFxcIiwgXFxcInVuc2FmZVdpbmRvd1xcXCJdLCBmdW5jdGlvbihwbGF5ZXIsIHV3KXtcXHJcXG4gIHV3LnBsYXllciA9IHBsYXllcjtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9tYWluLmpzXCIpO1xuXG4iCiAgXQp9
}
(function () {eval("/**\r\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/jrburke/almond for details\r\n */\r\n//Going sloppy to avoid \'use strict\' string cost, but strict practices should\r\n//be followed.\r\n/*jslint sloppy: true */\r\n/*global setTimeout: false */\r\n\r\nvar requirejs, require, define;\r\n(function (undef) {\r\n    var main, req, makeMap, handlers,\r\n        defined = {},\r\n        waiting = {},\r\n        config = {},\r\n        defining = {},\r\n        hasOwn = Object.prototype.hasOwnProperty,\r\n        aps = [].slice,\r\n        jsSuffixRegExp = /\\.js$/;\r\n\r\n    function hasProp(obj, prop) {\r\n        return hasOwn.call(obj, prop);\r\n    }\r\n\r\n    /**\r\n     * Given a relative module name, like ./something, normalize it to\r\n     * a real name that can be mapped to a path.\r\n     * @param {String} name the relative name\r\n     * @param {String} baseName a real name that the name arg is relative\r\n     * to.\r\n     * @returns {String} normalized name\r\n     */\r\n    function normalize(name, baseName) {\r\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\r\n            foundI, foundStarMap, starI, i, j, part,\r\n            baseParts = baseName && baseName.split(\"/\"),\r\n            map = config.map,\r\n            starMap = (map && map[\'*\']) || {};\r\n\r\n        //Adjust any relative paths.\r\n        if (name && name.charAt(0) === \".\") {\r\n            //If have a base name, try to normalize against it,\r\n            //otherwise, assume it is a top-level require that will\r\n            //be relative to baseUrl in the end.\r\n            if (baseName) {\r\n                //Convert baseName to array, and lop off the last part,\r\n                //so that . matches that \"directory\" and not name of the baseName\'s\r\n                //module. For instance, baseName of \"one/two/three\", maps to\r\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\r\n                //this normalization.\r\n                baseParts = baseParts.slice(0, baseParts.length - 1);\r\n                name = name.split(\'/\');\r\n                lastIndex = name.length - 1;\r\n\r\n                // Node .js allowance:\r\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\r\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, \'\');\r\n                }\r\n\r\n                name = baseParts.concat(name);\r\n\r\n                //start trimDots\r\n                for (i = 0; i < name.length; i += 1) {\r\n                    part = name[i];\r\n                    if (part === \".\") {\r\n                        name.splice(i, 1);\r\n                        i -= 1;\r\n                    } else if (part === \"..\") {\r\n                        if (i === 1 && (name[2] === \'..\' || name[0] === \'..\')) {\r\n                            //End of the line. Keep at least one non-dot\r\n                            //path segment at the front so it can be mapped\r\n                            //correctly to disk. Otherwise, there is likely\r\n                            //no path mapping for a path starting with \'..\'.\r\n                            //This can still fail, but catches the most reasonable\r\n                            //uses of ..\r\n                            break;\r\n                        } else if (i > 0) {\r\n                            name.splice(i - 1, 2);\r\n                            i -= 2;\r\n                        }\r\n                    }\r\n                }\r\n                //end trimDots\r\n\r\n                name = name.join(\"/\");\r\n            } else if (name.indexOf(\'./\') === 0) {\r\n                // No baseName, so this is ID is resolved relative\r\n                // to baseUrl, pull off the leading dot.\r\n                name = name.substring(2);\r\n            }\r\n        }\r\n\r\n        //Apply map config if available.\r\n        if ((baseParts || starMap) && map) {\r\n            nameParts = name.split(\'/\');\r\n\r\n            for (i = nameParts.length; i > 0; i -= 1) {\r\n                nameSegment = nameParts.slice(0, i).join(\"/\");\r\n\r\n                if (baseParts) {\r\n                    //Find the longest baseName segment match in the config.\r\n                    //So, do joins on the biggest to smallest lengths of baseParts.\r\n                    for (j = baseParts.length; j > 0; j -= 1) {\r\n                        mapValue = map[baseParts.slice(0, j).join(\'/\')];\r\n\r\n                        //baseName segment has  config, find if it has one for\r\n                        //this name.\r\n                        if (mapValue) {\r\n                            mapValue = mapValue[nameSegment];\r\n                            if (mapValue) {\r\n                                //Match, update name to the new value.\r\n                                foundMap = mapValue;\r\n                                foundI = i;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (foundMap) {\r\n                    break;\r\n                }\r\n\r\n                //Check for a star map match, but just hold on to it,\r\n                //if there is a shorter segment match later in a matching\r\n                //config, then favor over this star map.\r\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\r\n                    foundStarMap = starMap[nameSegment];\r\n                    starI = i;\r\n                }\r\n            }\r\n\r\n            if (!foundMap && foundStarMap) {\r\n                foundMap = foundStarMap;\r\n                foundI = starI;\r\n            }\r\n\r\n            if (foundMap) {\r\n                nameParts.splice(0, foundI, foundMap);\r\n                name = nameParts.join(\'/\');\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    function makeRequire(relName, forceSync) {\r\n        return function () {\r\n            //A version of a require function that passes a moduleName\r\n            //value for items that may need to\r\n            //look up paths relative to the moduleName\r\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\r\n        };\r\n    }\r\n\r\n    function makeNormalize(relName) {\r\n        return function (name) {\r\n            return normalize(name, relName);\r\n        };\r\n    }\r\n\r\n    function makeLoad(depName) {\r\n        return function (value) {\r\n            defined[depName] = value;\r\n        };\r\n    }\r\n\r\n    function callDep(name) {\r\n        if (hasProp(waiting, name)) {\r\n            var args = waiting[name];\r\n            delete waiting[name];\r\n            defining[name] = true;\r\n            main.apply(undef, args);\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\r\n            throw new Error(\'No \' + name);\r\n        }\r\n        return defined[name];\r\n    }\r\n\r\n    //Turns a plugin!resource to [plugin, resource]\r\n    //with the plugin being undefined if the name\r\n    //did not have a plugin prefix.\r\n    function splitPrefix(name) {\r\n        var prefix,\r\n            index = name ? name.indexOf(\'!\') : -1;\r\n        if (index > -1) {\r\n            prefix = name.substring(0, index);\r\n            name = name.substring(index + 1, name.length);\r\n        }\r\n        return [prefix, name];\r\n    }\r\n\r\n    /**\r\n     * Makes a name map, normalizing the name, and using a plugin\r\n     * for normalization if necessary. Grabs a ref to plugin\r\n     * too, as an optimization.\r\n     */\r\n    makeMap = function (name, relName) {\r\n        var plugin,\r\n            parts = splitPrefix(name),\r\n            prefix = parts[0];\r\n\r\n        name = parts[1];\r\n\r\n        if (prefix) {\r\n            prefix = normalize(prefix, relName);\r\n            plugin = callDep(prefix);\r\n        }\r\n\r\n        //Normalize according\r\n        if (prefix) {\r\n            if (plugin && plugin.normalize) {\r\n                name = plugin.normalize(name, makeNormalize(relName));\r\n            } else {\r\n                name = normalize(name, relName);\r\n            }\r\n        } else {\r\n            name = normalize(name, relName);\r\n            parts = splitPrefix(name);\r\n            prefix = parts[0];\r\n            name = parts[1];\r\n            if (prefix) {\r\n                plugin = callDep(prefix);\r\n            }\r\n        }\r\n\r\n        //Using ridiculous property names for space reasons\r\n        return {\r\n            f: prefix ? prefix + \'!\' + name : name, //fullName\r\n            n: name,\r\n            pr: prefix,\r\n            p: plugin\r\n        };\r\n    };\r\n\r\n    function makeConfig(name) {\r\n        return function () {\r\n            return (config && config.config && config.config[name]) || {};\r\n        };\r\n    }\r\n\r\n    handlers = {\r\n        require: function (name) {\r\n            return makeRequire(name);\r\n        },\r\n        exports: function (name) {\r\n            var e = defined[name];\r\n            if (typeof e !== \'undefined\') {\r\n                return e;\r\n            } else {\r\n                return (defined[name] = {});\r\n            }\r\n        },\r\n        module: function (name) {\r\n            return {\r\n                id: name,\r\n                uri: \'\',\r\n                exports: defined[name],\r\n                config: makeConfig(name)\r\n            };\r\n        }\r\n    };\r\n\r\n    main = function (name, deps, callback, relName) {\r\n        var cjsModule, depName, ret, map, i,\r\n            args = [],\r\n            callbackType = typeof callback,\r\n            usingExports;\r\n\r\n        //Use name if no relName\r\n        relName = relName || name;\r\n\r\n        //Call the callback to define the module, if necessary.\r\n        if (callbackType === \'undefined\' || callbackType === \'function\') {\r\n            //Pull out the defined dependencies and pass the ordered\r\n            //values to the callback.\r\n            //Default to [require, exports, module] if no deps\r\n            deps = !deps.length && callback.length ? [\'require\', \'exports\', \'module\'] : deps;\r\n            for (i = 0; i < deps.length; i += 1) {\r\n                map = makeMap(deps[i], relName);\r\n                depName = map.f;\r\n\r\n                //Fast path CommonJS standard dependencies.\r\n                if (depName === \"require\") {\r\n                    args[i] = handlers.require(name);\r\n                } else if (depName === \"exports\") {\r\n                    //CommonJS module spec 1.1\r\n                    args[i] = handlers.exports(name);\r\n                    usingExports = true;\r\n                } else if (depName === \"module\") {\r\n                    //CommonJS module spec 1.1\r\n                    cjsModule = args[i] = handlers.module(name);\r\n                } else if (hasProp(defined, depName) ||\r\n                           hasProp(waiting, depName) ||\r\n                           hasProp(defining, depName)) {\r\n                    args[i] = callDep(depName);\r\n                } else if (map.p) {\r\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\r\n                    args[i] = defined[depName];\r\n                } else {\r\n                    throw new Error(name + \' missing \' + depName);\r\n                }\r\n            }\r\n\r\n            ret = callback ? callback.apply(defined[name], args) : undefined;\r\n\r\n            if (name) {\r\n                //If setting exports via \"module\" is in play,\r\n                //favor that over return value and exports. After that,\r\n                //favor a non-undefined return value over exports use.\r\n                if (cjsModule && cjsModule.exports !== undef &&\r\n                        cjsModule.exports !== defined[name]) {\r\n                    defined[name] = cjsModule.exports;\r\n                } else if (ret !== undef || !usingExports) {\r\n                    //Use the return value from the function.\r\n                    defined[name] = ret;\r\n                }\r\n            }\r\n        } else if (name) {\r\n            //May just be an object definition for the module. Only\r\n            //worry about defining if have a module name.\r\n            defined[name] = callback;\r\n        }\r\n    };\r\n\r\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\r\n        if (typeof deps === \"string\") {\r\n            if (handlers[deps]) {\r\n                //callback in this case is really relName\r\n                return handlers[deps](callback);\r\n            }\r\n            //Just return the module wanted. In this scenario, the\r\n            //deps arg is the module name, and second arg (if passed)\r\n            //is just the relName.\r\n            //Normalize module name, if it contains . or ..\r\n            return callDep(makeMap(deps, callback).f);\r\n        } else if (!deps.splice) {\r\n            //deps is a config object, not an array.\r\n            config = deps;\r\n            if (config.deps) {\r\n                req(config.deps, config.callback);\r\n            }\r\n            if (!callback) {\r\n                return;\r\n            }\r\n\r\n            if (callback.splice) {\r\n                //callback is an array, which means it is a dependency list.\r\n                //Adjust args if there are dependencies\r\n                deps = callback;\r\n                callback = relName;\r\n                relName = null;\r\n            } else {\r\n                deps = undef;\r\n            }\r\n        }\r\n\r\n        //Support require([\'a\'])\r\n        callback = callback || function () {};\r\n\r\n        //If relName is a function, it is an errback handler,\r\n        //so remove it.\r\n        if (typeof relName === \'function\') {\r\n            relName = forceSync;\r\n            forceSync = alt;\r\n        }\r\n\r\n        //Simulate async callback;\r\n        if (forceSync) {\r\n            main(undef, deps, callback, relName);\r\n        } else {\r\n            //Using a non-zero value because of concern for what old browsers\r\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\r\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\r\n            //If want a value immediately, use require(\'id\') instead -- something\r\n            //that works in almond on the global level, but not guaranteed and\r\n            //unlikely to work in other AMD implementations.\r\n            setTimeout(function () {\r\n                main(undef, deps, callback, relName);\r\n            }, 4);\r\n        }\r\n\r\n        return req;\r\n    };\r\n\r\n    /**\r\n     * Just drops the config on the floor, but returns req in case\r\n     * the config return value is used.\r\n     */\r\n    req.config = function (cfg) {\r\n        return req(cfg);\r\n    };\r\n\r\n    /**\r\n     * Expose module registry for debugging and tooling\r\n     */\r\n    requirejs._defined = defined;\r\n\r\n    define = function (name, deps, callback) {\r\n\r\n        //This module may not have dependencies\r\n        if (!deps.splice) {\r\n            //deps is not an array, so probably means\r\n            //an object literal or factory function for\r\n            //the value. Adjust args.\r\n            callback = deps;\r\n            deps = [];\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\r\n            waiting[name] = [name, deps, callback];\r\n        }\r\n    };\r\n\r\n    define.amd = {\r\n        jQuery: true\r\n    };\r\n}());\r\n\n//# sourceURL=/../vendor/almond.js");

define("../vendor/almond", function(){});

eval("define(\'unsafeWindow\',[], function(){\r\n  return window;\r\n});\n//# sourceURL=/unsafeWindow.js");

eval("define(\'support\',[\"unsafeWindow\"], function(uw){\r\n  function localStorageTest() {\r\n    var mod = \"support.test\";\r\n    try {\r\n      localStorage.setItem(mod, mod);\r\n      localStorage.removeItem(mod);\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  var isWebkitURL = typeof uw.webkitURL === \"object\";\r\n  var isURL = typeof uw.URL === \"object\";\r\n  var isCreateObjectURL = false;\r\n  var isRevokeObjectURL = false;\r\n  \r\n  var maxthonRuntime = window && window.external && window.external.mxGetRuntime && typeof window.external.mxGetRuntime === \"function\";\r\n  \r\n  if (isWebkitURL) {\r\n    isCreateObjectURL = typeof uw.webkitURL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.webkitURL.revokeObjectURL === \"function\";\r\n  } else if (isURL) {\r\n    isCreateObjectURL = typeof uw.URL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.URL.revokeObjectURL === \"function\";\r\n  }\r\n  \r\n  return {\r\n    localStorage: localStorageTest(),\r\n    Greasemonkey: (typeof GM_setValue !== \"undefined\" && (typeof GM_setValue.toString === \"undefined\" || GM_setValue.toString().indexOf(\"not supported\") === -1)),\r\n    createObjectURL: isCreateObjectURL,\r\n    revokeObjectURL: isRevokeObjectURL,\r\n    webkitURL: isWebkitURL,\r\n    URL: isURL,\r\n    maxthonRuntime: maxthonRuntime,\r\n    maxthonRuntimeStorage: maxthonRuntime && window.external.mxGetRuntime() && window.external.mxGetRuntime().storage,\r\n    firefoxPort: this.port && typeof this.port.request === \"function\" && this.port.storage && typeof this.port.on === \"function\"\r\n  };\r\n});\n//# sourceURL=/support.js");

eval("define(\'utils\',[\"support\", \"unsafeWindow\"], function(support, uw){\r\n  function each(obj, callback) {\r\n    if (isArray(obj)) {\r\n      for (var i = 0; i < obj.length; i++) {\r\n        if (callback(i, obj[i]) === true) break;\r\n      }\r\n    } else {\r\n      for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          if (callback(key, obj[key]) === true) break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n  }\r\n  \r\n  function asyncCall(scope, callback) {\r\n    return setTimeout(bind.apply(null, [scope, callback].concat(Array.prototype.slice.call(arguments, 2))), 0);\r\n  }\r\n  \r\n  function bind(scope, func) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    return function(){\r\n      return func.apply(scope, args.concat(Array.prototype.slice.call(arguments)))\r\n    };\r\n  }\r\n  function trimLeft(obj){\r\n    return obj.replace(/^\\s+/, \"\");\r\n  }\r\n  function trimRight(obj){\r\n    return obj.replace(/\\s+$/, \"\");\r\n  }\r\n  function map(obj, callback, thisArg) {\r\n    for (var i = 0, n = obj.length, a = []; i < n; i++) {\r\n      if (i in obj) a[i] = callback.call(thisArg, obj[i]);\r\n    }\r\n    return a;\r\n  }\r\n  \r\n  function defineLockedProperty(obj, key, setter, getter) {\r\n    if (typeof obj !== \"object\") obj = {};\r\n    if (ie || typeof Object.defineProperty === \"function\") {\r\n      Object.defineProperty(obj, key, {\r\n        get: getter,\r\n        set: setter\r\n      });\r\n      return obj;\r\n    } else {\r\n      obj.__defineGetter__(key, getter);\r\n      obj.__defineSetter__(key, setter);\r\n      return obj;\r\n    }\r\n  }\r\n  \r\n  function addEventListener(elm, event, callback, useCapture) {\r\n    if (elm.addEventListener) {\r\n      elm.addEventListener(event, callback, useCapture || false);\r\n    } else if (elm.attachEvent) {\r\n      elm.attachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  function removeEventListener(elm, event, callback, useCapture) {\r\n    if (elm.removeEventListener) {\r\n      elm.removeEventListener(event, callback, useCapture || false);\r\n    } else if (elm.detachEvent) {\r\n      elm.detachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  var ie = (function(){\r\n    for (var v = 3, el = document.createElement(\'b\'), all = el.all || []; el.innerHTML = \'<!--[if gt IE \' + (++v) + \']><i><![endif]-->\', all[0];);\r\n    return v > 4 ? v : !!document.documentMode;\r\n  }());\r\n  \r\n  var now = Date.now || function () {\r\n    return +new Date;\r\n  };\r\n  \r\n  /* Cookies */\r\n  function setCookie(name, value, domain, path, expires) {\r\n    domain = domain ? \";domain=\" + encodeURIComponent(domain) : \"\";\r\n    path = path ? \";path=\" + encodeURIComponent(path) : \"\";\r\n    expires = 0 > expires ? \"\" : 0 == expires ? \";expires=\" + (new Date(1970, 1, 1)).toUTCString() : \";expires=\" + (new Date(now() + 1E3 * expires)).toUTCString();\r\n    \r\n    document.cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value) + domain + path + expires;\r\n  }\r\n  \r\n  function getCookie(key) {\r\n    return getCookies()[key];\r\n  }\r\n  \r\n  function getCookies() {\r\n    var c = document.cookie, v = 0, cookies = {};\r\n    if (document.cookie.match(/^\\s*\\$Version=(?:\"1\"|1);\\s*(.*)/)) {\r\n      c = RegExp.$1;\r\n      v = 1;\r\n    }\r\n    if (v === 0) {\r\n      map(c.split(/[,;]/), function(cookie) {\r\n        var parts = cookie.split(/=/, 2),\r\n            name = decodeURIComponent(trimLeft(parts[0])),\r\n            value = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;\r\n        cookies[name] = value;\r\n      });\r\n    } else {\r\n      map(c.match(/(?:^|\\s+)([!#$%&\'*+\\-.0-9A-Z^`a-z|~]+)=([!#$%&\'*+\\-.0-9A-Z^`a-z|~]*|\"(?:[\\x20-\\x7E\\x80\\xFF]|\\\\[\\x00-\\x7F])*\")(?=\\s*[,;]|$)/g), function($0, $1) {\r\n        var name = $0, value = $1.charAt(0) === \'\"\' ? $1.substr(1, -1).replace(/\\\\(.)/g, \"$1\") : $1;\r\n        cookies[name] = value;\r\n      });\r\n    }\r\n    return cookies;\r\n  }\r\n  \r\n  function endsWith(str, suffix) {\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n  }\r\n  \r\n  function inject(func) {\r\n    var script = document.createElement(\"script\"),\r\n        p = (document.body || document.head || document.documentElement);\r\n    if (!p) {\r\n      throw \"Could not inject!!!\";\r\n    }\r\n    script.setAttribute(\"type\", \"text/javascript\");\r\n    script.appendChild(document.createTextNode(\"(\" + func + \")(\" + buildArgumentList.apply(null, [false].concat(Array.prototype.slice.call(arguments, 1))) + \");\"));\r\n    p.appendChild(script);\r\n    p.removeChild(script);\r\n  }\r\n  \r\n  function buildArgumentList(wrap) {\r\n    var list = [];\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    \r\n    for (var i = 0, len = args.length; i < len; i++) {\r\n      if (typeof args[i] === \"string\") {\r\n        list.push(\"\\\"\" + args[i].replace(/\\\\/, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\");\r\n      } else if (typeof args[i] === \"object\") {\r\n        list.push(JSON.stringify(args[i]));\r\n      } else if (typeof args[i] === \"undefined\") {\r\n        list.push(\"null\");\r\n      } else {\r\n        list.push(args[i]);\r\n      }\r\n    }\r\n    if (wrap) {\r\n      return \"(\" + list.join(\",\") + \")\";\r\n    } else {\r\n      return list.join(\",\");\r\n    }\r\n  }\r\n  \r\n  function isJSONString(json) {\r\n    try {\r\n      JSON.parse(json);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function xhr(details) {\r\n    var xmlhttp;\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new XMLHttpRequest();\r\n    } else if (typeof opera !== \"undefined\" && typeof opera.XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new opera.XMLHttpRequest();\r\n    } else {\r\n      if (details[\"onerror\"]) {\r\n        details[\"onerror\"]();\r\n      }\r\n      \r\n      return;\r\n    }\r\n    xmlhttp.onreadystatechange = function(){\r\n      var responseState = {\r\n        responseXML:(xmlhttp.readyState == 4 ? xmlhttp.responseXML : \'\'),\r\n        responseText:(xmlhttp.readyState == 4 ? xmlhttp.responseText : \'\'),\r\n        readyState:xmlhttp.readyState,\r\n        responseHeaders:(xmlhttp.readyState == 4 ? xmlhttp.getAllResponseHeaders() : \'\'),\r\n        status:(xmlhttp.readyState == 4 ? xmlhttp.status : 0),\r\n        statusText:(xmlhttp.readyState == 4 ? xmlhttp.statusText : \'\'),\r\n        finalUrl:(xmlhttp.readyState == 4 ? xmlhttp.finalUrl : \'\')\r\n      };\r\n      if (details[\"onreadystatechange\"]) {\r\n        details[\"onreadystatechange\"](responseState);\r\n      }\r\n      if (xmlhttp.readyState == 4) {\r\n        if (details[\"onload\"] && xmlhttp.status >= 200 && xmlhttp.status < 300) {\r\n          details[\"onload\"](responseState);\r\n        }\r\n        if (details[\"onerror\"] && (xmlhttp.status < 200 || xmlhttp.status >= 300)) {\r\n          details[\"onerror\"](responseState);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      xmlhttp.open(details.method, details.url);\r\n    } catch(e) {\r\n      if(details[\"onerror\"]) {\r\n        details[\"onerror\"]({responseXML:\'\',responseText:\'\',readyState:4,responseHeaders:\'\',status:403,statusText:\'Forbidden\'});\r\n      }\r\n      return;\r\n    }\r\n    if (details.headers) {\r\n      for (var prop in details.headers) {\r\n        xmlhttp.setRequestHeader(prop, details.headers[prop]);\r\n      }\r\n    }\r\n    xmlhttp.send((typeof(details.data) != \'undefined\') ? details.data : null);\r\n  }\r\n  \r\n  // Used for the message module (should probably move to another place)\r\n  // It replaces a property in the obj to a predefined function, where the arguments will be callbackId, target, referer\r\n  function bindFunctionCallbacks(obj, func, target, referer) {\r\n    for (key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"obj\") {\r\n          bindFunctionCallbacks(obj[key]);\r\n        } else if (typeof obj[key] === \"string\") {\r\n          if (obj[key].indexOf(\"@/(message.callback)/\") === 0) {\r\n            var callbackId = obj[key].split(\"@/(message.callback)/\")[1];\r\n            obj[key] = bind(null, func, callbackId, target, referer);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function extend(obj, defaults, deep) {\r\n    if (typeof obj !== \"object\") throw new TypeError(\"Unsupported type for obj.\");\r\n    if (typeof defaults !== \"object\") throw new TypeError(\"Unsupported type for defaults.\");\r\n    \r\n    for (var key in defaults) {\r\n      if (defaults.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"object\" && typeof defaults[key] === \"object\" && deep) {\r\n          extend(obj[key], defaults[key], deep);\r\n        } else if (!obj.hasOwnProperty(key)) {\r\n          obj[key] = defaults[key];\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function inArray(key, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function listClasses(el) {\r\n    if (!el || !el.className) return [];\r\n    return el.className.split(\" \");\r\n  }\r\n  \r\n  function addClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var addList = className.split(\" \");\r\n    \r\n    for (var i = 0, len = addList.length; i < len; i++) {\r\n      if (!inArray(addList[i], classes)) {\r\n        el.className += \" \" + addList[i];\r\n      }\r\n    }\r\n    return el.className;\r\n  }\r\n  \r\n  function removeClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var removeList = className.split(\" \");\r\n    \r\n    var buffer = [];\r\n    for (var i = 0, len = classes.length; i < len; i++) {\r\n      if (!inArray(classes[i], removeList)) {\r\n        buffer.push(classes[i]);\r\n      }\r\n    }\r\n    return el.className = buffer.join(\" \");\r\n  }\r\n  \r\n  function hasClass(el, className) {\r\n    return inArray(className, listClasses(el));\r\n  }\r\n  \r\n  function throttle(func, delay, options){\r\n    function timeout() {\r\n      previous = options.leading === false ? 0 : new Date;\r\n      timer = null;\r\n      result = func.apply(context, args);\r\n    }\r\n    var context, args, result, timer = null, previous = 0;\r\n    options = options || {};\r\n    return function(){\r\n      var now = new Date, dt;\r\n      \r\n      context = this;\r\n      args = arguments;\r\n      \r\n      if (!previous && options.leading === false) previous = now;\r\n      dt = delay - (now - previous);\r\n      \r\n      if (dt <= 0) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n        previous = now;\r\n        result = func.apply(context, args);\r\n      } else if (!timer && options.trailing !== false) {\r\n        timer = setTimeout(timeout, dt);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n  \r\n  function clone(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n  \r\n  function removeDuplicates(arr) {\r\n    var uniqueArr = [];\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (!inArray(uniqueArr, arr[i])) {\r\n        uniqueArr.push(arr[i]);\r\n      }\r\n    }\r\n    \r\n    return uniqueArr;\r\n  }\r\n  \r\n  function escapeRegExp(str) {\r\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n  }\r\n  \r\n  function toBlob(bytes, contentType) {\r\n    contentType = contentType || \"text/plain\";\r\n    var sliceSize = 512;\r\n    \r\n    var bytesLength = bytes.length;\r\n    var slicesCount = Math.ceil(bytesLength / sliceSize);\r\n    \r\n    var byteArrays = new Array(slicesCount);\r\n    \r\n    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\r\n      var begin = sliceIndex * sliceSize;\r\n      var end = Math.min(begin + sliceSize, bytesLength);\r\n      \r\n      var sliceBytes = new Array(end - begin);\r\n      for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {\r\n        sliceBytes[i] = bytes[offset].charCodeAt(0);\r\n      }\r\n      byteArrays[sliceIndex] = new Uint8Array(sliceBytes);\r\n    }\r\n    \r\n    return new Blob(byteArrays, { type: contentType });\r\n  }\r\n  \r\n  function createObjectURL(blob) {\r\n    if (support.createObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.createObjectURL(blob);\r\n      } else {\r\n        return uw.URL.createObjectURL(blob);\r\n      }\r\n    } else {\r\n      throw \"createObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  function revokeObjectURL(url) {\r\n    if (support.revokeObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.revokeObjectURL(url);\r\n      } else {\r\n        return uw.URL.revokeObjectURL(url);\r\n      }\r\n    } else {\r\n      throw \"revokeObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  // Returns a random number between min and max\r\n  function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n  \r\n  // Returns a random integer between min (included) and max (excluded)\r\n  function getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n  \r\n  // Returns a random string of characters of chars with the length of length\r\n  function generateToken(chars, length) {\r\n    if (typeof chars !== \"string\") chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\";\r\n    if (typeof length !== \"number\") length = 64;\r\n    \r\n    var charsLength = chars.length;\r\n    \r\n    var token = \"\";\r\n    for (var i = 0; i < length; i++) {\r\n      token += chars[getRandomInt(0, charsLength)];\r\n    }\r\n    \r\n    return token;\r\n  }\r\n  \r\n  function escapeECMAVariable(key, defaultKey) {\r\n    key = key.replace(/[^0-9a-zA-Z_\\$]/g, \"\");\r\n    while (/$[0-9]/g.test(key) && key.length > 0) {\r\n      if (key === \"\") return defaultKey;\r\n      key = key.substring(1);\r\n    }\r\n    return key;\r\n  }\r\n  \r\n  function indexOfArray(value, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === value) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n  \r\n  function getKeys(obj) {\r\n    var keys = [];\r\n    each(obj, function(key){\r\n      keys.push(key);\r\n    });\r\n    return keys;\r\n  }\r\n  \r\n  function setProperty(target, path, value, createPath) {\r\n    var tokens = path.split(\".\");\r\n    for (var i = 0, len = tokens.length - 1; i < len; i++) {\r\n      if (target[tokens[i]]) {\r\n        target = target[tokens[i]];\r\n      } else {\r\n        if (createPath) {\r\n          target[tokens[i]] = {};\r\n          target = target[tokens[i]];\r\n        } else {\r\n          throw \"Path \" + path + \" does not exist for\", target;\r\n        }\r\n      }\r\n    }\r\n    target[tokens[tokens.length - 1]] = value;\r\n  }\r\n  \r\n  return {\r\n    hasClass: hasClass,\r\n    removeClass: removeClass,\r\n    addClass: addClass,\r\n    each: each,\r\n    isArray: isArray,\r\n    inArray: inArray,\r\n    bind: bind,\r\n    asyncCall: asyncCall,\r\n    defineLockedProperty: defineLockedProperty,\r\n    ie: ie,\r\n    addEventListener: addEventListener,\r\n    removeEventListener: removeEventListener,\r\n    now: now,\r\n    trimLeft: trimLeft,\r\n    trimRight: trimRight,\r\n    map: map,\r\n    setCookie: setCookie,\r\n    getCookie: getCookie,\r\n    getCookies: getCookies,\r\n    endsWith: endsWith,\r\n    inject: inject,\r\n    isJSONString: isJSONString,\r\n    xhr: xhr,\r\n    buildArgumentList: buildArgumentList,\r\n    bindFunctionCallbacks: bindFunctionCallbacks,\r\n    extend: extend,\r\n    throttle: throttle,\r\n    clone: clone,\r\n    removeDuplicates: removeDuplicates,\r\n    escapeRegExp: escapeRegExp,\r\n    toBlob: toBlob,\r\n    createObjectURL: createObjectURL,\r\n    revokeObjectURL: revokeObjectURL,\r\n    getRandomArbitrary: getRandomArbitrary,\r\n    getRandomInt: getRandomInt,\r\n    generateToken: generateToken,\r\n    escapeECMAVariable: escapeECMAVariable,\r\n    indexOfArray: indexOfArray,\r\n    getKeys: getKeys,\r\n    setProperty: setProperty\r\n  };\r\n});\n//# sourceURL=/utils.js");

eval("define(\'storage/localStorage\',[\"utils\"], function(utils){\r\n  function getItem(key, callback, preferSync) {\r\n    var item = localStorage.getItem(key);\r\n    if (preferSync) {\r\n      callback(item);\r\n    } else {\r\n      utils.asyncCall(null, callback, item);\r\n    }\r\n  }\r\n  \r\n  return {\r\n    setItem: utils.bind(localStorage, localStorage.setItem),\r\n    getItem: getItem,\r\n    removeItem: utils.bind(localStorage, localStorage.removeItem)\r\n  };\r\n});\n//# sourceURL=/storage/localStorage.js");

eval("define(\'storage/cookies\',[\"utils\"], function(utils){\r\n  function setItem(key, value) {\r\n    utils.setCookie(prefix + key, value, null, \"/\", 1000*24*60*60*1000);\r\n  }\r\n  \r\n  function getItem(key, callback, preferSync) {\r\n    var item = utils.getCookie(prefix + key);\r\n    if (preferSync) {\r\n      callback(item);\r\n    } else {\r\n      utils.asyncCall(null, callback, item);\r\n    }\r\n  }\r\n  \r\n  function removeItem(key) {\r\n    utils.setCookie(prefix + key, \"\", null, \"/\", 0);\r\n  }\r\n  \r\n  var prefix = \"ytcenter.\";\r\n  \r\n  return {\r\n    setItem: setItem,\r\n    getItem: getItem,\r\n    removeItem: removeItem\r\n  };\r\n});\n//# sourceURL=/storage/cookies.js");

eval("define(\'console\',[\"utils\"], function(utils){\r\n  function setEnabled(b) {\r\n    enabled = b;\r\n  }\r\n  \r\n  function log() {\r\n    if (!enabled) return function(){};\r\n    return console.log.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function error() {\r\n    if (!enabled) return function(){};\r\n    return console.error.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function warn() {\r\n    if (!enabled) return function(){};\r\n    return console.warn.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  var sessionToken = (typeof consoleSessionToken === \"string\" ? consoleSessionToken : utils.generateToken(null, 8));\r\n  \r\n  var enabled = true;\r\n  \r\n  var con = {};\r\n  \r\n  con.sessionToken = sessionToken;\r\n  \r\n  utils.defineLockedProperty(con, \"log\", function(){}, log);\r\n  utils.defineLockedProperty(con, \"error\", function(){}, error);\r\n  utils.defineLockedProperty(con, \"warn\", function(){}, warn);\r\n  \r\n  return con;\r\n});\n//# sourceURL=/console.js");

eval("define(\'storage/browser\',[\"support\", \"storage/localStorage\", \"storage/cookies\", \"console\"], function(support, localStorage, cookies){\r\n  if (support.localStorage) {\r\n    return localStorage;\r\n  } else {\r\n    return cookies;\r\n  }\r\n});\n//# sourceURL=/storage/browser.js");

eval("define(\'storage/userscript\',[\"support\", \"storage/browser\", \"utils\"], function(support, browser, utils){\r\n  function setItem(key, value) {\r\n    GM_setValue(key, value);\r\n  }\r\n  \r\n  function getItem(key, callback, preferSync) {\r\n    var item = GM_getValue(key);\r\n    if (preferSync) {\r\n      callback(item);\r\n    } else {\r\n      utils.asyncCall(null, callback, item);\r\n    }\r\n  }\r\n  \r\n  function removeItem(key) {\r\n    GM_deleteValue(key);\r\n  }\r\n  \r\n  if (support.Greasemonkey) {\r\n    return {\r\n      setItem: setItem,\r\n      removeItem: removeItem,\r\n      getItem: getItem\r\n    };\r\n  } else {\r\n    return browser;\r\n  }\r\n});\n//# sourceURL=/storage/userscript.js");

eval("define(\'storage\',[\"exports\", \"storage/userscript\", \"utils\"], function(exports, storageHandler, utils){\r\n  function setItem(key, value) {\r\n    cache[key] = value;\r\n    storageHandler.setItem(key, value);\r\n  }\r\n  \r\n  function removeItem(key) {\r\n    delete cache[key];\r\n    storageHandler.removeItem(key);\r\n  }\r\n  \r\n  function getItemCallback(callback, key, value) {\r\n    cache[key] = value;\r\n    callback(cache[key]);\r\n  }\r\n  \r\n  function getItem(key, callback, sync) {\r\n    if (!(key in cache)) {\r\n      storageHandler.getItem(key, utils.bind(null, getItemCallback, callback, key));\r\n    } else {\r\n      if (sync) {\r\n        callback(cache[key]);\r\n        return cache[key];\r\n      } else {\r\n        utils.asyncCall(null, callback, cache[key]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  var cache = {};\r\n  \r\n  /* Exports */\r\n  exports.setItem = setItem;\r\n  exports.removeItem = removeItem;\r\n  exports.getItem = getItem;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/storage.js");

eval("define(\'UserProxy/CustomEvent\',[\"utils\"], function(utils){\r\n  function addEventListener(event, listener) {\r\n    if (!events[event]) {\r\n      // Creating the array of listeners for event\r\n      events[event] = [];\r\n      \r\n      docListeners[event] = utils.bind(null, eventListener, event, events[event]);\r\n      \r\n      // Adding the event listener.\r\n      window.addEventListener(event, docListeners[event], false);\r\n    }\r\n    \r\n    // Adding listener to array.\r\n    events[event].push(listener);\r\n  }\r\n  \r\n  function removeEventListener(event, listener) {\r\n    if (event in events) {\r\n      for (var i = 0, len = events[event].length; i < len; i++) {\r\n        if (events[event][i] === listener) {\r\n          events[event].splice(i, 1);\r\n          i--; len--;\r\n        }\r\n      }\r\n      if (events[event].length === 0) {\r\n        window.removeEventListener(event, docListeners[event], false);\r\n        \r\n        events[event] = null;\r\n        docListeners[event] = null;\r\n      }\r\n    }\r\n  }\r\n  \r\n  function eventListener(event, listeners, e) {\r\n    e = e || window.event;\r\n    \r\n    // Parse the detail to the original object.\r\n    var data = JSON.parse(e.detail);\r\n    \r\n    if (typeof data.detail === \"object\" && data.token !== token) {\r\n      var detail = data.detail;\r\n      for (var i = 0, len = listeners.length; i < len; i++) {\r\n        // Call the listener with the event name and the parsed detail.\r\n        listeners[i](detail);\r\n      }\r\n      \r\n      // Prevent propagation\r\n      if (e && typeof e.stopPropagation === \"function\") {\r\n        e.stopPropagation();\r\n      }\r\n    }\r\n  }\r\n  \r\n  function fireEvent(event, detail) {\r\n    // Creating the event\r\n    var e = document.createEvent(\"CustomEvent\");\r\n    e.initCustomEvent(event, true, true, JSON.stringify({ detail: detail, token: token }));\r\n    \r\n    // Firing the event\r\n    document.documentElement.dispatchEvent(e);\r\n  }\r\n  \r\n  var token = utils.generateToken(); // The token is used to identify itself and prevent calling its own listeners.\r\n  var events = {};\r\n  var docListeners = {};\r\n  \r\n  return {\r\n    addEventListener: addEventListener,\r\n    removeEventListener: removeEventListener,\r\n    fireEvent: fireEvent\r\n  };\r\n});\n//# sourceURL=/UserProxy/CustomEvent.js");

eval("define(\'UserProxy/Message\',[\"utils\"], function(utils){\r\n  function addEventListener(event, listener) {\r\n    initMessage(); // Init the message event listener if not already initialized.\r\n    \r\n    if (!events[event]) events[event] = [];\r\n    \r\n    // Bind the event name to the listener as an argument.\r\n    var boundListener = utils.bind(null, listener, event);\r\n    \r\n    // Add the boundListener to the event\r\n    events[event].push(boundListener);\r\n  }\r\n  \r\n  function fireEvent(event, detail) {\r\n    window.postMessage(JSON.stringify({ token: token, event: event, detail: detail }), \"*\");\r\n  }\r\n  \r\n  function messageListener(e) {\r\n    e = e || window.event;\r\n    \r\n    // Parse the detail to the original object.\r\n    var data = JSON.parse(e.data);\r\n    \r\n    // Verify that the retrieved information is correct and that it didn\'t call itself.\r\n    if (typeof data.event === \"string\" && typeof data.detail === \"object\" && data.token !== token) {\r\n      \r\n      // Iterate through every listener for data.event.\r\n      if (utils.isArray(events[data.event])) {\r\n        var listeners = events[data.event];\r\n        \r\n        var detail = data.detail;\r\n        for (var i = 0, len = listeners.length; i < len; i++) {\r\n          listeners(detail);\r\n        }\r\n    \r\n        // Prevent propagation only if everything went well.\r\n        if (e && typeof e.stopPropagation === \"function\") {\r\n          e.stopPropagation();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function initMessage() {\r\n    if (!messageEventAdded) {\r\n      // Adding the message event listener.\r\n      window.addEventListener(\"message\", messageListener, false);\r\n    }\r\n  }\r\n  \r\n  var messageEventAdded = false;\r\n  var token = utils.generateToken(); // The token is used to identify itself and prevent calling its own listeners.\r\n  \r\n  var events = {};\r\n  \r\n  return {\r\n    addEventListener: addEventListener,\r\n    fireEvent: fireEvent\r\n  };\r\n});\n//# sourceURL=/UserProxy/Message.js");

eval("define(\'UserProxy/support\',[], function(){\r\n  function customEvent() {\r\n    try {\r\n      var e = document.createEvent(\'CustomEvent\');\r\n      if (e && typeof e.initCustomEvent === \"function\") {\r\n        e.initCustomEvent(mod, true, true, { mod: mod });\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  var mod = \"support.test\";\r\n  \r\n  return {\r\n    CustomEvent: customEvent\r\n  };\r\n});\n//# sourceURL=/UserProxy/support.js");

eval("define(\'UserProxy/memFunction\',[\"utils\", \"./CustomEvent\", \"./Message\", \"./support\"], function(utils, customEvent, message, support){\r\n  function parseObject(obj, token, type) {\r\n    if (typeof obj === \"object\") {\r\n      utils.each(obj, function(key, value){\r\n        if (typeof value === \"object\") {\r\n          obj[key] = parseObject(value, token, type);\r\n        } else if (typeof value === \"string\") {\r\n          obj[key] = parseString(value);\r\n        } else if (typeof value === \"function\") {\r\n          var id = cache.push(value) - 1;\r\n          obj[key] = \"${\" + token + \"/\" + type + \"/\" + id + \"}\";\r\n        }\r\n      });\r\n    } else if (typeof value === \"string\") {\r\n      obj = parseString(obj);\r\n    } else if (typeof obj === \"function\") {\r\n      var id = cache.push(obj) - 1;\r\n      obj = \"${\" + token + \"/\" + type + \"/\" + id + \"}\";\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function parseString(str) {\r\n    if (/^\\$[\\\\]*\\{([0-9a-zA-Z\\.\\-_\\/\\\\]+)\\}$/g.test(str)) {\r\n      return \"$\\\\\" + str.substring(1);\r\n    }\r\n    return str;\r\n  }\r\n  \r\n  function restoreString(str, token, type) {\r\n    if (/^\\$\\{([0-9a-zA-Z\\.\\-_]+)\\/([0-9a-zA-Z\\.\\-_]+)\\/([0-9]+)\\}$/g.test(str)) {\r\n      var parsed = str.substring(2, str.length - 1).split(\"/\"); // \" + token + \"/\" + type + \"/\" + id + \"\r\n      var id = parseInt(parsed[2], 10);\r\n      if (parsed[0] === token && parsed[1] === type) {\r\n        return cache[id];\r\n      } else {\r\n        return utils.bind(null, functionPlaceholder, parsed[0] + \"-\" + parsed[1], id);\r\n      }\r\n    } else if (/^\\$[\\\\]+\\{([0-9a-zA-Z\\.\\-_\\/\\\\]+)\\}$/g.test(str)) {\r\n      return \"$\" + str.substring(2);\r\n    }\r\n    return str;\r\n  }\r\n  \r\n  function restoreObject(obj, token, type) {\r\n    if (typeof obj === \"object\") {\r\n      utils.each(obj, function(key, value){\r\n        if (typeof value === \"object\") {\r\n          obj[key] = restoreObject(value, token, type);\r\n        } else if (typeof value === \"string\") {\r\n          obj[key] = restoreString(value, token, type);\r\n        } else if (typeof value === \"function\") {\r\n          throw Error(\"Function was found!\");\r\n        }\r\n      });\r\n    } else if (typeof value === \"string\") {\r\n      return restoreString(value, token, type);\r\n    } else if (typeof value === \"function\") {\r\n      throw Error(\"Function was found!\");\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function functionPlaceholder(event, id) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    if (support.CustomEvent) {\r\n      return customEvent.fireEvent(event, { callbackId: id, args: args, mem: true });\r\n    } else {\r\n      return message.fireEvent(event, { callbackId: id, args: args, mem: true });\r\n    }\r\n  }\r\n  \r\n  function getCacheFunction(id) {\r\n    return cache[id];\r\n  }\r\n  \r\n  var cache = [];\r\n  \r\n  return {\r\n    parseObject: parseObject,\r\n    restoreObject: restoreObject,\r\n    getCacheFunction: getCacheFunction\r\n  };\r\n});\n//# sourceURL=/UserProxy/memFunction.js");

eval("define(\'UserProxy/Connection\',[\"./CustomEvent\", \"./Message\", \"utils\", \"./support\", \"./memFunction\"], function(customEvent, message, utils, support, mem){\r\n  function listenerProxy(functions, token, type, detail) {\r\n    setTimeout(utils.bind(null, listener, functions, token, type, detail), 4);\r\n  }\r\n  \r\n  function listener(functions, token, type, detail) {\r\n    var keys = utils.getKeys(functions);\r\n    var index = utils.indexOfArray(detail.method, keys);\r\n    if (index > -1) {\r\n      var result = functions[keys[index]].apply(null, mem.restoreObject(detail.args, token, type));\r\n      if (typeof detail.id === \"number\") {\r\n        var memResult = mem.parseObject(result, token, type);\r\n        var detail = { callbackId: detail.id, args: [ memResult ] };\r\n        if (support.CustomEvent) {\r\n          customEvent.fireEvent(token + \"-page\", detail);\r\n        } else {\r\n          message.addEventListener(token + \"-page\", detail);\r\n        }\r\n      }\r\n    } else {\r\n      throw \"Method \" + detail.method + \" has not been set!\";\r\n    }\r\n  }\r\n  \r\n  function Connection(pageProxy) {\r\n    this.token = utils.generateToken();\r\n    this.functions = {};\r\n    this.namespace = \"UserProxy\";\r\n    this.pageProxy = pageProxy;\r\n  }\r\n  \r\n  Connection.prototype.setFunctions = function setFunctions(functions) {\r\n    this.functions = functions;\r\n  }\r\n  \r\n  Connection.prototype.setNamespace = function setFunctions(namespace) {\r\n    this.namespace = namespace;\r\n  }\r\n  \r\n  Connection.prototype.inject = function inject(code) {\r\n    var parent = (document.body || document.head || document.documentElement);\r\n    if (!parent) throw \"Parent was not found!\";\r\n    \r\n    var script = document.createElement(\"script\")\r\n    script.setAttribute(\"type\", \"text/javascript\");\r\n\r\n    this.connect();\r\n    \r\n    var args = [ false, this.token, utils.getKeys(this.functions) ];\r\n    args = args.concat(Array.prototype.slice.call(arguments, 1));\r\n    \r\n    var content = \"(\" + code + \")(\" + utils.buildArgumentList.apply(null, args) + \");\";\r\n    \r\n    script.appendChild(document.createTextNode(content));\r\n    \r\n    parent.appendChild(script);\r\n    parent.removeChild(script);\r\n  }\r\n  \r\n  Connection.prototype.connect = function connect() {\r\n    if (this.establishedConnectionListener) this.disconnect();\r\n    \r\n    this.establishedConnectionListener = utils.bind(null, listenerProxy, this.functions, this.token, \"content\");\r\n    if (support.CustomEvent) {\r\n      customEvent.addEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    } else {\r\n      message.addEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    }\r\n  }\r\n  \r\n  Connection.prototype.disconnect = function connect() {\r\n    if (!this.establishedConnectionListener) return;\r\n    if (support.CustomEvent) {\r\n      customEvent.removeEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    } else {\r\n      message.removeEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    }\r\n    this.establishedConnectionListener = null;\r\n  }\r\n  \r\n  return Connection;\r\n});\n//# sourceURL=/UserProxy/Connection.js");

eval("define(\'extensions-connection/userscript\',[], function(){\r\n  function empty() { }\r\n  return {\r\n    setPageConnection: empty\r\n  };\r\n});\n//# sourceURL=/extensions-connection/userscript.js");

eval("define(\'xhr/browser\',[], function(){\r\n  function xhr(details) {\r\n    var xmlhttp;\r\n    if (typeof XMLHttpRequest != \"undefined\") {\r\n      xmlhttp = new XMLHttpRequest();\r\n    } else {\r\n      details[\"onerror\"](responseState);\r\n    }\r\n    xmlhttp.onreadystatechange = function(){\r\n      var responseState = {\r\n        responseXML: \'\',\r\n        responseText: (xmlhttp.readyState == 4 ? xmlhttp.responseText : \'\'),\r\n        readyState: xmlhttp.readyState,\r\n        responseHeaders: (xmlhttp.readyState == 4 ? xmlhttp.getAllResponseHeaders() : \'\'),\r\n        status: (xmlhttp.readyState == 4 ? xmlhttp.status : 0),\r\n        statusText: (xmlhttp.readyState == 4 ? xmlhttp.statusText : \'\'),\r\n        finalUrl: (xmlhttp.readyState == 4 ? xmlhttp.finalUrl : \'\')\r\n      };\r\n      if (details[\"onreadystatechange\"]) {\r\n        details[\"onreadystatechange\"](responseState);\r\n      }\r\n      if (xmlhttp.readyState == 4) {\r\n        if (details[\"onload\"] && xmlhttp.status >= 200 && xmlhttp.status < 300) {\r\n          details[\"onload\"](responseState);\r\n        }\r\n        if (details[\"onerror\"] && (xmlhttp.status < 200 || xmlhttp.status >= 300)) {\r\n          details[\"onerror\"](responseState);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      xmlhttp.open(details.method, details.url);\r\n    } catch(e) {\r\n      details[\"onerror\"]();\r\n    }\r\n    if (details.headers) {\r\n      for (var prop in details.headers) {\r\n        xmlhttp.setRequestHeader(prop, details.headers[prop]);\r\n      }\r\n    }\r\n    xmlhttp.send((typeof(details.data) !== \'undefined\') ? details.data : null);\r\n  }\r\n  \r\n  return xhr;\r\n});\n//# sourceURL=/xhr/browser.js");

eval("define(\'xhr/userscript\',[\"support\", \"xhr/browser\"], function(support, browser){\r\n  if (support.Greasemonkey) {\r\n    return GM_xmlhttpRequest;\r\n  } else {\r\n    return browser;\r\n  }\r\n});\n//# sourceURL=/xhr/userscript.js");

eval("define(\'xhr\',[\"xhr/userscript\"], function(xhr){\r\n  return xhr;\r\n});\n//# sourceURL=/xhr.js");

eval("define(\'main-wrapper\',[\"storage\", \"UserProxy/Connection\", \"extensions-connection/userscript\", \"xhr\", \"console\"], function(storage, Connection, extension, xhr, con){\r\n  var functionMap = {\r\n    \"setItem\": storage.setItem,\r\n    \"getItem\": storage.getItem,\r\n    \"removeItem\": storage.removeItem,\r\n    \"xhr\": xhr,\r\n    \"log\": con.log\r\n  };\r\n  \r\n  var connection = null;\r\n  \r\n  storage.getItem(\"YouTubeCenterSettings\", function(settings){\r\n    if (typeof settings !== \"object\") settings = JSON.parse(settings || \"{}\");\r\n    \r\n    connection = new Connection();\r\n    connection.setFunctions(functionMap);\r\n    \r\n    extension.setPageConnection(connection);\r\n    \r\n    connection.inject(mainPage, settings, con.sessionToken);\r\n  }, true);\r\n});\n//# sourceURL=/main-wrapper.js");


require(["main-wrapper"]);
}());
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJtYWluLXdyYXBwZXItYWxsLmpzIiwKICAic291cmNlcyI6IFsKICAgICIuLi92ZW5kb3IvYWxtb25kLmpzIiwKICAgICJ1bnNhZmVXaW5kb3cuanMiLAogICAgInN1cHBvcnQuanMiLAogICAgInV0aWxzLmpzIiwKICAgICJzdG9yYWdlL2xvY2FsU3RvcmFnZS5qcyIsCiAgICAic3RvcmFnZS9jb29raWVzLmpzIiwKICAgICJjb25zb2xlLmpzIiwKICAgICJzdG9yYWdlL2Jyb3dzZXIuanMiLAogICAgInN0b3JhZ2UvdXNlcnNjcmlwdC5qcyIsCiAgICAic3RvcmFnZS5qcyIsCiAgICAiVXNlclByb3h5L0N1c3RvbUV2ZW50LmpzIiwKICAgICJVc2VyUHJveHkvTWVzc2FnZS5qcyIsCiAgICAiVXNlclByb3h5L3N1cHBvcnQuanMiLAogICAgIlVzZXJQcm94eS9tZW1GdW5jdGlvbi5qcyIsCiAgICAiVXNlclByb3h5L0Nvbm5lY3Rpb24uanMiLAogICAgImV4dGVuc2lvbnMtY29ubmVjdGlvbi91c2Vyc2NyaXB0LmpzIiwKICAgICJ4aHIvYnJvd3Nlci5qcyIsCiAgICAieGhyL3VzZXJzY3JpcHQuanMiLAogICAgInhoci5qcyIsCiAgICAibWFpbi13cmFwcGVyLmpzIgogIF0sCiAgIm5hbWVzIjogW10sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxBQ0pBO0FBQ0E7QUNEQSxBREVBO0FDREE7QUFDQSxBQ0ZBO0FBQ0E7QUNEQSxBREVBO0FDREE7QUNEQSxBREVBO0FDREE7QUNEQSxBREVBO0FDREE7QUFDQSxBQ0ZBO0FBQ0E7QUFDQSxBQ0ZBO0FBQ0E7QUNEQSxBREVBO0FDREE7QUNEQSxBREVBO0FDREE7QUFDQSxBQ0ZBO0FBQ0E7QUFDQSxBQ0ZBO0FBQ0E7QUNEQSxBREVBO0FDREE7QUNEQSxBREVBO0FDREE7QUFDQSxBQ0ZBO0FBQ0E7QUFDQSxBQ0ZBO0FBQ0E7QUFDQSxBQ0ZBO0FBQ0E7QUNEQSxBREVBO0FDREE7QUNEQSxBREVBO0FDREE7QUFDQSIsCiAgInNvdXJjZXNDb250ZW50IjogWwogICAgImV2YWwoXCIvKipcXHJcXG4gKiBAbGljZW5zZSBhbG1vbmQgMC4yLjkgQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXHJcXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxcclxcbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9hbG1vbmQgZm9yIGRldGFpbHNcXHJcXG4gKi9cXHJcXG4vL0dvaW5nIHNsb3BweSB0byBhdm9pZCBcXCd1c2Ugc3RyaWN0XFwnIHN0cmluZyBjb3N0LCBidXQgc3RyaWN0IHByYWN0aWNlcyBzaG91bGRcXHJcXG4vL2JlIGZvbGxvd2VkLlxcclxcbi8qanNsaW50IHNsb3BweTogdHJ1ZSAqL1xcclxcbi8qZ2xvYmFsIHNldFRpbWVvdXQ6IGZhbHNlICovXFxyXFxuXFxyXFxudmFyIHJlcXVpcmVqcywgcmVxdWlyZSwgZGVmaW5lO1xcclxcbihmdW5jdGlvbiAodW5kZWYpIHtcXHJcXG4gICAgdmFyIG1haW4sIHJlcSwgbWFrZU1hcCwgaGFuZGxlcnMsXFxyXFxuICAgICAgICBkZWZpbmVkID0ge30sXFxyXFxuICAgICAgICB3YWl0aW5nID0ge30sXFxyXFxuICAgICAgICBjb25maWcgPSB7fSxcXHJcXG4gICAgICAgIGRlZmluaW5nID0ge30sXFxyXFxuICAgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxcclxcbiAgICAgICAgYXBzID0gW10uc2xpY2UsXFxyXFxuICAgICAgICBqc1N1ZmZpeFJlZ0V4cCA9IC9cXFxcLmpzJC87XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIGhhc1Byb3Aob2JqLCBwcm9wKSB7XFxyXFxuICAgICAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogR2l2ZW4gYSByZWxhdGl2ZSBtb2R1bGUgbmFtZSwgbGlrZSAuL3NvbWV0aGluZywgbm9ybWFsaXplIGl0IHRvXFxyXFxuICAgICAqIGEgcmVhbCBuYW1lIHRoYXQgY2FuIGJlIG1hcHBlZCB0byBhIHBhdGguXFxyXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSByZWxhdGl2ZSBuYW1lXFxyXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlTmFtZSBhIHJlYWwgbmFtZSB0aGF0IHRoZSBuYW1lIGFyZyBpcyByZWxhdGl2ZVxcclxcbiAgICAgKiB0by5cXHJcXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbm9ybWFsaXplZCBuYW1lXFxyXFxuICAgICAqL1xcclxcbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUpIHtcXHJcXG4gICAgICAgIHZhciBuYW1lUGFydHMsIG5hbWVTZWdtZW50LCBtYXBWYWx1ZSwgZm91bmRNYXAsIGxhc3RJbmRleCxcXHJcXG4gICAgICAgICAgICBmb3VuZEksIGZvdW5kU3Rhck1hcCwgc3RhckksIGksIGosIHBhcnQsXFxyXFxuICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUgJiYgYmFzZU5hbWUuc3BsaXQoXFxcIi9cXFwiKSxcXHJcXG4gICAgICAgICAgICBtYXAgPSBjb25maWcubWFwLFxcclxcbiAgICAgICAgICAgIHN0YXJNYXAgPSAobWFwICYmIG1hcFtcXCcqXFwnXSkgfHwge307XFxyXFxuXFxyXFxuICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXFxyXFxuICAgICAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gXFxcIi5cXFwiKSB7XFxyXFxuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXFxyXFxuICAgICAgICAgICAgLy9vdGhlcndpc2UsIGFzc3VtZSBpdCBpcyBhIHRvcC1sZXZlbCByZXF1aXJlIHRoYXQgd2lsbFxcclxcbiAgICAgICAgICAgIC8vYmUgcmVsYXRpdmUgdG8gYmFzZVVybCBpbiB0aGUgZW5kLlxcclxcbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xcclxcbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgYmFzZU5hbWUgdG8gYXJyYXksIGFuZCBsb3Agb2ZmIHRoZSBsYXN0IHBhcnQsXFxyXFxuICAgICAgICAgICAgICAgIC8vc28gdGhhdCAuIG1hdGNoZXMgdGhhdCBcXFwiZGlyZWN0b3J5XFxcIiBhbmQgbm90IG5hbWUgb2YgdGhlIGJhc2VOYW1lXFwnc1xcclxcbiAgICAgICAgICAgICAgICAvL21vZHVsZS4gRm9yIGluc3RhbmNlLCBiYXNlTmFtZSBvZiBcXFwib25lL3R3by90aHJlZVxcXCIsIG1hcHMgdG9cXHJcXG4gICAgICAgICAgICAgICAgLy9cXFwib25lL3R3by90aHJlZS5qc1xcXCIsIGJ1dCB3ZSB3YW50IHRoZSBkaXJlY3RvcnksIFxcXCJvbmUvdHdvXFxcIiBmb3JcXHJcXG4gICAgICAgICAgICAgICAgLy90aGlzIG5vcm1hbGl6YXRpb24uXFxyXFxuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KFxcJy9cXCcpO1xcclxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIE5vZGUgLmpzIGFsbG93YW5jZTpcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5ub2RlSWRDb21wYXQgJiYganNTdWZmaXhSZWdFeHAudGVzdChuYW1lW2xhc3RJbmRleF0pKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBuYW1lW2xhc3RJbmRleF0gPSBuYW1lW2xhc3RJbmRleF0ucmVwbGFjZShqc1N1ZmZpeFJlZ0V4cCwgXFwnXFwnKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmNvbmNhdChuYW1lKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy9zdGFydCB0cmltRG90c1xcclxcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkgKz0gMSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IG5hbWVbaV07XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gXFxcIi5cXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSwgMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcXFwiLi5cXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgKG5hbWVbMl0gPT09IFxcJy4uXFwnIHx8IG5hbWVbMF0gPT09IFxcJy4uXFwnKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0VuZCBvZiB0aGUgbGluZS4gS2VlcCBhdCBsZWFzdCBvbmUgbm9uLWRvdFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhdGggc2VnbWVudCBhdCB0aGUgZnJvbnQgc28gaXQgY2FuIGJlIG1hcHBlZFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3RseSB0byBkaXNrLiBPdGhlcndpc2UsIHRoZXJlIGlzIGxpa2VseVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vIHBhdGggbWFwcGluZyBmb3IgYSBwYXRoIHN0YXJ0aW5nIHdpdGggXFwnLi5cXCcuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpIC0gMSwgMik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgLy9lbmQgdHJpbURvdHNcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuam9pbihcXFwiL1xcXCIpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZS5pbmRleE9mKFxcJy4vXFwnKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAvLyBObyBiYXNlTmFtZSwgc28gdGhpcyBpcyBJRCBpcyByZXNvbHZlZCByZWxhdGl2ZVxcclxcbiAgICAgICAgICAgICAgICAvLyB0byBiYXNlVXJsLCBwdWxsIG9mZiB0aGUgbGVhZGluZyBkb3QuXFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygyKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL0FwcGx5IG1hcCBjb25maWcgaWYgYXZhaWxhYmxlLlxcclxcbiAgICAgICAgaWYgKChiYXNlUGFydHMgfHwgc3Rhck1hcCkgJiYgbWFwKSB7XFxyXFxuICAgICAgICAgICAgbmFtZVBhcnRzID0gbmFtZS5zcGxpdChcXCcvXFwnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSBuYW1lUGFydHMubGVuZ3RoOyBpID4gMDsgaSAtPSAxKSB7XFxyXFxuICAgICAgICAgICAgICAgIG5hbWVTZWdtZW50ID0gbmFtZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXFxcIi9cXFwiKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJ0cykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy9GaW5kIHRoZSBsb25nZXN0IGJhc2VOYW1lIHNlZ21lbnQgbWF0Y2ggaW4gdGhlIGNvbmZpZy5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vU28sIGRvIGpvaW5zIG9uIHRoZSBiaWdnZXN0IHRvIHNtYWxsZXN0IGxlbmd0aHMgb2YgYmFzZVBhcnRzLlxcclxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYmFzZVBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwW2Jhc2VQYXJ0cy5zbGljZSgwLCBqKS5qb2luKFxcJy9cXCcpXTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Jhc2VOYW1lIHNlZ21lbnQgaGFzICBjb25maWcsIGZpbmQgaWYgaXQgaGFzIG9uZSBmb3JcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbmFtZS5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBtYXBWYWx1ZVtuYW1lU2VnbWVudF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXRjaCwgdXBkYXRlIG5hbWUgdG8gdGhlIG5ldyB2YWx1ZS5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWFwID0gbWFwVmFsdWU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEkgPSBpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGZvciBhIHN0YXIgbWFwIG1hdGNoLCBidXQganVzdCBob2xkIG9uIHRvIGl0LFxcclxcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGEgc2hvcnRlciBzZWdtZW50IG1hdGNoIGxhdGVyIGluIGEgbWF0Y2hpbmdcXHJcXG4gICAgICAgICAgICAgICAgLy9jb25maWcsIHRoZW4gZmF2b3Igb3ZlciB0aGlzIHN0YXIgbWFwLlxcclxcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU3Rhck1hcCAmJiBzdGFyTWFwICYmIHN0YXJNYXBbbmFtZVNlZ21lbnRdKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJNYXAgPSBzdGFyTWFwW25hbWVTZWdtZW50XTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJJID0gaTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoIWZvdW5kTWFwICYmIGZvdW5kU3Rhck1hcCkge1xcclxcbiAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IGZvdW5kU3Rhck1hcDtcXHJcXG4gICAgICAgICAgICAgICAgZm91bmRJID0gc3Rhckk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lUGFydHMuc3BsaWNlKDAsIGZvdW5kSSwgZm91bmRNYXApO1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVBhcnRzLmpvaW4oXFwnL1xcJyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgcmV0dXJuIG5hbWU7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbWFrZVJlcXVpcmUocmVsTmFtZSwgZm9yY2VTeW5jKSB7XFxyXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIC8vQSB2ZXJzaW9uIG9mIGEgcmVxdWlyZSBmdW5jdGlvbiB0aGF0IHBhc3NlcyBhIG1vZHVsZU5hbWVcXHJcXG4gICAgICAgICAgICAvL3ZhbHVlIGZvciBpdGVtcyB0aGF0IG1heSBuZWVkIHRvXFxyXFxuICAgICAgICAgICAgLy9sb29rIHVwIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSBtb2R1bGVOYW1lXFxyXFxuICAgICAgICAgICAgcmV0dXJuIHJlcS5hcHBseSh1bmRlZiwgYXBzLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoW3JlbE5hbWUsIGZvcmNlU3luY10pKTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSB7XFxyXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBtYWtlTG9hZChkZXBOYW1lKSB7XFxyXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XFxyXFxuICAgICAgICAgICAgZGVmaW5lZFtkZXBOYW1lXSA9IHZhbHVlO1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBjYWxsRGVwKG5hbWUpIHtcXHJcXG4gICAgICAgIGlmIChoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB3YWl0aW5nW25hbWVdO1xcclxcbiAgICAgICAgICAgIGRlbGV0ZSB3YWl0aW5nW25hbWVdO1xcclxcbiAgICAgICAgICAgIGRlZmluaW5nW25hbWVdID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICBtYWluLmFwcGx5KHVuZGVmLCBhcmdzKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcChkZWZpbmluZywgbmFtZSkpIHtcXHJcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFwnTm8gXFwnICsgbmFtZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gZGVmaW5lZFtuYW1lXTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvL1R1cm5zIGEgcGx1Z2luIXJlc291cmNlIHRvIFtwbHVnaW4sIHJlc291cmNlXVxcclxcbiAgICAvL3dpdGggdGhlIHBsdWdpbiBiZWluZyB1bmRlZmluZWQgaWYgdGhlIG5hbWVcXHJcXG4gICAgLy9kaWQgbm90IGhhdmUgYSBwbHVnaW4gcHJlZml4LlxcclxcbiAgICBmdW5jdGlvbiBzcGxpdFByZWZpeChuYW1lKSB7XFxyXFxuICAgICAgICB2YXIgcHJlZml4LFxcclxcbiAgICAgICAgICAgIGluZGV4ID0gbmFtZSA/IG5hbWUuaW5kZXhPZihcXCchXFwnKSA6IC0xO1xcclxcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcXHJcXG4gICAgICAgICAgICBwcmVmaXggPSBuYW1lLnN1YnN0cmluZygwLCBpbmRleCk7XFxyXFxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKGluZGV4ICsgMSwgbmFtZS5sZW5ndGgpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIG5hbWVdO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBNYWtlcyBhIG5hbWUgbWFwLCBub3JtYWxpemluZyB0aGUgbmFtZSwgYW5kIHVzaW5nIGEgcGx1Z2luXFxyXFxuICAgICAqIGZvciBub3JtYWxpemF0aW9uIGlmIG5lY2Vzc2FyeS4gR3JhYnMgYSByZWYgdG8gcGx1Z2luXFxyXFxuICAgICAqIHRvbywgYXMgYW4gb3B0aW1pemF0aW9uLlxcclxcbiAgICAgKi9cXHJcXG4gICAgbWFrZU1hcCA9IGZ1bmN0aW9uIChuYW1lLCByZWxOYW1lKSB7XFxyXFxuICAgICAgICB2YXIgcGx1Z2luLFxcclxcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSksXFxyXFxuICAgICAgICAgICAgcHJlZml4ID0gcGFydHNbMF07XFxyXFxuXFxyXFxuICAgICAgICBuYW1lID0gcGFydHNbMV07XFxyXFxuXFxyXFxuICAgICAgICBpZiAocHJlZml4KSB7XFxyXFxuICAgICAgICAgICAgcHJlZml4ID0gbm9ybWFsaXplKHByZWZpeCwgcmVsTmFtZSk7XFxyXFxuICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy9Ob3JtYWxpemUgYWNjb3JkaW5nXFxyXFxuICAgICAgICBpZiAocHJlZml4KSB7XFxyXFxuICAgICAgICAgICAgaWYgKHBsdWdpbiAmJiBwbHVnaW4ubm9ybWFsaXplKSB7XFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBwbHVnaW4ubm9ybWFsaXplKG5hbWUsIG1ha2VOb3JtYWxpemUocmVsTmFtZSkpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSk7XFxyXFxuICAgICAgICAgICAgcHJlZml4ID0gcGFydHNbMF07XFxyXFxuICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xcclxcbiAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vVXNpbmcgcmlkaWN1bG91cyBwcm9wZXJ0eSBuYW1lcyBmb3Igc3BhY2UgcmVhc29uc1xcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICBmOiBwcmVmaXggPyBwcmVmaXggKyBcXCchXFwnICsgbmFtZSA6IG5hbWUsIC8vZnVsbE5hbWVcXHJcXG4gICAgICAgICAgICBuOiBuYW1lLFxcclxcbiAgICAgICAgICAgIHByOiBwcmVmaXgsXFxyXFxuICAgICAgICAgICAgcDogcGx1Z2luXFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBtYWtlQ29uZmlnKG5hbWUpIHtcXHJcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIChjb25maWcgJiYgY29uZmlnLmNvbmZpZyAmJiBjb25maWcuY29uZmlnW25hbWVdKSB8fCB7fTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgaGFuZGxlcnMgPSB7XFxyXFxuICAgICAgICByZXF1aXJlOiBmdW5jdGlvbiAobmFtZSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShuYW1lKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBleHBvcnRzOiBmdW5jdGlvbiAobmFtZSkge1xcclxcbiAgICAgICAgICAgIHZhciBlID0gZGVmaW5lZFtuYW1lXTtcXHJcXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUgIT09IFxcJ3VuZGVmaW5lZFxcJykge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRlZmluZWRbbmFtZV0gPSB7fSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIG1vZHVsZTogZnVuY3Rpb24gKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBpZDogbmFtZSxcXHJcXG4gICAgICAgICAgICAgICAgdXJpOiBcXCdcXCcsXFxyXFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGRlZmluZWRbbmFtZV0sXFxyXFxuICAgICAgICAgICAgICAgIGNvbmZpZzogbWFrZUNvbmZpZyhuYW1lKVxcclxcbiAgICAgICAgICAgIH07XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIG1haW4gPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpIHtcXHJcXG4gICAgICAgIHZhciBjanNNb2R1bGUsIGRlcE5hbWUsIHJldCwgbWFwLCBpLFxcclxcbiAgICAgICAgICAgIGFyZ3MgPSBbXSxcXHJcXG4gICAgICAgICAgICBjYWxsYmFja1R5cGUgPSB0eXBlb2YgY2FsbGJhY2ssXFxyXFxuICAgICAgICAgICAgdXNpbmdFeHBvcnRzO1xcclxcblxcclxcbiAgICAgICAgLy9Vc2UgbmFtZSBpZiBubyByZWxOYW1lXFxyXFxuICAgICAgICByZWxOYW1lID0gcmVsTmFtZSB8fCBuYW1lO1xcclxcblxcclxcbiAgICAgICAgLy9DYWxsIHRoZSBjYWxsYmFjayB0byBkZWZpbmUgdGhlIG1vZHVsZSwgaWYgbmVjZXNzYXJ5LlxcclxcbiAgICAgICAgaWYgKGNhbGxiYWNrVHlwZSA9PT0gXFwndW5kZWZpbmVkXFwnIHx8IGNhbGxiYWNrVHlwZSA9PT0gXFwnZnVuY3Rpb25cXCcpIHtcXHJcXG4gICAgICAgICAgICAvL1B1bGwgb3V0IHRoZSBkZWZpbmVkIGRlcGVuZGVuY2llcyBhbmQgcGFzcyB0aGUgb3JkZXJlZFxcclxcbiAgICAgICAgICAgIC8vdmFsdWVzIHRvIHRoZSBjYWxsYmFjay5cXHJcXG4gICAgICAgICAgICAvL0RlZmF1bHQgdG8gW3JlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZV0gaWYgbm8gZGVwc1xcclxcbiAgICAgICAgICAgIGRlcHMgPSAhZGVwcy5sZW5ndGggJiYgY2FsbGJhY2subGVuZ3RoID8gW1xcJ3JlcXVpcmVcXCcsIFxcJ2V4cG9ydHNcXCcsIFxcJ21vZHVsZVxcJ10gOiBkZXBzO1xcclxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSArPSAxKSB7XFxyXFxuICAgICAgICAgICAgICAgIG1hcCA9IG1ha2VNYXAoZGVwc1tpXSwgcmVsTmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBtYXAuZjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy9GYXN0IHBhdGggQ29tbW9uSlMgc3RhbmRhcmQgZGVwZW5kZW5jaWVzLlxcclxcbiAgICAgICAgICAgICAgICBpZiAoZGVwTmFtZSA9PT0gXFxcInJlcXVpcmVcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMucmVxdWlyZShuYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcXFwiZXhwb3J0c1xcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXFxyXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMuZXhwb3J0cyhuYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHVzaW5nRXhwb3J0cyA9IHRydWU7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXFxcIm1vZHVsZVxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXFxyXFxuICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUgPSBhcmdzW2ldID0gaGFuZGxlcnMubW9kdWxlKG5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1Byb3AoZGVmaW5lZCwgZGVwTmFtZSkgfHxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKHdhaXRpbmcsIGRlcE5hbWUpIHx8XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcChkZWZpbmluZywgZGVwTmFtZSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjYWxsRGVwKGRlcE5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcC5wKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXAucC5sb2FkKG1hcC5uLCBtYWtlUmVxdWlyZShyZWxOYW1lLCB0cnVlKSwgbWFrZUxvYWQoZGVwTmFtZSksIHt9KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBkZWZpbmVkW2RlcE5hbWVdO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBcXCcgbWlzc2luZyBcXCcgKyBkZXBOYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICByZXQgPSBjYWxsYmFjayA/IGNhbGxiYWNrLmFwcGx5KGRlZmluZWRbbmFtZV0sIGFyZ3MpIDogdW5kZWZpbmVkO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vSWYgc2V0dGluZyBleHBvcnRzIHZpYSBcXFwibW9kdWxlXFxcIiBpcyBpbiBwbGF5LFxcclxcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIHRoYXQgb3ZlciByZXR1cm4gdmFsdWUgYW5kIGV4cG9ydHMuIEFmdGVyIHRoYXQsXFxyXFxuICAgICAgICAgICAgICAgIC8vZmF2b3IgYSBub24tdW5kZWZpbmVkIHJldHVybiB2YWx1ZSBvdmVyIGV4cG9ydHMgdXNlLlxcclxcbiAgICAgICAgICAgICAgICBpZiAoY2pzTW9kdWxlICYmIGNqc01vZHVsZS5leHBvcnRzICE9PSB1bmRlZiAmJlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZS5leHBvcnRzICE9PSBkZWZpbmVkW25hbWVdKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2pzTW9kdWxlLmV4cG9ydHM7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZiB8fCAhdXNpbmdFeHBvcnRzKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvL1VzZSB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uLlxcclxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IHJldDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xcclxcbiAgICAgICAgICAgIC8vTWF5IGp1c3QgYmUgYW4gb2JqZWN0IGRlZmluaXRpb24gZm9yIHRoZSBtb2R1bGUuIE9ubHlcXHJcXG4gICAgICAgICAgICAvL3dvcnJ5IGFib3V0IGRlZmluaW5nIGlmIGhhdmUgYSBtb2R1bGUgbmFtZS5cXHJcXG4gICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2FsbGJhY2s7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIHJlcXVpcmVqcyA9IHJlcXVpcmUgPSByZXEgPSBmdW5jdGlvbiAoZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUsIGZvcmNlU3luYywgYWx0KSB7XFxyXFxuICAgICAgICBpZiAodHlwZW9mIGRlcHMgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzW2RlcHNdKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgaW4gdGhpcyBjYXNlIGlzIHJlYWxseSByZWxOYW1lXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyc1tkZXBzXShjYWxsYmFjayk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vSnVzdCByZXR1cm4gdGhlIG1vZHVsZSB3YW50ZWQuIEluIHRoaXMgc2NlbmFyaW8sIHRoZVxcclxcbiAgICAgICAgICAgIC8vZGVwcyBhcmcgaXMgdGhlIG1vZHVsZSBuYW1lLCBhbmQgc2Vjb25kIGFyZyAoaWYgcGFzc2VkKVxcclxcbiAgICAgICAgICAgIC8vaXMganVzdCB0aGUgcmVsTmFtZS5cXHJcXG4gICAgICAgICAgICAvL05vcm1hbGl6ZSBtb2R1bGUgbmFtZSwgaWYgaXQgY29udGFpbnMgLiBvciAuLlxcclxcbiAgICAgICAgICAgIHJldHVybiBjYWxsRGVwKG1ha2VNYXAoZGVwcywgY2FsbGJhY2spLmYpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICghZGVwcy5zcGxpY2UpIHtcXHJcXG4gICAgICAgICAgICAvL2RlcHMgaXMgYSBjb25maWcgb2JqZWN0LCBub3QgYW4gYXJyYXkuXFxyXFxuICAgICAgICAgICAgY29uZmlnID0gZGVwcztcXHJcXG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlcHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmVxKGNvbmZpZy5kZXBzLCBjb25maWcuY2FsbGJhY2spO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLnNwbGljZSkge1xcclxcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGlzIGFuIGFycmF5LCB3aGljaCBtZWFucyBpdCBpcyBhIGRlcGVuZGVuY3kgbGlzdC5cXHJcXG4gICAgICAgICAgICAgICAgLy9BZGp1c3QgYXJncyBpZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzXFxyXFxuICAgICAgICAgICAgICAgIGRlcHMgPSBjYWxsYmFjaztcXHJcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByZWxOYW1lO1xcclxcbiAgICAgICAgICAgICAgICByZWxOYW1lID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBkZXBzID0gdW5kZWY7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy9TdXBwb3J0IHJlcXVpcmUoW1xcJ2FcXCddKVxcclxcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcXHJcXG5cXHJcXG4gICAgICAgIC8vSWYgcmVsTmFtZSBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBhbiBlcnJiYWNrIGhhbmRsZXIsXFxyXFxuICAgICAgICAvL3NvIHJlbW92ZSBpdC5cXHJcXG4gICAgICAgIGlmICh0eXBlb2YgcmVsTmFtZSA9PT0gXFwnZnVuY3Rpb25cXCcpIHtcXHJcXG4gICAgICAgICAgICByZWxOYW1lID0gZm9yY2VTeW5jO1xcclxcbiAgICAgICAgICAgIGZvcmNlU3luYyA9IGFsdDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vU2ltdWxhdGUgYXN5bmMgY2FsbGJhY2s7XFxyXFxuICAgICAgICBpZiAoZm9yY2VTeW5jKSB7XFxyXFxuICAgICAgICAgICAgbWFpbih1bmRlZiwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAvL1VzaW5nIGEgbm9uLXplcm8gdmFsdWUgYmVjYXVzZSBvZiBjb25jZXJuIGZvciB3aGF0IG9sZCBicm93c2Vyc1xcclxcbiAgICAgICAgICAgIC8vZG8sIGFuZCBsYXRlc3QgYnJvd3NlcnMgXFxcInVwZ3JhZGVcXFwiIHRvIDQgaWYgbG93ZXIgdmFsdWUgaXMgdXNlZDpcXHJcXG4gICAgICAgICAgICAvL2h0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RpbWVycy5odG1sI2RvbS13aW5kb3d0aW1lcnMtc2V0dGltZW91dDpcXHJcXG4gICAgICAgICAgICAvL0lmIHdhbnQgYSB2YWx1ZSBpbW1lZGlhdGVseSwgdXNlIHJlcXVpcmUoXFwnaWRcXCcpIGluc3RlYWQgLS0gc29tZXRoaW5nXFxyXFxuICAgICAgICAgICAgLy90aGF0IHdvcmtzIGluIGFsbW9uZCBvbiB0aGUgZ2xvYmFsIGxldmVsLCBidXQgbm90IGd1YXJhbnRlZWQgYW5kXFxyXFxuICAgICAgICAgICAgLy91bmxpa2VseSB0byB3b3JrIGluIG90aGVyIEFNRCBpbXBsZW1lbnRhdGlvbnMuXFxyXFxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcXHJcXG4gICAgICAgICAgICB9LCA0KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHJldHVybiByZXE7XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBKdXN0IGRyb3BzIHRoZSBjb25maWcgb24gdGhlIGZsb29yLCBidXQgcmV0dXJucyByZXEgaW4gY2FzZVxcclxcbiAgICAgKiB0aGUgY29uZmlnIHJldHVybiB2YWx1ZSBpcyB1c2VkLlxcclxcbiAgICAgKi9cXHJcXG4gICAgcmVxLmNvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcXHJcXG4gICAgICAgIHJldHVybiByZXEoY2ZnKTtcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEV4cG9zZSBtb2R1bGUgcmVnaXN0cnkgZm9yIGRlYnVnZ2luZyBhbmQgdG9vbGluZ1xcclxcbiAgICAgKi9cXHJcXG4gICAgcmVxdWlyZWpzLl9kZWZpbmVkID0gZGVmaW5lZDtcXHJcXG5cXHJcXG4gICAgZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XFxyXFxuXFxyXFxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcXHJcXG4gICAgICAgIGlmICghZGVwcy5zcGxpY2UpIHtcXHJcXG4gICAgICAgICAgICAvL2RlcHMgaXMgbm90IGFuIGFycmF5LCBzbyBwcm9iYWJseSBtZWFuc1xcclxcbiAgICAgICAgICAgIC8vYW4gb2JqZWN0IGxpdGVyYWwgb3IgZmFjdG9yeSBmdW5jdGlvbiBmb3JcXHJcXG4gICAgICAgICAgICAvL3RoZSB2YWx1ZS4gQWRqdXN0IGFyZ3MuXFxyXFxuICAgICAgICAgICAgY2FsbGJhY2sgPSBkZXBzO1xcclxcbiAgICAgICAgICAgIGRlcHMgPSBbXTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xcclxcbiAgICAgICAgICAgIHdhaXRpbmdbbmFtZV0gPSBbbmFtZSwgZGVwcywgY2FsbGJhY2tdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICBkZWZpbmUuYW1kID0ge1xcclxcbiAgICAgICAgalF1ZXJ5OiB0cnVlXFxyXFxuICAgIH07XFxyXFxufSgpKTtcXHJcXG5cXG4vLyMgc291cmNlVVJMPS8uLi92ZW5kb3IvYWxtb25kLmpzXCIpO1xuXG5kZWZpbmUoXCIuLi92ZW5kb3IvYWxtb25kXCIsIGZ1bmN0aW9uKCl7fSk7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCd1bnNhZmVXaW5kb3dcXCcsW10sIGZ1bmN0aW9uKCl7XFxyXFxuICByZXR1cm4gd2luZG93O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3Vuc2FmZVdpbmRvdy5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3N1cHBvcnRcXCcsW1xcXCJ1bnNhZmVXaW5kb3dcXFwiXSwgZnVuY3Rpb24odXcpe1xcclxcbiAgZnVuY3Rpb24gbG9jYWxTdG9yYWdlVGVzdCgpIHtcXHJcXG4gICAgdmFyIG1vZCA9IFxcXCJzdXBwb3J0LnRlc3RcXFwiO1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcXHJcXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xcclxcbiAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBpc1dlYmtpdFVSTCA9IHR5cGVvZiB1dy53ZWJraXRVUkwgPT09IFxcXCJvYmplY3RcXFwiO1xcclxcbiAgdmFyIGlzVVJMID0gdHlwZW9mIHV3LlVSTCA9PT0gXFxcIm9iamVjdFxcXCI7XFxyXFxuICB2YXIgaXNDcmVhdGVPYmplY3RVUkwgPSBmYWxzZTtcXHJcXG4gIHZhciBpc1Jldm9rZU9iamVjdFVSTCA9IGZhbHNlO1xcclxcbiAgXFxyXFxuICB2YXIgbWF4dGhvblJ1bnRpbWUgPSB3aW5kb3cgJiYgd2luZG93LmV4dGVybmFsICYmIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUgJiYgdHlwZW9mIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUgPT09IFxcXCJmdW5jdGlvblxcXCI7XFxyXFxuICBcXHJcXG4gIGlmIChpc1dlYmtpdFVSTCkge1xcclxcbiAgICBpc0NyZWF0ZU9iamVjdFVSTCA9IHR5cGVvZiB1dy53ZWJraXRVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgICBpc1Jldm9rZU9iamVjdFVSTCA9IHR5cGVvZiB1dy53ZWJraXRVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgfSBlbHNlIGlmIChpc1VSTCkge1xcclxcbiAgICBpc0NyZWF0ZU9iamVjdFVSTCA9IHR5cGVvZiB1dy5VUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgICBpc1Jldm9rZU9iamVjdFVSTCA9IHR5cGVvZiB1dy5VUkwucmV2b2tlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICByZXR1cm4ge1xcclxcbiAgICBsb2NhbFN0b3JhZ2U6IGxvY2FsU3RvcmFnZVRlc3QoKSxcXHJcXG4gICAgR3JlYXNlbW9ua2V5OiAodHlwZW9mIEdNX3NldFZhbHVlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiAodHlwZW9mIEdNX3NldFZhbHVlLnRvU3RyaW5nID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fCBHTV9zZXRWYWx1ZS50b1N0cmluZygpLmluZGV4T2YoXFxcIm5vdCBzdXBwb3J0ZWRcXFwiKSA9PT0gLTEpKSxcXHJcXG4gICAgY3JlYXRlT2JqZWN0VVJMOiBpc0NyZWF0ZU9iamVjdFVSTCxcXHJcXG4gICAgcmV2b2tlT2JqZWN0VVJMOiBpc1Jldm9rZU9iamVjdFVSTCxcXHJcXG4gICAgd2Via2l0VVJMOiBpc1dlYmtpdFVSTCxcXHJcXG4gICAgVVJMOiBpc1VSTCxcXHJcXG4gICAgbWF4dGhvblJ1bnRpbWU6IG1heHRob25SdW50aW1lLFxcclxcbiAgICBtYXh0aG9uUnVudGltZVN0b3JhZ2U6IG1heHRob25SdW50aW1lICYmIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUoKSAmJiB3aW5kb3cuZXh0ZXJuYWwubXhHZXRSdW50aW1lKCkuc3RvcmFnZSxcXHJcXG4gICAgZmlyZWZveFBvcnQ6IHRoaXMucG9ydCAmJiB0eXBlb2YgdGhpcy5wb3J0LnJlcXVlc3QgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdGhpcy5wb3J0LnN0b3JhZ2UgJiYgdHlwZW9mIHRoaXMucG9ydC5vbiA9PT0gXFxcImZ1bmN0aW9uXFxcIlxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9zdXBwb3J0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwndXRpbHNcXCcsW1xcXCJzdXBwb3J0XFxcIiwgXFxcInVuc2FmZVdpbmRvd1xcXCJdLCBmdW5jdGlvbihzdXBwb3J0LCB1dyl7XFxyXFxuICBmdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcXHJcXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xcclxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICBpZiAoY2FsbGJhY2soaSwgb2JqW2ldKSA9PT0gdHJ1ZSkgYnJlYWs7XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXHJcXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgICBpZiAoY2FsbGJhY2soa2V5LCBvYmpba2V5XSkgPT09IHRydWUpIGJyZWFrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xcclxcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09IFxcXCJbb2JqZWN0IEFycmF5XVxcXCI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFzeW5jQ2FsbChzY29wZSwgY2FsbGJhY2spIHtcXHJcXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZC5hcHBseShudWxsLCBbc2NvcGUsIGNhbGxiYWNrXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSkpLCAwKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYmluZChzY29wZSwgZnVuYykge1xcclxcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbigpe1xcclxcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNjb3BlLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSlcXHJcXG4gICAgfTtcXHJcXG4gIH1cXHJcXG4gIGZ1bmN0aW9uIHRyaW1MZWZ0KG9iail7XFxyXFxuICAgIHJldHVybiBvYmoucmVwbGFjZSgvXlxcXFxzKy8sIFxcXCJcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIGZ1bmN0aW9uIHRyaW1SaWdodChvYmope1xcclxcbiAgICByZXR1cm4gb2JqLnJlcGxhY2UoL1xcXFxzKyQvLCBcXFwiXFxcIik7XFxyXFxuICB9XFxyXFxuICBmdW5jdGlvbiBtYXAob2JqLCBjYWxsYmFjaywgdGhpc0FyZykge1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG9iai5sZW5ndGgsIGEgPSBbXTsgaSA8IG47IGkrKykge1xcclxcbiAgICAgIGlmIChpIGluIG9iaikgYVtpXSA9IGNhbGxiYWNrLmNhbGwodGhpc0FyZywgb2JqW2ldKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gYTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZGVmaW5lTG9ja2VkUHJvcGVydHkob2JqLCBrZXksIHNldHRlciwgZ2V0dGVyKSB7XFxyXFxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcXFwib2JqZWN0XFxcIikgb2JqID0ge307XFxyXFxuICAgIGlmIChpZSB8fCB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XFxyXFxuICAgICAgICBnZXQ6IGdldHRlcixcXHJcXG4gICAgICAgIHNldDogc2V0dGVyXFxyXFxuICAgICAgfSk7XFxyXFxuICAgICAgcmV0dXJuIG9iajtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhrZXksIGdldHRlcik7XFxyXFxuICAgICAgb2JqLl9fZGVmaW5lU2V0dGVyX18oa2V5LCBzZXR0ZXIpO1xcclxcbiAgICAgIHJldHVybiBvYmo7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbG0sIGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xcclxcbiAgICBpZiAoZWxtLmFkZEV2ZW50TGlzdGVuZXIpIHtcXHJcXG4gICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xcclxcbiAgICB9IGVsc2UgaWYgKGVsbS5hdHRhY2hFdmVudCkge1xcclxcbiAgICAgIGVsbS5hdHRhY2hFdmVudChcXFwib25cXFwiICsgZXZlbnQsIGNhbGxiYWNrKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsbSwgZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XFxyXFxuICAgIGlmIChlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcclxcbiAgICAgIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XFxyXFxuICAgIH0gZWxzZSBpZiAoZWxtLmRldGFjaEV2ZW50KSB7XFxyXFxuICAgICAgZWxtLmRldGFjaEV2ZW50KFxcXCJvblxcXCIgKyBldmVudCwgY2FsbGJhY2spO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBpZSA9IChmdW5jdGlvbigpe1xcclxcbiAgICBmb3IgKHZhciB2ID0gMywgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcJ2JcXCcpLCBhbGwgPSBlbC5hbGwgfHwgW107IGVsLmlubmVySFRNTCA9IFxcJzwhLS1baWYgZ3QgSUUgXFwnICsgKCsrdikgKyBcXCddPjxpPjwhW2VuZGlmXS0tPlxcJywgYWxsWzBdOyk7XFxyXFxuICAgIHJldHVybiB2ID4gNCA/IHYgOiAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcXHJcXG4gIH0oKSk7XFxyXFxuICBcXHJcXG4gIHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgIHJldHVybiArbmV3IERhdGU7XFxyXFxuICB9O1xcclxcbiAgXFxyXFxuICAvKiBDb29raWVzICovXFxyXFxuICBmdW5jdGlvbiBzZXRDb29raWUobmFtZSwgdmFsdWUsIGRvbWFpbiwgcGF0aCwgZXhwaXJlcykge1xcclxcbiAgICBkb21haW4gPSBkb21haW4gPyBcXFwiO2RvbWFpbj1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRvbWFpbikgOiBcXFwiXFxcIjtcXHJcXG4gICAgcGF0aCA9IHBhdGggPyBcXFwiO3BhdGg9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXRoKSA6IFxcXCJcXFwiO1xcclxcbiAgICBleHBpcmVzID0gMCA+IGV4cGlyZXMgPyBcXFwiXFxcIiA6IDAgPT0gZXhwaXJlcyA/IFxcXCI7ZXhwaXJlcz1cXFwiICsgKG5ldyBEYXRlKDE5NzAsIDEsIDEpKS50b1VUQ1N0cmluZygpIDogXFxcIjtleHBpcmVzPVxcXCIgKyAobmV3IERhdGUobm93KCkgKyAxRTMgKiBleHBpcmVzKSkudG9VVENTdHJpbmcoKTtcXHJcXG4gICAgXFxyXFxuICAgIGRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSArIFxcXCI9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBkb21haW4gKyBwYXRoICsgZXhwaXJlcztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0Q29va2llKGtleSkge1xcclxcbiAgICByZXR1cm4gZ2V0Q29va2llcygpW2tleV07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldENvb2tpZXMoKSB7XFxyXFxuICAgIHZhciBjID0gZG9jdW1lbnQuY29va2llLCB2ID0gMCwgY29va2llcyA9IHt9O1xcclxcbiAgICBpZiAoZG9jdW1lbnQuY29va2llLm1hdGNoKC9eXFxcXHMqXFxcXCRWZXJzaW9uPSg/OlxcXCIxXFxcInwxKTtcXFxccyooLiopLykpIHtcXHJcXG4gICAgICBjID0gUmVnRXhwLiQxO1xcclxcbiAgICAgIHYgPSAxO1xcclxcbiAgICB9XFxyXFxuICAgIGlmICh2ID09PSAwKSB7XFxyXFxuICAgICAgbWFwKGMuc3BsaXQoL1ssO10vKSwgZnVuY3Rpb24oY29va2llKSB7XFxyXFxuICAgICAgICB2YXIgcGFydHMgPSBjb29raWUuc3BsaXQoLz0vLCAyKSxcXHJcXG4gICAgICAgICAgICBuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHRyaW1MZWZ0KHBhcnRzWzBdKSksXFxyXFxuICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5sZW5ndGggPiAxID8gZGVjb2RlVVJJQ29tcG9uZW50KHRyaW1SaWdodChwYXJ0c1sxXSkpIDogbnVsbDtcXHJcXG4gICAgICAgIGNvb2tpZXNbbmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBtYXAoYy5tYXRjaCgvKD86XnxcXFxccyspKFshIyQlJlxcJyorXFxcXC0uMC05QS1aXmBhLXp8fl0rKT0oWyEjJCUmXFwnKitcXFxcLS4wLTlBLVpeYGEtenx+XSp8XFxcIig/OltcXFxceDIwLVxcXFx4N0VcXFxceDgwXFxcXHhGRl18XFxcXFxcXFxbXFxcXHgwMC1cXFxceDdGXSkqXFxcIikoPz1cXFxccypbLDtdfCQpL2cpLCBmdW5jdGlvbigkMCwgJDEpIHtcXHJcXG4gICAgICAgIHZhciBuYW1lID0gJDAsIHZhbHVlID0gJDEuY2hhckF0KDApID09PSBcXCdcXFwiXFwnID8gJDEuc3Vic3RyKDEsIC0xKS5yZXBsYWNlKC9cXFxcXFxcXCguKS9nLCBcXFwiJDFcXFwiKSA6ICQxO1xcclxcbiAgICAgICAgY29va2llc1tuYW1lXSA9IHZhbHVlO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBjb29raWVzO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeCkge1xcclxcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpbmplY3QoZnVuYykge1xcclxcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIiksXFxyXFxuICAgICAgICBwID0gKGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xcclxcbiAgICBpZiAoIXApIHtcXHJcXG4gICAgICB0aHJvdyBcXFwiQ291bGQgbm90IGluamVjdCEhIVxcXCI7XFxyXFxuICAgIH1cXHJcXG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJ0ZXh0L2phdmFzY3JpcHRcXFwiKTtcXHJcXG4gICAgc2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCIoXFxcIiArIGZ1bmMgKyBcXFwiKShcXFwiICsgYnVpbGRBcmd1bWVudExpc3QuYXBwbHkobnVsbCwgW2ZhbHNlXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpICsgXFxcIik7XFxcIikpO1xcclxcbiAgICBwLmFwcGVuZENoaWxkKHNjcmlwdCk7XFxyXFxuICAgIHAucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYnVpbGRBcmd1bWVudExpc3Qod3JhcCkge1xcclxcbiAgICB2YXIgbGlzdCA9IFtdO1xcclxcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICAgIGxpc3QucHVzaChcXFwiXFxcXFxcXCJcXFwiICsgYXJnc1tpXS5yZXBsYWNlKC9cXFxcXFxcXC8sIFxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIikucmVwbGFjZSgvXFxcIi9nLCBcXFwiXFxcXFxcXFxcXFxcXFxcIlxcXCIpICsgXFxcIlxcXFxcXFwiXFxcIik7XFxyXFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXHJcXG4gICAgICAgIGxpc3QucHVzaChKU09OLnN0cmluZ2lmeShhcmdzW2ldKSk7XFxyXFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXHJcXG4gICAgICAgIGxpc3QucHVzaChcXFwibnVsbFxcXCIpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goYXJnc1tpXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGlmICh3cmFwKSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCIoXFxcIiArIGxpc3Quam9pbihcXFwiLFxcXCIpICsgXFxcIilcXFwiO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHJldHVybiBsaXN0LmpvaW4oXFxcIixcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpc0pTT05TdHJpbmcoanNvbikge1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgIEpTT04ucGFyc2UoanNvbik7XFxyXFxuICAgIH0gY2F0Y2ggKGUpIHtcXHJcXG4gICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHRydWU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHhocihkZXRhaWxzKSB7XFxyXFxuICAgIHZhciB4bWxodHRwO1xcclxcbiAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcclxcbiAgICAgIHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXHJcXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3BlcmEgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIHR5cGVvZiBvcGVyYS5YTUxIdHRwUmVxdWVzdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXHJcXG4gICAgICB4bWxodHRwID0gbmV3IG9wZXJhLlhNTEh0dHBSZXF1ZXN0KCk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgaWYgKGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSkge1xcclxcbiAgICAgICAgZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKCk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIFxcclxcbiAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcbiAgICB4bWxodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XFxyXFxuICAgICAgdmFyIHJlc3BvbnNlU3RhdGUgPSB7XFxyXFxuICAgICAgICByZXNwb25zZVhNTDooeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLnJlc3BvbnNlWE1MIDogXFwnXFwnKSxcXHJcXG4gICAgICAgIHJlc3BvbnNlVGV4dDooeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLnJlc3BvbnNlVGV4dCA6IFxcJ1xcJyksXFxyXFxuICAgICAgICByZWFkeVN0YXRlOnhtbGh0dHAucmVhZHlTdGF0ZSxcXHJcXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczooeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIDogXFwnXFwnKSxcXHJcXG4gICAgICAgIHN0YXR1czooeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLnN0YXR1cyA6IDApLFxcclxcbiAgICAgICAgc3RhdHVzVGV4dDooeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLnN0YXR1c1RleHQgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgZmluYWxVcmw6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5maW5hbFVybCA6IFxcJ1xcJylcXHJcXG4gICAgICB9O1xcclxcbiAgICAgIGlmIChkZXRhaWxzW1xcXCJvbnJlYWR5c3RhdGVjaGFuZ2VcXFwiXSkge1xcclxcbiAgICAgICAgZGV0YWlsc1tcXFwib25yZWFkeXN0YXRlY2hhbmdlXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCkge1xcclxcbiAgICAgICAgaWYgKGRldGFpbHNbXFxcIm9ubG9hZFxcXCJdICYmIHhtbGh0dHAuc3RhdHVzID49IDIwMCAmJiB4bWxodHRwLnN0YXR1cyA8IDMwMCkge1xcclxcbiAgICAgICAgICBkZXRhaWxzW1xcXCJvbmxvYWRcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0gJiYgKHhtbGh0dHAuc3RhdHVzIDwgMjAwIHx8IHhtbGh0dHAuc3RhdHVzID49IDMwMCkpIHtcXHJcXG4gICAgICAgICAgZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKHJlc3BvbnNlU3RhdGUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICB4bWxodHRwLm9wZW4oZGV0YWlscy5tZXRob2QsIGRldGFpbHMudXJsKTtcXHJcXG4gICAgfSBjYXRjaChlKSB7XFxyXFxuICAgICAgaWYoZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKSB7XFxyXFxuICAgICAgICBkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0oe3Jlc3BvbnNlWE1MOlxcJ1xcJyxyZXNwb25zZVRleHQ6XFwnXFwnLHJlYWR5U3RhdGU6NCxyZXNwb25zZUhlYWRlcnM6XFwnXFwnLHN0YXR1czo0MDMsc3RhdHVzVGV4dDpcXCdGb3JiaWRkZW5cXCd9KTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgcmV0dXJuO1xcclxcbiAgICB9XFxyXFxuICAgIGlmIChkZXRhaWxzLmhlYWRlcnMpIHtcXHJcXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRldGFpbHMuaGVhZGVycykge1xcclxcbiAgICAgICAgeG1saHR0cC5zZXRSZXF1ZXN0SGVhZGVyKHByb3AsIGRldGFpbHMuaGVhZGVyc1twcm9wXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHhtbGh0dHAuc2VuZCgodHlwZW9mKGRldGFpbHMuZGF0YSkgIT0gXFwndW5kZWZpbmVkXFwnKSA/IGRldGFpbHMuZGF0YSA6IG51bGwpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvLyBVc2VkIGZvciB0aGUgbWVzc2FnZSBtb2R1bGUgKHNob3VsZCBwcm9iYWJseSBtb3ZlIHRvIGFub3RoZXIgcGxhY2UpXFxyXFxuICAvLyBJdCByZXBsYWNlcyBhIHByb3BlcnR5IGluIHRoZSBvYmogdG8gYSBwcmVkZWZpbmVkIGZ1bmN0aW9uLCB3aGVyZSB0aGUgYXJndW1lbnRzIHdpbGwgYmUgY2FsbGJhY2tJZCwgdGFyZ2V0LCByZWZlcmVyXFxyXFxuICBmdW5jdGlvbiBiaW5kRnVuY3Rpb25DYWxsYmFja3Mob2JqLCBmdW5jLCB0YXJnZXQsIHJlZmVyZXIpIHtcXHJcXG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XFxyXFxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSBcXFwib2JqXFxcIikge1xcclxcbiAgICAgICAgICBiaW5kRnVuY3Rpb25DYWxsYmFja3Mob2JqW2tleV0pO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICAgIGlmIChvYmpba2V5XS5pbmRleE9mKFxcXCJALyhtZXNzYWdlLmNhbGxiYWNrKS9cXFwiKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0lkID0gb2JqW2tleV0uc3BsaXQoXFxcIkAvKG1lc3NhZ2UuY2FsbGJhY2spL1xcXCIpWzFdO1xcclxcbiAgICAgICAgICAgIG9ialtrZXldID0gYmluZChudWxsLCBmdW5jLCBjYWxsYmFja0lkLCB0YXJnZXQsIHJlZmVyZXIpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGV4dGVuZChvYmosIGRlZmF1bHRzLCBkZWVwKSB7XFxyXFxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcXFwib2JqZWN0XFxcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiVW5zdXBwb3J0ZWQgdHlwZSBmb3Igb2JqLlxcXCIpO1xcclxcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRzICE9PSBcXFwib2JqZWN0XFxcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiVW5zdXBwb3J0ZWQgdHlwZSBmb3IgZGVmYXVsdHMuXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcXHJcXG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIGRlZmF1bHRzW2tleV0gPT09IFxcXCJvYmplY3RcXFwiICYmIGRlZXApIHtcXHJcXG4gICAgICAgICAgZXh0ZW5kKG9ialtrZXldLCBkZWZhdWx0c1trZXldLCBkZWVwKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIG9iajtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaW5BcnJheShrZXksIGFycikge1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGFycltpXSA9PT0ga2V5KSB7XFxyXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBsaXN0Q2xhc3NlcyhlbCkge1xcclxcbiAgICBpZiAoIWVsIHx8ICFlbC5jbGFzc05hbWUpIHJldHVybiBbXTtcXHJcXG4gICAgcmV0dXJuIGVsLmNsYXNzTmFtZS5zcGxpdChcXFwiIFxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XFxyXFxuICAgIHZhciBjbGFzc2VzID0gbGlzdENsYXNzZXMoZWwpO1xcclxcbiAgICB2YXIgYWRkTGlzdCA9IGNsYXNzTmFtZS5zcGxpdChcXFwiIFxcXCIpO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFkZExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoIWluQXJyYXkoYWRkTGlzdFtpXSwgY2xhc3NlcykpIHtcXHJcXG4gICAgICAgIGVsLmNsYXNzTmFtZSArPSBcXFwiIFxcXCIgKyBhZGRMaXN0W2ldO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XFxyXFxuICAgIHZhciBjbGFzc2VzID0gbGlzdENsYXNzZXMoZWwpO1xcclxcbiAgICB2YXIgcmVtb3ZlTGlzdCA9IGNsYXNzTmFtZS5zcGxpdChcXFwiIFxcXCIpO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmICghaW5BcnJheShjbGFzc2VzW2ldLCByZW1vdmVMaXN0KSkge1xcclxcbiAgICAgICAgYnVmZmVyLnB1c2goY2xhc3Nlc1tpXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBlbC5jbGFzc05hbWUgPSBidWZmZXIuam9pbihcXFwiIFxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XFxyXFxuICAgIHJldHVybiBpbkFycmF5KGNsYXNzTmFtZSwgbGlzdENsYXNzZXMoZWwpKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgZGVsYXksIG9wdGlvbnMpe1xcclxcbiAgICBmdW5jdGlvbiB0aW1lb3V0KCkge1xcclxcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBuZXcgRGF0ZTtcXHJcXG4gICAgICB0aW1lciA9IG51bGw7XFxyXFxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXHJcXG4gICAgfVxcclxcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0LCB0aW1lciA9IG51bGwsIHByZXZpb3VzID0gMDtcXHJcXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbigpe1xcclxcbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSwgZHQ7XFxyXFxuICAgICAgXFxyXFxuICAgICAgY29udGV4dCA9IHRoaXM7XFxyXFxuICAgICAgYXJncyA9IGFyZ3VtZW50cztcXHJcXG4gICAgICBcXHJcXG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xcclxcbiAgICAgIGR0ID0gZGVsYXkgLSAobm93IC0gcHJldmlvdXMpO1xcclxcbiAgICAgIFxcclxcbiAgICAgIGlmIChkdCA8PSAwKSB7XFxyXFxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcclxcbiAgICAgICAgdGltZXIgPSBudWxsO1xcclxcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XFxyXFxuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVyICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XFxyXFxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQodGltZW91dCwgZHQpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcclxcbiAgICB9O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBjbG9uZShvYmopIHtcXHJcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoYXJyKSB7XFxyXFxuICAgIHZhciB1bmlxdWVBcnIgPSBbXTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmICghaW5BcnJheSh1bmlxdWVBcnIsIGFycltpXSkpIHtcXHJcXG4gICAgICAgIHVuaXF1ZUFyci5wdXNoKGFycltpXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4gdW5pcXVlQXJyO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XFxyXFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFwtXFxcXFtcXFxcXVxcXFwvXFxcXHtcXFxcfVxcXFwoXFxcXClcXFxcKlxcXFwrXFxcXD9cXFxcLlxcXFxcXFxcXFxcXF5cXFxcJFxcXFx8XS9nLCBcXFwiXFxcXFxcXFwkJlxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB0b0Jsb2IoYnl0ZXMsIGNvbnRlbnRUeXBlKSB7XFxyXFxuICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgXFxcInRleHQvcGxhaW5cXFwiO1xcclxcbiAgICB2YXIgc2xpY2VTaXplID0gNTEyO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xcclxcbiAgICB2YXIgc2xpY2VzQ291bnQgPSBNYXRoLmNlaWwoYnl0ZXNMZW5ndGggLyBzbGljZVNpemUpO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGJ5dGVBcnJheXMgPSBuZXcgQXJyYXkoc2xpY2VzQ291bnQpO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIgc2xpY2VJbmRleCA9IDA7IHNsaWNlSW5kZXggPCBzbGljZXNDb3VudDsgKytzbGljZUluZGV4KSB7XFxyXFxuICAgICAgdmFyIGJlZ2luID0gc2xpY2VJbmRleCAqIHNsaWNlU2l6ZTtcXHJcXG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oYmVnaW4gKyBzbGljZVNpemUsIGJ5dGVzTGVuZ3RoKTtcXHJcXG4gICAgICBcXHJcXG4gICAgICB2YXIgc2xpY2VCeXRlcyA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XFxyXFxuICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gYmVnaW4sIGkgPSAwIDsgb2Zmc2V0IDwgZW5kOyArK2ksICsrb2Zmc2V0KSB7XFxyXFxuICAgICAgICBzbGljZUJ5dGVzW2ldID0gYnl0ZXNbb2Zmc2V0XS5jaGFyQ29kZUF0KDApO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICBieXRlQXJyYXlzW3NsaWNlSW5kZXhdID0gbmV3IFVpbnQ4QXJyYXkoc2xpY2VCeXRlcyk7XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHJldHVybiBuZXcgQmxvYihieXRlQXJyYXlzLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkwoYmxvYikge1xcclxcbiAgICBpZiAoc3VwcG9ydC5jcmVhdGVPYmplY3RVUkwpIHtcXHJcXG4gICAgICBpZiAoc3VwcG9ydC53ZWJraXRVUkwpIHtcXHJcXG4gICAgICAgIHJldHVybiB1dy53ZWJraXRVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdGhyb3cgXFxcImNyZWF0ZU9iamVjdFVSTCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIVxcXCI7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmV2b2tlT2JqZWN0VVJMKHVybCkge1xcclxcbiAgICBpZiAoc3VwcG9ydC5yZXZva2VPYmplY3RVUkwpIHtcXHJcXG4gICAgICBpZiAoc3VwcG9ydC53ZWJraXRVUkwpIHtcXHJcXG4gICAgICAgIHJldHVybiB1dy53ZWJraXRVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJldHVybiB1dy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHRocm93IFxcXCJyZXZva2VPYmplY3RVUkwgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciFcXFwiO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8vIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcXHJcXG4gIGZ1bmN0aW9uIGdldFJhbmRvbUFyYml0cmFyeShtaW4sIG1heCkge1xcclxcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvLyBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gKGluY2x1ZGVkKSBhbmQgbWF4IChleGNsdWRlZClcXHJcXG4gIGZ1bmN0aW9uIGdldFJhbmRvbUludChtaW4sIG1heCkge1xcclxcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvLyBSZXR1cm5zIGEgcmFuZG9tIHN0cmluZyBvZiBjaGFyYWN0ZXJzIG9mIGNoYXJzIHdpdGggdGhlIGxlbmd0aCBvZiBsZW5ndGhcXHJcXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVG9rZW4oY2hhcnMsIGxlbmd0aCkge1xcclxcbiAgICBpZiAodHlwZW9mIGNoYXJzICE9PSBcXFwic3RyaW5nXFxcIikgY2hhcnMgPSBcXFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODktX1xcXCI7XFxyXFxuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSBcXFwibnVtYmVyXFxcIikgbGVuZ3RoID0gNjQ7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgdG9rZW4gPSBcXFwiXFxcIjtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcclxcbiAgICAgIHRva2VuICs9IGNoYXJzW2dldFJhbmRvbUludCgwLCBjaGFyc0xlbmd0aCldO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4gdG9rZW47XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGVzY2FwZUVDTUFWYXJpYWJsZShrZXksIGRlZmF1bHRLZXkpIHtcXHJcXG4gICAga2V5ID0ga2V5LnJlcGxhY2UoL1teMC05YS16QS1aX1xcXFwkXS9nLCBcXFwiXFxcIik7XFxyXFxuICAgIHdoaWxlICgvJFswLTldL2cudGVzdChrZXkpICYmIGtleS5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgaWYgKGtleSA9PT0gXFxcIlxcXCIpIHJldHVybiBkZWZhdWx0S2V5O1xcclxcbiAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcoMSk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGtleTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaW5kZXhPZkFycmF5KHZhbHVlLCBhcnIpIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChhcnJbaV0gPT09IHZhbHVlKSB7XFxyXFxuICAgICAgICByZXR1cm4gaTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIC0xO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRLZXlzKG9iaikge1xcclxcbiAgICB2YXIga2V5cyA9IFtdO1xcclxcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24oa2V5KXtcXHJcXG4gICAgICBrZXlzLnB1c2goa2V5KTtcXHJcXG4gICAgfSk7XFxyXFxuICAgIHJldHVybiBrZXlzO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBzZXRQcm9wZXJ0eSh0YXJnZXQsIHBhdGgsIHZhbHVlLCBjcmVhdGVQYXRoKSB7XFxyXFxuICAgIHZhciB0b2tlbnMgPSBwYXRoLnNwbGl0KFxcXCIuXFxcIik7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKHRhcmdldFt0b2tlbnNbaV1dKSB7XFxyXFxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zW2ldXTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgaWYgKGNyZWF0ZVBhdGgpIHtcXHJcXG4gICAgICAgICAgdGFyZ2V0W3Rva2Vuc1tpXV0gPSB7fTtcXHJcXG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3Rva2Vuc1tpXV07XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB0aHJvdyBcXFwiUGF0aCBcXFwiICsgcGF0aCArIFxcXCIgZG9lcyBub3QgZXhpc3QgZm9yXFxcIiwgdGFyZ2V0O1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB0YXJnZXRbdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXV0gPSB2YWx1ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxcclxcbiAgICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXFxyXFxuICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcXHJcXG4gICAgZWFjaDogZWFjaCxcXHJcXG4gICAgaXNBcnJheTogaXNBcnJheSxcXHJcXG4gICAgaW5BcnJheTogaW5BcnJheSxcXHJcXG4gICAgYmluZDogYmluZCxcXHJcXG4gICAgYXN5bmNDYWxsOiBhc3luY0NhbGwsXFxyXFxuICAgIGRlZmluZUxvY2tlZFByb3BlcnR5OiBkZWZpbmVMb2NrZWRQcm9wZXJ0eSxcXHJcXG4gICAgaWU6IGllLFxcclxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLFxcclxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiByZW1vdmVFdmVudExpc3RlbmVyLFxcclxcbiAgICBub3c6IG5vdyxcXHJcXG4gICAgdHJpbUxlZnQ6IHRyaW1MZWZ0LFxcclxcbiAgICB0cmltUmlnaHQ6IHRyaW1SaWdodCxcXHJcXG4gICAgbWFwOiBtYXAsXFxyXFxuICAgIHNldENvb2tpZTogc2V0Q29va2llLFxcclxcbiAgICBnZXRDb29raWU6IGdldENvb2tpZSxcXHJcXG4gICAgZ2V0Q29va2llczogZ2V0Q29va2llcyxcXHJcXG4gICAgZW5kc1dpdGg6IGVuZHNXaXRoLFxcclxcbiAgICBpbmplY3Q6IGluamVjdCxcXHJcXG4gICAgaXNKU09OU3RyaW5nOiBpc0pTT05TdHJpbmcsXFxyXFxuICAgIHhocjogeGhyLFxcclxcbiAgICBidWlsZEFyZ3VtZW50TGlzdDogYnVpbGRBcmd1bWVudExpc3QsXFxyXFxuICAgIGJpbmRGdW5jdGlvbkNhbGxiYWNrczogYmluZEZ1bmN0aW9uQ2FsbGJhY2tzLFxcclxcbiAgICBleHRlbmQ6IGV4dGVuZCxcXHJcXG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxcclxcbiAgICBjbG9uZTogY2xvbmUsXFxyXFxuICAgIHJlbW92ZUR1cGxpY2F0ZXM6IHJlbW92ZUR1cGxpY2F0ZXMsXFxyXFxuICAgIGVzY2FwZVJlZ0V4cDogZXNjYXBlUmVnRXhwLFxcclxcbiAgICB0b0Jsb2I6IHRvQmxvYixcXHJcXG4gICAgY3JlYXRlT2JqZWN0VVJMOiBjcmVhdGVPYmplY3RVUkwsXFxyXFxuICAgIHJldm9rZU9iamVjdFVSTDogcmV2b2tlT2JqZWN0VVJMLFxcclxcbiAgICBnZXRSYW5kb21BcmJpdHJhcnk6IGdldFJhbmRvbUFyYml0cmFyeSxcXHJcXG4gICAgZ2V0UmFuZG9tSW50OiBnZXRSYW5kb21JbnQsXFxyXFxuICAgIGdlbmVyYXRlVG9rZW46IGdlbmVyYXRlVG9rZW4sXFxyXFxuICAgIGVzY2FwZUVDTUFWYXJpYWJsZTogZXNjYXBlRUNNQVZhcmlhYmxlLFxcclxcbiAgICBpbmRleE9mQXJyYXk6IGluZGV4T2ZBcnJheSxcXHJcXG4gICAgZ2V0S2V5czogZ2V0S2V5cyxcXHJcXG4gICAgc2V0UHJvcGVydHk6IHNldFByb3BlcnR5XFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3V0aWxzLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnc3RvcmFnZS9sb2NhbFN0b3JhZ2VcXCcsW1xcXCJ1dGlsc1xcXCJdLCBmdW5jdGlvbih1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBnZXRJdGVtKGtleSwgY2FsbGJhY2ssIHByZWZlclN5bmMpIHtcXHJcXG4gICAgdmFyIGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xcclxcbiAgICBpZiAocHJlZmVyU3luYykge1xcclxcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHV0aWxzLmFzeW5jQ2FsbChudWxsLCBjYWxsYmFjaywgaXRlbSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgc2V0SXRlbTogdXRpbHMuYmluZChsb2NhbFN0b3JhZ2UsIGxvY2FsU3RvcmFnZS5zZXRJdGVtKSxcXHJcXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSxcXHJcXG4gICAgcmVtb3ZlSXRlbTogdXRpbHMuYmluZChsb2NhbFN0b3JhZ2UsIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKVxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9zdG9yYWdlL2xvY2FsU3RvcmFnZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3N0b3JhZ2UvY29va2llc1xcJyxbXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKHV0aWxzKXtcXHJcXG4gIGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xcclxcbiAgICB1dGlscy5zZXRDb29raWUocHJlZml4ICsga2V5LCB2YWx1ZSwgbnVsbCwgXFxcIi9cXFwiLCAxMDAwKjI0KjYwKjYwKjEwMDApO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRJdGVtKGtleSwgY2FsbGJhY2ssIHByZWZlclN5bmMpIHtcXHJcXG4gICAgdmFyIGl0ZW0gPSB1dGlscy5nZXRDb29raWUocHJlZml4ICsga2V5KTtcXHJcXG4gICAgaWYgKHByZWZlclN5bmMpIHtcXHJcXG4gICAgICBjYWxsYmFjayhpdGVtKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB1dGlscy5hc3luY0NhbGwobnVsbCwgY2FsbGJhY2ssIGl0ZW0pO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5KSB7XFxyXFxuICAgIHV0aWxzLnNldENvb2tpZShwcmVmaXggKyBrZXksIFxcXCJcXFwiLCBudWxsLCBcXFwiL1xcXCIsIDApO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgcHJlZml4ID0gXFxcInl0Y2VudGVyLlxcXCI7XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIHNldEl0ZW06IHNldEl0ZW0sXFxyXFxuICAgIGdldEl0ZW06IGdldEl0ZW0sXFxyXFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW1cXHJcXG4gIH07XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vc3RvcmFnZS9jb29raWVzLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnY29uc29sZVxcJyxbXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKHV0aWxzKXtcXHJcXG4gIGZ1bmN0aW9uIHNldEVuYWJsZWQoYikge1xcclxcbiAgICBlbmFibGVkID0gYjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbG9nKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsIFxcXCJ1c2Vyc2NyaXB0W1xcXCIgKyBzZXNzaW9uVG9rZW4gKyBcXFwiXVxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBlcnJvcigpIHtcXHJcXG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4gZnVuY3Rpb24oKXt9O1xcclxcbiAgICByZXR1cm4gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUsIFxcXCJ1c2Vyc2NyaXB0W1xcXCIgKyBzZXNzaW9uVG9rZW4gKyBcXFwiXVxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB3YXJuKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlLCBcXFwidXNlcnNjcmlwdFtcXFwiICsgc2Vzc2lvblRva2VuICsgXFxcIl1cXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIHNlc3Npb25Ub2tlbiA9ICh0eXBlb2YgY29uc29sZVNlc3Npb25Ub2tlbiA9PT0gXFxcInN0cmluZ1xcXCIgPyBjb25zb2xlU2Vzc2lvblRva2VuIDogdXRpbHMuZ2VuZXJhdGVUb2tlbihudWxsLCA4KSk7XFxyXFxuICBcXHJcXG4gIHZhciBlbmFibGVkID0gdHJ1ZTtcXHJcXG4gIFxcclxcbiAgdmFyIGNvbiA9IHt9O1xcclxcbiAgXFxyXFxuICBjb24uc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xcclxcbiAgXFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShjb24sIFxcXCJsb2dcXFwiLCBmdW5jdGlvbigpe30sIGxvZyk7XFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShjb24sIFxcXCJlcnJvclxcXCIsIGZ1bmN0aW9uKCl7fSwgZXJyb3IpO1xcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkoY29uLCBcXFwid2FyblxcXCIsIGZ1bmN0aW9uKCl7fSwgd2Fybik7XFxyXFxuICBcXHJcXG4gIHJldHVybiBjb247XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vY29uc29sZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3N0b3JhZ2UvYnJvd3NlclxcJyxbXFxcInN1cHBvcnRcXFwiLCBcXFwic3RvcmFnZS9sb2NhbFN0b3JhZ2VcXFwiLCBcXFwic3RvcmFnZS9jb29raWVzXFxcIiwgXFxcImNvbnNvbGVcXFwiXSwgZnVuY3Rpb24oc3VwcG9ydCwgbG9jYWxTdG9yYWdlLCBjb29raWVzKXtcXHJcXG4gIGlmIChzdXBwb3J0LmxvY2FsU3RvcmFnZSkge1xcclxcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xcclxcbiAgfSBlbHNlIHtcXHJcXG4gICAgcmV0dXJuIGNvb2tpZXM7XFxyXFxuICB9XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vc3RvcmFnZS9icm93c2VyLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnc3RvcmFnZS91c2Vyc2NyaXB0XFwnLFtcXFwic3VwcG9ydFxcXCIsIFxcXCJzdG9yYWdlL2Jyb3dzZXJcXFwiLCBcXFwidXRpbHNcXFwiXSwgZnVuY3Rpb24oc3VwcG9ydCwgYnJvd3NlciwgdXRpbHMpe1xcclxcbiAgZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlKSB7XFxyXFxuICAgIEdNX3NldFZhbHVlKGtleSwgdmFsdWUpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRJdGVtKGtleSwgY2FsbGJhY2ssIHByZWZlclN5bmMpIHtcXHJcXG4gICAgdmFyIGl0ZW0gPSBHTV9nZXRWYWx1ZShrZXkpO1xcclxcbiAgICBpZiAocHJlZmVyU3luYykge1xcclxcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHV0aWxzLmFzeW5jQ2FsbChudWxsLCBjYWxsYmFjaywgaXRlbSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXkpIHtcXHJcXG4gICAgR01fZGVsZXRlVmFsdWUoa2V5KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgaWYgKHN1cHBvcnQuR3JlYXNlbW9ua2V5KSB7XFxyXFxuICAgIHJldHVybiB7XFxyXFxuICAgICAgc2V0SXRlbTogc2V0SXRlbSxcXHJcXG4gICAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtLFxcclxcbiAgICAgIGdldEl0ZW06IGdldEl0ZW1cXHJcXG4gICAgfTtcXHJcXG4gIH0gZWxzZSB7XFxyXFxuICAgIHJldHVybiBicm93c2VyO1xcclxcbiAgfVxcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3N0b3JhZ2UvdXNlcnNjcmlwdC5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3N0b3JhZ2VcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcInN0b3JhZ2UvdXNlcnNjcmlwdFxcXCIsIFxcXCJ1dGlsc1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCBzdG9yYWdlSGFuZGxlciwgdXRpbHMpe1xcclxcbiAgZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlKSB7XFxyXFxuICAgIGNhY2hlW2tleV0gPSB2YWx1ZTtcXHJcXG4gICAgc3RvcmFnZUhhbmRsZXIuc2V0SXRlbShrZXksIHZhbHVlKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXkpIHtcXHJcXG4gICAgZGVsZXRlIGNhY2hlW2tleV07XFxyXFxuICAgIHN0b3JhZ2VIYW5kbGVyLnJlbW92ZUl0ZW0oa2V5KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0SXRlbUNhbGxiYWNrKGNhbGxiYWNrLCBrZXksIHZhbHVlKSB7XFxyXFxuICAgIGNhY2hlW2tleV0gPSB2YWx1ZTtcXHJcXG4gICAgY2FsbGJhY2soY2FjaGVba2V5XSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaywgc3luYykge1xcclxcbiAgICBpZiAoIShrZXkgaW4gY2FjaGUpKSB7XFxyXFxuICAgICAgc3RvcmFnZUhhbmRsZXIuZ2V0SXRlbShrZXksIHV0aWxzLmJpbmQobnVsbCwgZ2V0SXRlbUNhbGxiYWNrLCBjYWxsYmFjaywga2V5KSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgaWYgKHN5bmMpIHtcXHJcXG4gICAgICAgIGNhbGxiYWNrKGNhY2hlW2tleV0pO1xcclxcbiAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHV0aWxzLmFzeW5jQ2FsbChudWxsLCBjYWxsYmFjaywgY2FjaGVba2V5XSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBjYWNoZSA9IHt9O1xcclxcbiAgXFxyXFxuICAvKiBFeHBvcnRzICovXFxyXFxuICBleHBvcnRzLnNldEl0ZW0gPSBzZXRJdGVtO1xcclxcbiAgZXhwb3J0cy5yZW1vdmVJdGVtID0gcmVtb3ZlSXRlbTtcXHJcXG4gIGV4cG9ydHMuZ2V0SXRlbSA9IGdldEl0ZW07XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3N0b3JhZ2UuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdVc2VyUHJveHkvQ3VzdG9tRXZlbnRcXCcsW1xcXCJ1dGlsc1xcXCJdLCBmdW5jdGlvbih1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xcclxcbiAgICBpZiAoIWV2ZW50c1tldmVudF0pIHtcXHJcXG4gICAgICAvLyBDcmVhdGluZyB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBldmVudFxcclxcbiAgICAgIGV2ZW50c1tldmVudF0gPSBbXTtcXHJcXG4gICAgICBcXHJcXG4gICAgICBkb2NMaXN0ZW5lcnNbZXZlbnRdID0gdXRpbHMuYmluZChudWxsLCBldmVudExpc3RlbmVyLCBldmVudCwgZXZlbnRzW2V2ZW50XSk7XFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gQWRkaW5nIHRoZSBldmVudCBsaXN0ZW5lci5cXHJcXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZG9jTGlzdGVuZXJzW2V2ZW50XSwgZmFsc2UpO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICAvLyBBZGRpbmcgbGlzdGVuZXIgdG8gYXJyYXkuXFxyXFxuICAgIGV2ZW50c1tldmVudF0ucHVzaChsaXN0ZW5lcik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XFxyXFxuICAgIGlmIChldmVudCBpbiBldmVudHMpIHtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgaWYgKGV2ZW50c1tldmVudF1baV0gPT09IGxpc3RlbmVyKSB7XFxyXFxuICAgICAgICAgIGV2ZW50c1tldmVudF0uc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgICBpLS07IGxlbi0tO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgICBpZiAoZXZlbnRzW2V2ZW50XS5sZW5ndGggPT09IDApIHtcXHJcXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBkb2NMaXN0ZW5lcnNbZXZlbnRdLCBmYWxzZSk7XFxyXFxuICAgICAgICBcXHJcXG4gICAgICAgIGV2ZW50c1tldmVudF0gPSBudWxsO1xcclxcbiAgICAgICAgZG9jTGlzdGVuZXJzW2V2ZW50XSA9IG51bGw7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycywgZSkge1xcclxcbiAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XFxyXFxuICAgIFxcclxcbiAgICAvLyBQYXJzZSB0aGUgZGV0YWlsIHRvIHRoZSBvcmlnaW5hbCBvYmplY3QuXFxyXFxuICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShlLmRldGFpbCk7XFxyXFxuICAgIFxcclxcbiAgICBpZiAodHlwZW9mIGRhdGEuZGV0YWlsID09PSBcXFwib2JqZWN0XFxcIiAmJiBkYXRhLnRva2VuICE9PSB0b2tlbikge1xcclxcbiAgICAgIHZhciBkZXRhaWwgPSBkYXRhLmRldGFpbDtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAvLyBDYWxsIHRoZSBsaXN0ZW5lciB3aXRoIHRoZSBldmVudCBuYW1lIGFuZCB0aGUgcGFyc2VkIGRldGFpbC5cXHJcXG4gICAgICAgIGxpc3RlbmVyc1tpXShkZXRhaWwpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICBcXHJcXG4gICAgICAvLyBQcmV2ZW50IHByb3BhZ2F0aW9uXFxyXFxuICAgICAgaWYgKGUgJiYgdHlwZW9mIGUuc3RvcFByb3BhZ2F0aW9uID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnQsIGRldGFpbCkge1xcclxcbiAgICAvLyBDcmVhdGluZyB0aGUgZXZlbnRcXHJcXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcXFwiQ3VzdG9tRXZlbnRcXFwiKTtcXHJcXG4gICAgZS5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHRydWUsIHRydWUsIEpTT04uc3RyaW5naWZ5KHsgZGV0YWlsOiBkZXRhaWwsIHRva2VuOiB0b2tlbiB9KSk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBGaXJpbmcgdGhlIGV2ZW50XFxyXFxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGUpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgdG9rZW4gPSB1dGlscy5nZW5lcmF0ZVRva2VuKCk7IC8vIFRoZSB0b2tlbiBpcyB1c2VkIHRvIGlkZW50aWZ5IGl0c2VsZiBhbmQgcHJldmVudCBjYWxsaW5nIGl0cyBvd24gbGlzdGVuZXJzLlxcclxcbiAgdmFyIGV2ZW50cyA9IHt9O1xcclxcbiAgdmFyIGRvY0xpc3RlbmVycyA9IHt9O1xcclxcbiAgXFxyXFxuICByZXR1cm4ge1xcclxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLFxcclxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiByZW1vdmVFdmVudExpc3RlbmVyLFxcclxcbiAgICBmaXJlRXZlbnQ6IGZpcmVFdmVudFxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9Vc2VyUHJveHkvQ3VzdG9tRXZlbnQuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdVc2VyUHJveHkvTWVzc2FnZVxcJyxbXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKHV0aWxzKXtcXHJcXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XFxyXFxuICAgIGluaXRNZXNzYWdlKCk7IC8vIEluaXQgdGhlIG1lc3NhZ2UgZXZlbnQgbGlzdGVuZXIgaWYgbm90IGFscmVhZHkgaW5pdGlhbGl6ZWQuXFxyXFxuICAgIFxcclxcbiAgICBpZiAoIWV2ZW50c1tldmVudF0pIGV2ZW50c1tldmVudF0gPSBbXTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIEJpbmQgdGhlIGV2ZW50IG5hbWUgdG8gdGhlIGxpc3RlbmVyIGFzIGFuIGFyZ3VtZW50LlxcclxcbiAgICB2YXIgYm91bmRMaXN0ZW5lciA9IHV0aWxzLmJpbmQobnVsbCwgbGlzdGVuZXIsIGV2ZW50KTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIEFkZCB0aGUgYm91bmRMaXN0ZW5lciB0byB0aGUgZXZlbnRcXHJcXG4gICAgZXZlbnRzW2V2ZW50XS5wdXNoKGJvdW5kTGlzdGVuZXIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnQsIGRldGFpbCkge1xcclxcbiAgICB3aW5kb3cucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeyB0b2tlbjogdG9rZW4sIGV2ZW50OiBldmVudCwgZGV0YWlsOiBkZXRhaWwgfSksIFxcXCIqXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIG1lc3NhZ2VMaXN0ZW5lcihlKSB7XFxyXFxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFBhcnNlIHRoZSBkZXRhaWwgdG8gdGhlIG9yaWdpbmFsIG9iamVjdC5cXHJcXG4gICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGUuZGF0YSk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgcmV0cmlldmVkIGluZm9ybWF0aW9uIGlzIGNvcnJlY3QgYW5kIHRoYXQgaXQgZGlkblxcJ3QgY2FsbCBpdHNlbGYuXFxyXFxuICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudCA9PT0gXFxcInN0cmluZ1xcXCIgJiYgdHlwZW9mIGRhdGEuZGV0YWlsID09PSBcXFwib2JqZWN0XFxcIiAmJiBkYXRhLnRva2VuICE9PSB0b2tlbikge1xcclxcbiAgICAgIFxcclxcbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBsaXN0ZW5lciBmb3IgZGF0YS5ldmVudC5cXHJcXG4gICAgICBpZiAodXRpbHMuaXNBcnJheShldmVudHNbZGF0YS5ldmVudF0pKSB7XFxyXFxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2RhdGEuZXZlbnRdO1xcclxcbiAgICAgICAgXFxyXFxuICAgICAgICB2YXIgZGV0YWlsID0gZGF0YS5kZXRhaWw7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgIGxpc3RlbmVycyhkZXRhaWwpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICBcXHJcXG4gICAgICAgIC8vIFByZXZlbnQgcHJvcGFnYXRpb24gb25seSBpZiBldmVyeXRoaW5nIHdlbnQgd2VsbC5cXHJcXG4gICAgICAgIGlmIChlICYmIHR5cGVvZiBlLnN0b3BQcm9wYWdhdGlvbiA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpbml0TWVzc2FnZSgpIHtcXHJcXG4gICAgaWYgKCFtZXNzYWdlRXZlbnRBZGRlZCkge1xcclxcbiAgICAgIC8vIEFkZGluZyB0aGUgbWVzc2FnZSBldmVudCBsaXN0ZW5lci5cXHJcXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsIG1lc3NhZ2VMaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBtZXNzYWdlRXZlbnRBZGRlZCA9IGZhbHNlO1xcclxcbiAgdmFyIHRva2VuID0gdXRpbHMuZ2VuZXJhdGVUb2tlbigpOyAvLyBUaGUgdG9rZW4gaXMgdXNlZCB0byBpZGVudGlmeSBpdHNlbGYgYW5kIHByZXZlbnQgY2FsbGluZyBpdHMgb3duIGxpc3RlbmVycy5cXHJcXG4gIFxcclxcbiAgdmFyIGV2ZW50cyA9IHt9O1xcclxcbiAgXFxyXFxuICByZXR1cm4ge1xcclxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLFxcclxcbiAgICBmaXJlRXZlbnQ6IGZpcmVFdmVudFxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9Vc2VyUHJveHkvTWVzc2FnZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ1VzZXJQcm94eS9zdXBwb3J0XFwnLFtdLCBmdW5jdGlvbigpe1xcclxcbiAgZnVuY3Rpb24gY3VzdG9tRXZlbnQoKSB7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcXCdDdXN0b21FdmVudFxcJyk7XFxyXFxuICAgICAgaWYgKGUgJiYgdHlwZW9mIGUuaW5pdEN1c3RvbUV2ZW50ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgICBlLmluaXRDdXN0b21FdmVudChtb2QsIHRydWUsIHRydWUsIHsgbW9kOiBtb2QgfSk7XFxyXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBtb2QgPSBcXFwic3VwcG9ydC50ZXN0XFxcIjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgQ3VzdG9tRXZlbnQ6IGN1c3RvbUV2ZW50XFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L1VzZXJQcm94eS9zdXBwb3J0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnVXNlclByb3h5L21lbUZ1bmN0aW9uXFwnLFtcXFwidXRpbHNcXFwiLCBcXFwiLi9DdXN0b21FdmVudFxcXCIsIFxcXCIuL01lc3NhZ2VcXFwiLCBcXFwiLi9zdXBwb3J0XFxcIl0sIGZ1bmN0aW9uKHV0aWxzLCBjdXN0b21FdmVudCwgbWVzc2FnZSwgc3VwcG9ydCl7XFxyXFxuICBmdW5jdGlvbiBwYXJzZU9iamVjdChvYmosIHRva2VuLCB0eXBlKSB7XFxyXFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcXFwib2JqZWN0XFxcIikge1xcclxcbiAgICAgIHV0aWxzLmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbHVlKXtcXHJcXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgICAgIG9ialtrZXldID0gcGFyc2VPYmplY3QodmFsdWUsIHRva2VuLCB0eXBlKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgICBvYmpba2V5XSA9IHBhcnNlU3RyaW5nKHZhbHVlKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgICAgIHZhciBpZCA9IGNhY2hlLnB1c2godmFsdWUpIC0gMTtcXHJcXG4gICAgICAgICAgb2JqW2tleV0gPSBcXFwiJHtcXFwiICsgdG9rZW4gKyBcXFwiL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwifVxcXCI7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgIG9iaiA9IHBhcnNlU3RyaW5nKG9iaik7XFxyXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgIHZhciBpZCA9IGNhY2hlLnB1c2gob2JqKSAtIDE7XFxyXFxuICAgICAgb2JqID0gXFxcIiR7XFxcIiArIHRva2VuICsgXFxcIi9cXFwiICsgdHlwZSArIFxcXCIvXFxcIiArIGlkICsgXFxcIn1cXFwiO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBvYmo7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xcclxcbiAgICBpZiAoL15cXFxcJFtcXFxcXFxcXF0qXFxcXHsoWzAtOWEtekEtWlxcXFwuXFxcXC1fXFxcXC9cXFxcXFxcXF0rKVxcXFx9JC9nLnRlc3Qoc3RyKSkge1xcclxcbiAgICAgIHJldHVybiBcXFwiJFxcXFxcXFxcXFxcIiArIHN0ci5zdWJzdHJpbmcoMSk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHN0cjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVzdG9yZVN0cmluZyhzdHIsIHRva2VuLCB0eXBlKSB7XFxyXFxuICAgIGlmICgvXlxcXFwkXFxcXHsoWzAtOWEtekEtWlxcXFwuXFxcXC1fXSspXFxcXC8oWzAtOWEtekEtWlxcXFwuXFxcXC1fXSspXFxcXC8oWzAtOV0rKVxcXFx9JC9nLnRlc3Qoc3RyKSkge1xcclxcbiAgICAgIHZhciBwYXJzZWQgPSBzdHIuc3Vic3RyaW5nKDIsIHN0ci5sZW5ndGggLSAxKS5zcGxpdChcXFwiL1xcXCIpOyAvLyBcXFwiICsgdG9rZW4gKyBcXFwiL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwiXFxyXFxuICAgICAgdmFyIGlkID0gcGFyc2VJbnQocGFyc2VkWzJdLCAxMCk7XFxyXFxuICAgICAgaWYgKHBhcnNlZFswXSA9PT0gdG9rZW4gJiYgcGFyc2VkWzFdID09PSB0eXBlKSB7XFxyXFxuICAgICAgICByZXR1cm4gY2FjaGVbaWRdO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICByZXR1cm4gdXRpbHMuYmluZChudWxsLCBmdW5jdGlvblBsYWNlaG9sZGVyLCBwYXJzZWRbMF0gKyBcXFwiLVxcXCIgKyBwYXJzZWRbMV0sIGlkKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSBpZiAoL15cXFxcJFtcXFxcXFxcXF0rXFxcXHsoWzAtOWEtekEtWlxcXFwuXFxcXC1fXFxcXC9cXFxcXFxcXF0rKVxcXFx9JC9nLnRlc3Qoc3RyKSkge1xcclxcbiAgICAgIHJldHVybiBcXFwiJFxcXCIgKyBzdHIuc3Vic3RyaW5nKDIpO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBzdHI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJlc3RvcmVPYmplY3Qob2JqLCB0b2tlbiwgdHlwZSkge1xcclxcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXHJcXG4gICAgICB1dGlscy5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XFxyXFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwib2JqZWN0XFxcIikge1xcclxcbiAgICAgICAgICBvYmpba2V5XSA9IHJlc3RvcmVPYmplY3QodmFsdWUsIHRva2VuLCB0eXBlKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgICBvYmpba2V5XSA9IHJlc3RvcmVTdHJpbmcodmFsdWUsIHRva2VuLCB0eXBlKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgICAgIHRocm93IEVycm9yKFxcXCJGdW5jdGlvbiB3YXMgZm91bmQhXFxcIik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgIHJldHVybiByZXN0b3JlU3RyaW5nKHZhbHVlLCB0b2tlbiwgdHlwZSk7XFxyXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgdGhyb3cgRXJyb3IoXFxcIkZ1bmN0aW9uIHdhcyBmb3VuZCFcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gb2JqO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBmdW5jdGlvblBsYWNlaG9sZGVyKGV2ZW50LCBpZCkge1xcclxcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XFxyXFxuICAgIGlmIChzdXBwb3J0LkN1c3RvbUV2ZW50KSB7XFxyXFxuICAgICAgcmV0dXJuIGN1c3RvbUV2ZW50LmZpcmVFdmVudChldmVudCwgeyBjYWxsYmFja0lkOiBpZCwgYXJnczogYXJncywgbWVtOiB0cnVlIH0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHJldHVybiBtZXNzYWdlLmZpcmVFdmVudChldmVudCwgeyBjYWxsYmFja0lkOiBpZCwgYXJnczogYXJncywgbWVtOiB0cnVlIH0pO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldENhY2hlRnVuY3Rpb24oaWQpIHtcXHJcXG4gICAgcmV0dXJuIGNhY2hlW2lkXTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIGNhY2hlID0gW107XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIHBhcnNlT2JqZWN0OiBwYXJzZU9iamVjdCxcXHJcXG4gICAgcmVzdG9yZU9iamVjdDogcmVzdG9yZU9iamVjdCxcXHJcXG4gICAgZ2V0Q2FjaGVGdW5jdGlvbjogZ2V0Q2FjaGVGdW5jdGlvblxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9Vc2VyUHJveHkvbWVtRnVuY3Rpb24uanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdVc2VyUHJveHkvQ29ubmVjdGlvblxcJyxbXFxcIi4vQ3VzdG9tRXZlbnRcXFwiLCBcXFwiLi9NZXNzYWdlXFxcIiwgXFxcInV0aWxzXFxcIiwgXFxcIi4vc3VwcG9ydFxcXCIsIFxcXCIuL21lbUZ1bmN0aW9uXFxcIl0sIGZ1bmN0aW9uKGN1c3RvbUV2ZW50LCBtZXNzYWdlLCB1dGlscywgc3VwcG9ydCwgbWVtKXtcXHJcXG4gIGZ1bmN0aW9uIGxpc3RlbmVyUHJveHkoZnVuY3Rpb25zLCB0b2tlbiwgdHlwZSwgZGV0YWlsKSB7XFxyXFxuICAgIHNldFRpbWVvdXQodXRpbHMuYmluZChudWxsLCBsaXN0ZW5lciwgZnVuY3Rpb25zLCB0b2tlbiwgdHlwZSwgZGV0YWlsKSwgNCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGxpc3RlbmVyKGZ1bmN0aW9ucywgdG9rZW4sIHR5cGUsIGRldGFpbCkge1xcclxcbiAgICB2YXIga2V5cyA9IHV0aWxzLmdldEtleXMoZnVuY3Rpb25zKTtcXHJcXG4gICAgdmFyIGluZGV4ID0gdXRpbHMuaW5kZXhPZkFycmF5KGRldGFpbC5tZXRob2QsIGtleXMpO1xcclxcbiAgICBpZiAoaW5kZXggPiAtMSkge1xcclxcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbnNba2V5c1tpbmRleF1dLmFwcGx5KG51bGwsIG1lbS5yZXN0b3JlT2JqZWN0KGRldGFpbC5hcmdzLCB0b2tlbiwgdHlwZSkpO1xcclxcbiAgICAgIGlmICh0eXBlb2YgZGV0YWlsLmlkID09PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgICAgdmFyIG1lbVJlc3VsdCA9IG1lbS5wYXJzZU9iamVjdChyZXN1bHQsIHRva2VuLCB0eXBlKTtcXHJcXG4gICAgICAgIHZhciBkZXRhaWwgPSB7IGNhbGxiYWNrSWQ6IGRldGFpbC5pZCwgYXJnczogWyBtZW1SZXN1bHQgXSB9O1xcclxcbiAgICAgICAgaWYgKHN1cHBvcnQuQ3VzdG9tRXZlbnQpIHtcXHJcXG4gICAgICAgICAgY3VzdG9tRXZlbnQuZmlyZUV2ZW50KHRva2VuICsgXFxcIi1wYWdlXFxcIiwgZGV0YWlsKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIG1lc3NhZ2UuYWRkRXZlbnRMaXN0ZW5lcih0b2tlbiArIFxcXCItcGFnZVxcXCIsIGRldGFpbCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHRocm93IFxcXCJNZXRob2QgXFxcIiArIGRldGFpbC5tZXRob2QgKyBcXFwiIGhhcyBub3QgYmVlbiBzZXQhXFxcIjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBDb25uZWN0aW9uKHBhZ2VQcm94eSkge1xcclxcbiAgICB0aGlzLnRva2VuID0gdXRpbHMuZ2VuZXJhdGVUb2tlbigpO1xcclxcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IHt9O1xcclxcbiAgICB0aGlzLm5hbWVzcGFjZSA9IFxcXCJVc2VyUHJveHlcXFwiO1xcclxcbiAgICB0aGlzLnBhZ2VQcm94eSA9IHBhZ2VQcm94eTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0RnVuY3Rpb25zID0gZnVuY3Rpb24gc2V0RnVuY3Rpb25zKGZ1bmN0aW9ucykge1xcclxcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gc2V0RnVuY3Rpb25zKG5hbWVzcGFjZSkge1xcclxcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KGNvZGUpIHtcXHJcXG4gICAgdmFyIHBhcmVudCA9IChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcXHJcXG4gICAgaWYgKCFwYXJlbnQpIHRocm93IFxcXCJQYXJlbnQgd2FzIG5vdCBmb3VuZCFcXFwiO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpXFxyXFxuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwidGV4dC9qYXZhc2NyaXB0XFxcIik7XFxyXFxuXFxyXFxuICAgIHRoaXMuY29ubmVjdCgpO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGFyZ3MgPSBbIGZhbHNlLCB0aGlzLnRva2VuLCB1dGlscy5nZXRLZXlzKHRoaXMuZnVuY3Rpb25zKSBdO1xcclxcbiAgICBhcmdzID0gYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgY29udGVudCA9IFxcXCIoXFxcIiArIGNvZGUgKyBcXFwiKShcXFwiICsgdXRpbHMuYnVpbGRBcmd1bWVudExpc3QuYXBwbHkobnVsbCwgYXJncykgKyBcXFwiKTtcXFwiO1xcclxcbiAgICBcXHJcXG4gICAgc2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcXHJcXG4gICAgXFxyXFxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xcclxcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XFxyXFxuICAgIGlmICh0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbkxpc3RlbmVyKSB0aGlzLmRpc2Nvbm5lY3QoKTtcXHJcXG4gICAgXFxyXFxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uTGlzdGVuZXIgPSB1dGlscy5iaW5kKG51bGwsIGxpc3RlbmVyUHJveHksIHRoaXMuZnVuY3Rpb25zLCB0aGlzLnRva2VuLCBcXFwiY29udGVudFxcXCIpO1xcclxcbiAgICBpZiAoc3VwcG9ydC5DdXN0b21FdmVudCkge1xcclxcbiAgICAgIGN1c3RvbUV2ZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy50b2tlbiArIFxcXCItY29udGVudFxcXCIsIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uTGlzdGVuZXIpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIG1lc3NhZ2UuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnRva2VuICsgXFxcIi1jb250ZW50XFxcIiwgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lcik7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XFxyXFxuICAgIGlmICghdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lcikgcmV0dXJuO1xcclxcbiAgICBpZiAoc3VwcG9ydC5DdXN0b21FdmVudCkge1xcclxcbiAgICAgIGN1c3RvbUV2ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy50b2tlbiArIFxcXCItY29udGVudFxcXCIsIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uTGlzdGVuZXIpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIG1lc3NhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLnRva2VuICsgXFxcIi1jb250ZW50XFxcIiwgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lcik7XFxyXFxuICAgIH1cXHJcXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lciA9IG51bGw7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHJldHVybiBDb25uZWN0aW9uO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L1VzZXJQcm94eS9Db25uZWN0aW9uLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnZXh0ZW5zaW9ucy1jb25uZWN0aW9uL3VzZXJzY3JpcHRcXCcsW10sIGZ1bmN0aW9uKCl7XFxyXFxuICBmdW5jdGlvbiBlbXB0eSgpIHsgfVxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgc2V0UGFnZUNvbm5lY3Rpb246IGVtcHR5XFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L2V4dGVuc2lvbnMtY29ubmVjdGlvbi91c2Vyc2NyaXB0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwneGhyL2Jyb3dzZXJcXCcsW10sIGZ1bmN0aW9uKCl7XFxyXFxuICBmdW5jdGlvbiB4aHIoZGV0YWlscykge1xcclxcbiAgICB2YXIgeG1saHR0cDtcXHJcXG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcclxcbiAgICAgIHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgIH1cXHJcXG4gICAgeG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xcclxcbiAgICAgIHZhciByZXNwb25zZVN0YXRlID0ge1xcclxcbiAgICAgICAgcmVzcG9uc2VYTUw6IFxcJ1xcJyxcXHJcXG4gICAgICAgIHJlc3BvbnNlVGV4dDogKHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5yZXNwb25zZVRleHQgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgcmVhZHlTdGF0ZTogeG1saHR0cC5yZWFkeVN0YXRlLFxcclxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiAoeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIDogXFwnXFwnKSxcXHJcXG4gICAgICAgIHN0YXR1czogKHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5zdGF0dXMgOiAwKSxcXHJcXG4gICAgICAgIHN0YXR1c1RleHQ6ICh4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuc3RhdHVzVGV4dCA6IFxcJ1xcJyksXFxyXFxuICAgICAgICBmaW5hbFVybDogKHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5maW5hbFVybCA6IFxcJ1xcJylcXHJcXG4gICAgICB9O1xcclxcbiAgICAgIGlmIChkZXRhaWxzW1xcXCJvbnJlYWR5c3RhdGVjaGFuZ2VcXFwiXSkge1xcclxcbiAgICAgICAgZGV0YWlsc1tcXFwib25yZWFkeXN0YXRlY2hhbmdlXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCkge1xcclxcbiAgICAgICAgaWYgKGRldGFpbHNbXFxcIm9ubG9hZFxcXCJdICYmIHhtbGh0dHAuc3RhdHVzID49IDIwMCAmJiB4bWxodHRwLnN0YXR1cyA8IDMwMCkge1xcclxcbiAgICAgICAgICBkZXRhaWxzW1xcXCJvbmxvYWRcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0gJiYgKHhtbGh0dHAuc3RhdHVzIDwgMjAwIHx8IHhtbGh0dHAuc3RhdHVzID49IDMwMCkpIHtcXHJcXG4gICAgICAgICAgZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKHJlc3BvbnNlU3RhdGUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICB4bWxodHRwLm9wZW4oZGV0YWlscy5tZXRob2QsIGRldGFpbHMudXJsKTtcXHJcXG4gICAgfSBjYXRjaChlKSB7XFxyXFxuICAgICAgZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKCk7XFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKGRldGFpbHMuaGVhZGVycykge1xcclxcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGV0YWlscy5oZWFkZXJzKSB7XFxyXFxuICAgICAgICB4bWxodHRwLnNldFJlcXVlc3RIZWFkZXIocHJvcCwgZGV0YWlscy5oZWFkZXJzW3Byb3BdKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgeG1saHR0cC5zZW5kKCh0eXBlb2YoZGV0YWlscy5kYXRhKSAhPT0gXFwndW5kZWZpbmVkXFwnKSA/IGRldGFpbHMuZGF0YSA6IG51bGwpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICByZXR1cm4geGhyO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3hoci9icm93c2VyLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwneGhyL3VzZXJzY3JpcHRcXCcsW1xcXCJzdXBwb3J0XFxcIiwgXFxcInhoci9icm93c2VyXFxcIl0sIGZ1bmN0aW9uKHN1cHBvcnQsIGJyb3dzZXIpe1xcclxcbiAgaWYgKHN1cHBvcnQuR3JlYXNlbW9ua2V5KSB7XFxyXFxuICAgIHJldHVybiBHTV94bWxodHRwUmVxdWVzdDtcXHJcXG4gIH0gZWxzZSB7XFxyXFxuICAgIHJldHVybiBicm93c2VyO1xcclxcbiAgfVxcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3hoci91c2Vyc2NyaXB0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwneGhyXFwnLFtcXFwieGhyL3VzZXJzY3JpcHRcXFwiXSwgZnVuY3Rpb24oeGhyKXtcXHJcXG4gIHJldHVybiB4aHI7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0veGhyLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnbWFpbi13cmFwcGVyXFwnLFtcXFwic3RvcmFnZVxcXCIsIFxcXCJVc2VyUHJveHkvQ29ubmVjdGlvblxcXCIsIFxcXCJleHRlbnNpb25zLWNvbm5lY3Rpb24vdXNlcnNjcmlwdFxcXCIsIFxcXCJ4aHJcXFwiLCBcXFwiY29uc29sZVxcXCJdLCBmdW5jdGlvbihzdG9yYWdlLCBDb25uZWN0aW9uLCBleHRlbnNpb24sIHhociwgY29uKXtcXHJcXG4gIHZhciBmdW5jdGlvbk1hcCA9IHtcXHJcXG4gICAgXFxcInNldEl0ZW1cXFwiOiBzdG9yYWdlLnNldEl0ZW0sXFxyXFxuICAgIFxcXCJnZXRJdGVtXFxcIjogc3RvcmFnZS5nZXRJdGVtLFxcclxcbiAgICBcXFwicmVtb3ZlSXRlbVxcXCI6IHN0b3JhZ2UucmVtb3ZlSXRlbSxcXHJcXG4gICAgXFxcInhoclxcXCI6IHhocixcXHJcXG4gICAgXFxcImxvZ1xcXCI6IGNvbi5sb2dcXHJcXG4gIH07XFxyXFxuICBcXHJcXG4gIHZhciBjb25uZWN0aW9uID0gbnVsbDtcXHJcXG4gIFxcclxcbiAgc3RvcmFnZS5nZXRJdGVtKFxcXCJZb3VUdWJlQ2VudGVyU2V0dGluZ3NcXFwiLCBmdW5jdGlvbihzZXR0aW5ncyl7XFxyXFxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09IFxcXCJvYmplY3RcXFwiKSBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2V0dGluZ3MgfHwgXFxcInt9XFxcIik7XFxyXFxuICAgIFxcclxcbiAgICBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oKTtcXHJcXG4gICAgY29ubmVjdGlvbi5zZXRGdW5jdGlvbnMoZnVuY3Rpb25NYXApO1xcclxcbiAgICBcXHJcXG4gICAgZXh0ZW5zaW9uLnNldFBhZ2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xcclxcbiAgICBcXHJcXG4gICAgY29ubmVjdGlvbi5pbmplY3QobWFpblBhZ2UsIHNldHRpbmdzLCBjb24uc2Vzc2lvblRva2VuKTtcXHJcXG4gIH0sIHRydWUpO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L21haW4td3JhcHBlci5qc1wiKTtcblxuIgogIF0KfQ==
})();