// ==UserScript==
// @id              YouTubeCenter
// @name            YouTube Center
// @namespace       http://www.facebook.com/YouTubeCenter
// @version         3.0.0
// @author          Jeppe Rune Mortensen <jepperm@gmail.com>
// @description     YouTube Center contains all kind of different useful functions which makes your visit on YouTube much more entertaining.
// @icon            https://raw.github.com/YePpHa/YouTubeCenter/master/assets/logo-48x48.png
// @icon64          https://raw.github.com/YePpHa/YouTubeCenter/master/assets/logo-64x64.png
// @domain          yeppha.github.io
// @domain          youtube.com
// @domain          www.youtube.com
// @domain          gdata.youtube.com
// @domain          apis.google.com
// @domain          plus.googleapis.com
// @domain          googleapis.com
// @domain          raw.github.com
// @domain          raw2.github.com
// @domain          s.ytimg.com
// @match           http://*.youtube.com/*
// @match           https://*.youtube.com/*
// @match           https://yeppha.github.io/downloads/YouTubeCenter.meta.js
// @match           http://s.ytimg.com/yts/jsbin/*
// @match           https://s.ytimg.com/yts/jsbin/*
// @match           https://raw.github.com/YePpHa/YouTubeCenter/master/*
// @match           http://apis.google.com/*/widget/render/comments?*
// @match           https://apis.google.com/*/widget/render/comments?*
// @match           http://plus.googleapis.com/*/widget/render/comments?*
// @match           https://plus.googleapis.com/*/widget/render/comments?*
// @include         http://*.youtube.com/*
// @include         https://*.youtube.com/*
// @include         http://apis.google.com/*/widget/render/comments?*
// @include         https://apis.google.com/*/widget/render/comments?*
// @include         http://plus.googleapis.com/*/widget/render/comments?*
// @include         https://plus.googleapis.com/*/widget/render/comments?*
// @exclude         http://apiblog.youtube.com/*
// @exclude         https://apiblog.youtube.com/*
// @exclude         http://*.youtube.com/subscribe_embed?*
// @exclude         https://*.youtube.com/subscribe_embed?*
// @grant           GM_getValue
// @grant           GM_setValue
// @grant           GM_deleteValue
// @grant           GM_xmlhttpRequest
// @grant           GM_log
// @grant           GM_registerMenuCommand
// @grant           unsafeWindow
// @updateURL       https://github.com/YePpHa/YouTubeCenter/raw/master/dist/YouTubeCenter.meta.js
// @downloadURL     https://github.com/YePpHa/YouTubeCenter/raw/master/dist/YouTubeCenter.user.js
// @updateVersion   1
// @run-at          document-start
// @priority        9001
// @contributionURL https://github.com/YePpHa/YouTubeCenter/wiki/Donate
// ==/UserScript==

(function(){
function mainPage(UserProxy_token, UserProxy_functions, globalSettings, consoleSessionToken) {
(function () {eval("/**\r\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/jrburke/almond for details\r\n */\r\n//Going sloppy to avoid \'use strict\' string cost, but strict practices should\r\n//be followed.\r\n/*jslint sloppy: true */\r\n/*global setTimeout: false */\r\n\r\nvar requirejs, require, define;\r\n(function (undef) {\r\n    var main, req, makeMap, handlers,\r\n        defined = {},\r\n        waiting = {},\r\n        config = {},\r\n        defining = {},\r\n        hasOwn = Object.prototype.hasOwnProperty,\r\n        aps = [].slice,\r\n        jsSuffixRegExp = /\\.js$/;\r\n\r\n    function hasProp(obj, prop) {\r\n        return hasOwn.call(obj, prop);\r\n    }\r\n\r\n    /**\r\n     * Given a relative module name, like ./something, normalize it to\r\n     * a real name that can be mapped to a path.\r\n     * @param {String} name the relative name\r\n     * @param {String} baseName a real name that the name arg is relative\r\n     * to.\r\n     * @returns {String} normalized name\r\n     */\r\n    function normalize(name, baseName) {\r\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\r\n            foundI, foundStarMap, starI, i, j, part,\r\n            baseParts = baseName && baseName.split(\"/\"),\r\n            map = config.map,\r\n            starMap = (map && map[\'*\']) || {};\r\n\r\n        //Adjust any relative paths.\r\n        if (name && name.charAt(0) === \".\") {\r\n            //If have a base name, try to normalize against it,\r\n            //otherwise, assume it is a top-level require that will\r\n            //be relative to baseUrl in the end.\r\n            if (baseName) {\r\n                //Convert baseName to array, and lop off the last part,\r\n                //so that . matches that \"directory\" and not name of the baseName\'s\r\n                //module. For instance, baseName of \"one/two/three\", maps to\r\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\r\n                //this normalization.\r\n                baseParts = baseParts.slice(0, baseParts.length - 1);\r\n                name = name.split(\'/\');\r\n                lastIndex = name.length - 1;\r\n\r\n                // Node .js allowance:\r\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\r\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, \'\');\r\n                }\r\n\r\n                name = baseParts.concat(name);\r\n\r\n                //start trimDots\r\n                for (i = 0; i < name.length; i += 1) {\r\n                    part = name[i];\r\n                    if (part === \".\") {\r\n                        name.splice(i, 1);\r\n                        i -= 1;\r\n                    } else if (part === \"..\") {\r\n                        if (i === 1 && (name[2] === \'..\' || name[0] === \'..\')) {\r\n                            //End of the line. Keep at least one non-dot\r\n                            //path segment at the front so it can be mapped\r\n                            //correctly to disk. Otherwise, there is likely\r\n                            //no path mapping for a path starting with \'..\'.\r\n                            //This can still fail, but catches the most reasonable\r\n                            //uses of ..\r\n                            break;\r\n                        } else if (i > 0) {\r\n                            name.splice(i - 1, 2);\r\n                            i -= 2;\r\n                        }\r\n                    }\r\n                }\r\n                //end trimDots\r\n\r\n                name = name.join(\"/\");\r\n            } else if (name.indexOf(\'./\') === 0) {\r\n                // No baseName, so this is ID is resolved relative\r\n                // to baseUrl, pull off the leading dot.\r\n                name = name.substring(2);\r\n            }\r\n        }\r\n\r\n        //Apply map config if available.\r\n        if ((baseParts || starMap) && map) {\r\n            nameParts = name.split(\'/\');\r\n\r\n            for (i = nameParts.length; i > 0; i -= 1) {\r\n                nameSegment = nameParts.slice(0, i).join(\"/\");\r\n\r\n                if (baseParts) {\r\n                    //Find the longest baseName segment match in the config.\r\n                    //So, do joins on the biggest to smallest lengths of baseParts.\r\n                    for (j = baseParts.length; j > 0; j -= 1) {\r\n                        mapValue = map[baseParts.slice(0, j).join(\'/\')];\r\n\r\n                        //baseName segment has  config, find if it has one for\r\n                        //this name.\r\n                        if (mapValue) {\r\n                            mapValue = mapValue[nameSegment];\r\n                            if (mapValue) {\r\n                                //Match, update name to the new value.\r\n                                foundMap = mapValue;\r\n                                foundI = i;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (foundMap) {\r\n                    break;\r\n                }\r\n\r\n                //Check for a star map match, but just hold on to it,\r\n                //if there is a shorter segment match later in a matching\r\n                //config, then favor over this star map.\r\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\r\n                    foundStarMap = starMap[nameSegment];\r\n                    starI = i;\r\n                }\r\n            }\r\n\r\n            if (!foundMap && foundStarMap) {\r\n                foundMap = foundStarMap;\r\n                foundI = starI;\r\n            }\r\n\r\n            if (foundMap) {\r\n                nameParts.splice(0, foundI, foundMap);\r\n                name = nameParts.join(\'/\');\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    function makeRequire(relName, forceSync) {\r\n        return function () {\r\n            //A version of a require function that passes a moduleName\r\n            //value for items that may need to\r\n            //look up paths relative to the moduleName\r\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\r\n        };\r\n    }\r\n\r\n    function makeNormalize(relName) {\r\n        return function (name) {\r\n            return normalize(name, relName);\r\n        };\r\n    }\r\n\r\n    function makeLoad(depName) {\r\n        return function (value) {\r\n            defined[depName] = value;\r\n        };\r\n    }\r\n\r\n    function callDep(name) {\r\n        if (hasProp(waiting, name)) {\r\n            var args = waiting[name];\r\n            delete waiting[name];\r\n            defining[name] = true;\r\n            main.apply(undef, args);\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\r\n            throw new Error(\'No \' + name);\r\n        }\r\n        return defined[name];\r\n    }\r\n\r\n    //Turns a plugin!resource to [plugin, resource]\r\n    //with the plugin being undefined if the name\r\n    //did not have a plugin prefix.\r\n    function splitPrefix(name) {\r\n        var prefix,\r\n            index = name ? name.indexOf(\'!\') : -1;\r\n        if (index > -1) {\r\n            prefix = name.substring(0, index);\r\n            name = name.substring(index + 1, name.length);\r\n        }\r\n        return [prefix, name];\r\n    }\r\n\r\n    /**\r\n     * Makes a name map, normalizing the name, and using a plugin\r\n     * for normalization if necessary. Grabs a ref to plugin\r\n     * too, as an optimization.\r\n     */\r\n    makeMap = function (name, relName) {\r\n        var plugin,\r\n            parts = splitPrefix(name),\r\n            prefix = parts[0];\r\n\r\n        name = parts[1];\r\n\r\n        if (prefix) {\r\n            prefix = normalize(prefix, relName);\r\n            plugin = callDep(prefix);\r\n        }\r\n\r\n        //Normalize according\r\n        if (prefix) {\r\n            if (plugin && plugin.normalize) {\r\n                name = plugin.normalize(name, makeNormalize(relName));\r\n            } else {\r\n                name = normalize(name, relName);\r\n            }\r\n        } else {\r\n            name = normalize(name, relName);\r\n            parts = splitPrefix(name);\r\n            prefix = parts[0];\r\n            name = parts[1];\r\n            if (prefix) {\r\n                plugin = callDep(prefix);\r\n            }\r\n        }\r\n\r\n        //Using ridiculous property names for space reasons\r\n        return {\r\n            f: prefix ? prefix + \'!\' + name : name, //fullName\r\n            n: name,\r\n            pr: prefix,\r\n            p: plugin\r\n        };\r\n    };\r\n\r\n    function makeConfig(name) {\r\n        return function () {\r\n            return (config && config.config && config.config[name]) || {};\r\n        };\r\n    }\r\n\r\n    handlers = {\r\n        require: function (name) {\r\n            return makeRequire(name);\r\n        },\r\n        exports: function (name) {\r\n            var e = defined[name];\r\n            if (typeof e !== \'undefined\') {\r\n                return e;\r\n            } else {\r\n                return (defined[name] = {});\r\n            }\r\n        },\r\n        module: function (name) {\r\n            return {\r\n                id: name,\r\n                uri: \'\',\r\n                exports: defined[name],\r\n                config: makeConfig(name)\r\n            };\r\n        }\r\n    };\r\n\r\n    main = function (name, deps, callback, relName) {\r\n        var cjsModule, depName, ret, map, i,\r\n            args = [],\r\n            callbackType = typeof callback,\r\n            usingExports;\r\n\r\n        //Use name if no relName\r\n        relName = relName || name;\r\n\r\n        //Call the callback to define the module, if necessary.\r\n        if (callbackType === \'undefined\' || callbackType === \'function\') {\r\n            //Pull out the defined dependencies and pass the ordered\r\n            //values to the callback.\r\n            //Default to [require, exports, module] if no deps\r\n            deps = !deps.length && callback.length ? [\'require\', \'exports\', \'module\'] : deps;\r\n            for (i = 0; i < deps.length; i += 1) {\r\n                map = makeMap(deps[i], relName);\r\n                depName = map.f;\r\n\r\n                //Fast path CommonJS standard dependencies.\r\n                if (depName === \"require\") {\r\n                    args[i] = handlers.require(name);\r\n                } else if (depName === \"exports\") {\r\n                    //CommonJS module spec 1.1\r\n                    args[i] = handlers.exports(name);\r\n                    usingExports = true;\r\n                } else if (depName === \"module\") {\r\n                    //CommonJS module spec 1.1\r\n                    cjsModule = args[i] = handlers.module(name);\r\n                } else if (hasProp(defined, depName) ||\r\n                           hasProp(waiting, depName) ||\r\n                           hasProp(defining, depName)) {\r\n                    args[i] = callDep(depName);\r\n                } else if (map.p) {\r\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\r\n                    args[i] = defined[depName];\r\n                } else {\r\n                    throw new Error(name + \' missing \' + depName);\r\n                }\r\n            }\r\n\r\n            ret = callback ? callback.apply(defined[name], args) : undefined;\r\n\r\n            if (name) {\r\n                //If setting exports via \"module\" is in play,\r\n                //favor that over return value and exports. After that,\r\n                //favor a non-undefined return value over exports use.\r\n                if (cjsModule && cjsModule.exports !== undef &&\r\n                        cjsModule.exports !== defined[name]) {\r\n                    defined[name] = cjsModule.exports;\r\n                } else if (ret !== undef || !usingExports) {\r\n                    //Use the return value from the function.\r\n                    defined[name] = ret;\r\n                }\r\n            }\r\n        } else if (name) {\r\n            //May just be an object definition for the module. Only\r\n            //worry about defining if have a module name.\r\n            defined[name] = callback;\r\n        }\r\n    };\r\n\r\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\r\n        if (typeof deps === \"string\") {\r\n            if (handlers[deps]) {\r\n                //callback in this case is really relName\r\n                return handlers[deps](callback);\r\n            }\r\n            //Just return the module wanted. In this scenario, the\r\n            //deps arg is the module name, and second arg (if passed)\r\n            //is just the relName.\r\n            //Normalize module name, if it contains . or ..\r\n            return callDep(makeMap(deps, callback).f);\r\n        } else if (!deps.splice) {\r\n            //deps is a config object, not an array.\r\n            config = deps;\r\n            if (config.deps) {\r\n                req(config.deps, config.callback);\r\n            }\r\n            if (!callback) {\r\n                return;\r\n            }\r\n\r\n            if (callback.splice) {\r\n                //callback is an array, which means it is a dependency list.\r\n                //Adjust args if there are dependencies\r\n                deps = callback;\r\n                callback = relName;\r\n                relName = null;\r\n            } else {\r\n                deps = undef;\r\n            }\r\n        }\r\n\r\n        //Support require([\'a\'])\r\n        callback = callback || function () {};\r\n\r\n        //If relName is a function, it is an errback handler,\r\n        //so remove it.\r\n        if (typeof relName === \'function\') {\r\n            relName = forceSync;\r\n            forceSync = alt;\r\n        }\r\n\r\n        //Simulate async callback;\r\n        if (forceSync) {\r\n            main(undef, deps, callback, relName);\r\n        } else {\r\n            //Using a non-zero value because of concern for what old browsers\r\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\r\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\r\n            //If want a value immediately, use require(\'id\') instead -- something\r\n            //that works in almond on the global level, but not guaranteed and\r\n            //unlikely to work in other AMD implementations.\r\n            setTimeout(function () {\r\n                main(undef, deps, callback, relName);\r\n            }, 4);\r\n        }\r\n\r\n        return req;\r\n    };\r\n\r\n    /**\r\n     * Just drops the config on the floor, but returns req in case\r\n     * the config return value is used.\r\n     */\r\n    req.config = function (cfg) {\r\n        return req(cfg);\r\n    };\r\n\r\n    /**\r\n     * Expose module registry for debugging and tooling\r\n     */\r\n    requirejs._defined = defined;\r\n\r\n    define = function (name, deps, callback) {\r\n\r\n        //This module may not have dependencies\r\n        if (!deps.splice) {\r\n            //deps is not an array, so probably means\r\n            //an object literal or factory function for\r\n            //the value. Adjust args.\r\n            callback = deps;\r\n            deps = [];\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\r\n            waiting[name] = [name, deps, callback];\r\n        }\r\n    };\r\n\r\n    define.amd = {\r\n        jQuery: true\r\n    };\r\n}());\r\n\n//# sourceURL=/../vendor/almond.js");

define("../vendor/almond", function(){});

eval("define(\'unsafeWindow\',[], function(){\r\n  return window;\r\n});\n//# sourceURL=/unsafeWindow.js");

eval("/**\r\n* A helper class to help checking for features that are supported by the browser.\r\n* @namespace helper\r\n* @class Support\r\n**/\r\ndefine(\'helper/support\',[\"exports\", \"unsafeWindow\"], function(exports, uw){\r\n  /**\r\n  * Performing a simple LocalStorage set, get test.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method localStorageTest\r\n  * @return {Boolean} Returns true if LocalStorage is supported otherwise returns false.\r\n  **/\r\n  function localStorageTest() {\r\n    var mod = \"support.test\";\r\n    try {\r\n      localStorage.setItem(mod, mod);\r\n      localStorage.removeItem(mod);\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Checking if `webkitURL` is an object.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isWebkitURL\r\n  * @type Boolean\r\n  **/\r\n  var isWebkitURL = typeof uw.webkitURL === \"object\";\r\n  \r\n  /**\r\n  * Checking if `URL` is an object.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isURL\r\n  * @type Boolean\r\n  **/\r\n  var isURL = typeof uw.URL === \"object\";\r\n  \r\n  /**\r\n  * Checking if Maxthon runtime is accessible.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property maxthonRuntime\r\n  * @type Boolean\r\n  **/\r\n  var maxthonRuntime = window && window.external && window.external.mxGetRuntime && typeof window.external.mxGetRuntime === \"function\";\r\n  \r\n  /**\r\n  * Checking if `createObjectURL` is supported.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isCreateObjectURL\r\n  * @type Boolean\r\n  **/\r\n  var isCreateObjectURL = false;\r\n  \r\n  /**\r\n  * Checking if `revokeObjectURL` is supported.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isRevokeObjectURL\r\n  * @type Boolean\r\n  **/\r\n  var isRevokeObjectURL = false;\r\n  if (isWebkitURL) {\r\n    isCreateObjectURL = typeof uw.webkitURL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.webkitURL.revokeObjectURL === \"function\";\r\n  } else if (isURL) {\r\n    isCreateObjectURL = typeof uw.URL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.URL.revokeObjectURL === \"function\";\r\n  }\r\n  \r\n  /**\r\n  * Checking if LocalStorage is supported.\r\n  *\r\n  * @static\r\n  * @property localStorage\r\n  * @type Boolean\r\n  **/\r\n  exports.localStorage = localStorageTest();\r\n  \r\n  /**\r\n  * Checking if the Greasemonkey API is supported.\r\n  *\r\n  * @static\r\n  * @property Greasemonkey\r\n  * @type Boolean\r\n  **/\r\n  exports.Greasemonkey = (typeof GM_setValue !== \"undefined\" && (typeof GM_setValue.toString === \"undefined\" || GM_setValue.toString().indexOf(\"not supported\") === -1));\r\n  \r\n  /**\r\n  * Checking if `createObjectUR` is supported.\r\n  *\r\n  * @static\r\n  * @property createObjectURL\r\n  * @type Boolean\r\n  **/\r\n  exports.createObjectURL = isCreateObjectURL;\r\n  \r\n  /**\r\n  * Checking if `revokeObjectURL` is supported.\r\n  *\r\n  * @static\r\n  * @property revokeObjectURL\r\n  * @type Boolean\r\n  **/\r\n  exports.revokeObjectURL = isRevokeObjectURL;\r\n  \r\n  /**\r\n  * Checking if the `webkitURL` object is supported.\r\n  *\r\n  * @static\r\n  * @property webkitURL\r\n  * @type Boolean\r\n  **/\r\n  exports.webkitURL = isWebkitURL;\r\n  \r\n  /**\r\n  * Checking if the `URL` object is supported.\r\n  *\r\n  * @static\r\n  * @property URL\r\n  * @type Boolean\r\n  **/\r\n  exports.URL = isURL;\r\n  \r\n  /**\r\n  * Checking if Maxthon runtime is supported.\r\n  *\r\n  * @static\r\n  * @property maxthonRuntime\r\n  * @type Boolean\r\n  **/\r\n  exports.maxthonRuntime = maxthonRuntime;\r\n  \r\n  /**\r\n  * Checking if Maxthon runtime Storage object is supported.\r\n  *\r\n  * @static\r\n  * @property maxthonRuntimeStorage\r\n  * @type Boolean\r\n  **/\r\n  exports.maxthonRuntimeStorage = maxthonRuntime && window.external.mxGetRuntime() && window.external.mxGetRuntime().storage;\r\n  \r\n  /**\r\n  * Checking if Firefox extension port is accessible.\r\n  *\r\n  * @static\r\n  * @property firefoxPort\r\n  * @type Boolean\r\n  **/\r\n  exports.firefoxPort = this.port && typeof this.port.request === \"function\" && this.port.storage && typeof this.port.on === \"function\";\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/helper/support.js");

eval("/**\r\n* @class Utils\r\n**/\r\ndefine(\'utils\',[\"exports\", \"./helper/support\", \"unsafeWindow\"], function(exports, support, uw){\r\n  function each(obj, callback) {\r\n    if (isArray(obj)) {\r\n      for (var i = 0; i < obj.length; i++) {\r\n        if (callback(i, obj[i]) === true) break;\r\n      }\r\n    } else {\r\n      for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          if (callback(key, obj[key]) === true) break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n  }\r\n  \r\n  function asyncCall(scope, callback) {\r\n    return setTimeout(bind.apply(null, [scope, callback].concat(Array.prototype.slice.call(arguments, 2))), 0);\r\n  }\r\n  \r\n  function bind(scope, func) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    return function(){\r\n      return func.apply(scope, args.concat(Array.prototype.slice.call(arguments)))\r\n    };\r\n  }\r\n  \r\n  function trimLeft(obj){\r\n    return obj.replace(/^\\s+/, \"\");\r\n  }\r\n  \r\n  function trimRight(obj){\r\n    return obj.replace(/\\s+$/, \"\");\r\n  }\r\n  \r\n  function map(obj, callback, thisArg) {\r\n    for (var i = 0, n = obj.length, a = []; i < n; i++) {\r\n      if (i in obj) a[i] = callback.call(thisArg, obj[i]);\r\n    }\r\n    return a;\r\n  }\r\n  \r\n  /**\r\n  * Define a property with a getter and a setter.\r\n  *\r\n  * @method defineProperty\r\n  * @param {Object} obj The object where the property resides in.\r\n  * @param {String} key The name of the property.\r\n  * @param {Function} get The getter function.\r\n  * @param {Function} set The setter function.\r\n  **/\r\n  function defineProperty(obj, key, get, set) {\r\n    if (Object && typeof Object.defineProperty === \"function\") {\r\n      Object.defineProperty(obj, key, {\r\n        \"get\": get,\r\n        \"set\": set\r\n      });\r\n    } else {\r\n      obj.__defineGetter__(key, get);\r\n      obj.__defineSetter__(key, set);\r\n    }\r\n  }\r\n  \r\n  function defineLockedProperty(obj, key, setter, getter) {\r\n    if (typeof obj !== \"object\") obj = {};\r\n    if (support.ie || typeof Object.defineProperty === \"function\") {\r\n      Object.defineProperty(obj, key, {\r\n        get: getter,\r\n        set: setter\r\n      });\r\n      return obj;\r\n    } else {\r\n      obj.__defineGetter__(key, getter);\r\n      obj.__defineSetter__(key, setter);\r\n      return obj;\r\n    }\r\n  }\r\n  \r\n  function addEventListener(elm, event, callback, useCapture) {\r\n    if (elm.addEventListener) {\r\n      elm.addEventListener(event, callback, useCapture || false);\r\n    } else if (elm.attachEvent) {\r\n      elm.attachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  function removeEventListener(elm, event, callback, useCapture) {\r\n    if (elm.removeEventListener) {\r\n      elm.removeEventListener(event, callback, useCapture || false);\r\n    } else if (elm.detachEvent) {\r\n      elm.detachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  var now = Date.now || function () {\r\n    return +new Date;\r\n  };\r\n  \r\n  /* Cookies */\r\n  function setCookie(name, value, domain, path, expires) {\r\n    domain = domain ? \";domain=\" + encodeURIComponent(domain) : \"\";\r\n    path = path ? \";path=\" + encodeURIComponent(path) : \"\";\r\n    expires = 0 > expires ? \"\" : 0 == expires ? \";expires=\" + (new Date(1970, 1, 1)).toUTCString() : \";expires=\" + (new Date(now() + 1E3 * expires)).toUTCString();\r\n    \r\n    document.cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value) + domain + path + expires;\r\n  }\r\n  \r\n  function getCookie(key) {\r\n    return getCookies()[key];\r\n  }\r\n  \r\n  function getCookies() {\r\n    var c = document.cookie, v = 0, cookies = {};\r\n    if (document.cookie.match(/^\\s*\\$Version=(?:\"1\"|1);\\s*(.*)/)) {\r\n      c = RegExp.$1;\r\n      v = 1;\r\n    }\r\n    if (v === 0) {\r\n      map(c.split(/[,;]/), function(cookie) {\r\n        var parts = cookie.split(/=/, 2),\r\n            name = decodeURIComponent(trimLeft(parts[0])),\r\n            value = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;\r\n        cookies[name] = value;\r\n      });\r\n    } else {\r\n      map(c.match(/(?:^|\\s+)([!#$%&\'*+\\-.0-9A-Z^`a-z|~]+)=([!#$%&\'*+\\-.0-9A-Z^`a-z|~]*|\"(?:[\\x20-\\x7E\\x80\\xFF]|\\\\[\\x00-\\x7F])*\")(?=\\s*[,;]|$)/g), function($0, $1) {\r\n        var name = $0, value = $1.charAt(0) === \'\"\' ? $1.substr(1, -1).replace(/\\\\(.)/g, \"$1\") : $1;\r\n        cookies[name] = value;\r\n      });\r\n    }\r\n    return cookies;\r\n  }\r\n  \r\n  function endsWith(str, suffix) {\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n  }\r\n  \r\n  function inject(func) {\r\n    var script = document.createElement(\"script\"),\r\n        p = (document.body || document.head || document.documentElement);\r\n    if (!p) {\r\n      throw \"Could not inject!!!\";\r\n    }\r\n    script.setAttribute(\"type\", \"text/javascript\");\r\n    script.appendChild(document.createTextNode(\"(\" + func + \")(\" + buildArgumentList.apply(null, [false].concat(Array.prototype.slice.call(arguments, 1))) + \");\"));\r\n    p.appendChild(script);\r\n    p.removeChild(script);\r\n  }\r\n  \r\n  function buildArgumentList(wrap) {\r\n    var list = [];\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    \r\n    for (var i = 0, len = args.length; i < len; i++) {\r\n      if (typeof args[i] === \"string\") {\r\n        list.push(\"\\\"\" + args[i].replace(/\\\\/, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\");\r\n      } else if (typeof args[i] === \"object\") {\r\n        list.push(JSON.stringify(args[i]));\r\n      } else if (typeof args[i] === \"undefined\") {\r\n        list.push(\"null\");\r\n      } else {\r\n        list.push(args[i]);\r\n      }\r\n    }\r\n    if (wrap) {\r\n      return \"(\" + list.join(\",\") + \")\";\r\n    } else {\r\n      return list.join(\",\");\r\n    }\r\n  }\r\n  \r\n  function isJSONString(json) {\r\n    try {\r\n      JSON.parse(json);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function xhr(details) {\r\n    var xmlhttp;\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new XMLHttpRequest();\r\n    } else if (typeof opera !== \"undefined\" && typeof opera.XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new opera.XMLHttpRequest();\r\n    } else {\r\n      if (details[\"onerror\"]) {\r\n        details[\"onerror\"]();\r\n      }\r\n      \r\n      return;\r\n    }\r\n    xmlhttp.onreadystatechange = function(){\r\n      var responseState = {\r\n        responseXML:(xmlhttp.readyState == 4 ? xmlhttp.responseXML : \'\'),\r\n        responseText:(xmlhttp.readyState == 4 ? xmlhttp.responseText : \'\'),\r\n        readyState:xmlhttp.readyState,\r\n        responseHeaders:(xmlhttp.readyState == 4 ? xmlhttp.getAllResponseHeaders() : \'\'),\r\n        status:(xmlhttp.readyState == 4 ? xmlhttp.status : 0),\r\n        statusText:(xmlhttp.readyState == 4 ? xmlhttp.statusText : \'\'),\r\n        finalUrl:(xmlhttp.readyState == 4 ? xmlhttp.finalUrl : \'\')\r\n      };\r\n      if (details[\"onreadystatechange\"]) {\r\n        details[\"onreadystatechange\"](responseState);\r\n      }\r\n      if (xmlhttp.readyState == 4) {\r\n        if (details[\"onload\"] && xmlhttp.status >= 200 && xmlhttp.status < 300) {\r\n          details[\"onload\"](responseState);\r\n        }\r\n        if (details[\"onerror\"] && (xmlhttp.status < 200 || xmlhttp.status >= 300)) {\r\n          details[\"onerror\"](responseState);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      xmlhttp.open(details.method, details.url);\r\n    } catch(e) {\r\n      if(details[\"onerror\"]) {\r\n        details[\"onerror\"]({responseXML:\'\',responseText:\'\',readyState:4,responseHeaders:\'\',status:403,statusText:\'Forbidden\'});\r\n      }\r\n      return;\r\n    }\r\n    if (details.headers) {\r\n      for (var prop in details.headers) {\r\n        xmlhttp.setRequestHeader(prop, details.headers[prop]);\r\n      }\r\n    }\r\n    xmlhttp.send((typeof(details.data) != \'undefined\') ? details.data : null);\r\n  }\r\n  \r\n  // Used for the message module (should probably move to another place)\r\n  // It replaces a property in the obj to a predefined function, where the arguments will be callbackId, target, referer\r\n  function bindFunctionCallbacks(obj, func, target, referer) {\r\n    for (key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"obj\") {\r\n          bindFunctionCallbacks(obj[key]);\r\n        } else if (typeof obj[key] === \"string\") {\r\n          if (obj[key].indexOf(\"@/(message.callback)/\") === 0) {\r\n            var callbackId = obj[key].split(\"@/(message.callback)/\")[1];\r\n            obj[key] = bind(null, func, callbackId, target, referer);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function extend(obj, defaults, deep) {\r\n    if (typeof obj !== \"object\") throw new TypeError(\"Unsupported type for obj.\");\r\n    if (typeof defaults !== \"object\") throw new TypeError(\"Unsupported type for defaults.\");\r\n    \r\n    for (var key in defaults) {\r\n      if (defaults.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"object\" && typeof defaults[key] === \"object\" && deep) {\r\n          extend(obj[key], defaults[key], deep);\r\n        } else if (!obj.hasOwnProperty(key)) {\r\n          obj[key] = defaults[key];\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function inArray(key, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function listClasses(el) {\r\n    if (!el || !el.className) return [];\r\n    return el.className.split(\" \");\r\n  }\r\n  \r\n  function addClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var addList = className.split(\" \");\r\n    \r\n    for (var i = 0, len = addList.length; i < len; i++) {\r\n      if (!inArray(addList[i], classes)) {\r\n        el.className += \" \" + addList[i];\r\n      }\r\n    }\r\n    return el.className;\r\n  }\r\n  \r\n  function removeClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var removeList = className.split(\" \");\r\n    \r\n    var buffer = [];\r\n    for (var i = 0, len = classes.length; i < len; i++) {\r\n      if (!inArray(classes[i], removeList)) {\r\n        buffer.push(classes[i]);\r\n      }\r\n    }\r\n    return el.className = buffer.join(\" \");\r\n  }\r\n  \r\n  function hasClass(el, className) {\r\n    return inArray(className, listClasses(el));\r\n  }\r\n  \r\n  function throttle(func, delay, options){\r\n    function timeout() {\r\n      previous = options.leading === false ? 0 : new Date;\r\n      timer = null;\r\n      result = func.apply(context, args);\r\n    }\r\n    var context, args, result, timer = null, previous = 0;\r\n    options = options || {};\r\n    return function(){\r\n      var now = new Date, dt;\r\n      \r\n      context = this;\r\n      args = arguments;\r\n      \r\n      if (!previous && options.leading === false) previous = now;\r\n      dt = delay - (now - previous);\r\n      \r\n      if (dt <= 0) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n        previous = now;\r\n        result = func.apply(context, args);\r\n      } else if (!timer && options.trailing !== false) {\r\n        timer = setTimeout(timeout, dt);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n  \r\n  function clone(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n  \r\n  function removeDuplicates(arr) {\r\n    var uniqueArr = [];\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (!inArray(uniqueArr, arr[i])) {\r\n        uniqueArr.push(arr[i]);\r\n      }\r\n    }\r\n    \r\n    return uniqueArr;\r\n  }\r\n  \r\n  function escapeRegExp(str) {\r\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n  }\r\n  \r\n  function toBlob(bytes, contentType) {\r\n    contentType = contentType || \"text/plain\";\r\n    var sliceSize = 512;\r\n    \r\n    var bytesLength = bytes.length;\r\n    var slicesCount = Math.ceil(bytesLength / sliceSize);\r\n    \r\n    var byteArrays = new Array(slicesCount);\r\n    \r\n    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\r\n      var begin = sliceIndex * sliceSize;\r\n      var end = Math.min(begin + sliceSize, bytesLength);\r\n      \r\n      var sliceBytes = new Array(end - begin);\r\n      for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {\r\n        sliceBytes[i] = bytes[offset].charCodeAt(0);\r\n      }\r\n      byteArrays[sliceIndex] = new Uint8Array(sliceBytes);\r\n    }\r\n    \r\n    return new Blob(byteArrays, { type: contentType });\r\n  }\r\n  \r\n  function createObjectURL(blob) {\r\n    if (support.createObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.createObjectURL(blob);\r\n      } else {\r\n        return uw.URL.createObjectURL(blob);\r\n      }\r\n    } else {\r\n      throw \"createObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  function revokeObjectURL(url) {\r\n    if (support.revokeObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.revokeObjectURL(url);\r\n      } else {\r\n        return uw.URL.revokeObjectURL(url);\r\n      }\r\n    } else {\r\n      throw \"revokeObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  // Returns a random number between min and max\r\n  function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n  \r\n  // Returns a random integer between min (included) and max (excluded)\r\n  function getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n  \r\n  // Returns a random string of characters of chars with the length of length\r\n  function generateToken(chars, length) {\r\n    if (typeof chars !== \"string\") chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\";\r\n    if (typeof length !== \"number\") length = 64;\r\n    \r\n    var charsLength = chars.length;\r\n    \r\n    var token = \"\";\r\n    for (var i = 0; i < length; i++) {\r\n      token += chars[getRandomInt(0, charsLength)];\r\n    }\r\n    \r\n    return token;\r\n  }\r\n  \r\n  function escapeECMAVariable(key, defaultKey) {\r\n    key = key.replace(/[^0-9a-zA-Z_\\$]/g, \"\");\r\n    while (/$[0-9]/g.test(key) && key.length > 0) {\r\n      if (key === \"\") return defaultKey;\r\n      key = key.substring(1);\r\n    }\r\n    return key;\r\n  }\r\n  \r\n  function indexOfArray(value, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === value) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n  \r\n  function getKeys(obj) {\r\n    var keys = [];\r\n    each(obj, function(key){\r\n      keys.push(key);\r\n    });\r\n    return keys;\r\n  }\r\n  \r\n  function setProperty(target, path, value, createPath) {\r\n    var tokens = path.split(\".\");\r\n    for (var i = 0, len = tokens.length - 1; i < len; i++) {\r\n      if (target[tokens[i]]) {\r\n        target = target[tokens[i]];\r\n      } else {\r\n        if (createPath) {\r\n          target[tokens[i]] = {};\r\n          target = target[tokens[i]];\r\n        } else {\r\n          throw \"Path \" + path + \" does not exist for\", target;\r\n        }\r\n      }\r\n    }\r\n    target[tokens[tokens.length - 1]] = value;\r\n  }\r\n  \r\n  /**\r\n  * Replaces each format item in a specified string with the text equivalent of a corresponding object\'s value.\r\n  *\r\n  * @static\r\n  * @method format\r\n  * @param {String} format A composite format string that includes one or more format items.\r\n  * @param {any} [args]* The object to format.\r\n  * @return {String} The string with each format item inserted.\r\n  **/\r\n  /**\r\n  * Replaces each token in a specified string with the text equivalent of a corresponding key\'s value.\r\n  *\r\n  * @static\r\n  * @method format\r\n  * @param {String} format A composite format string that includes one or more token items.\r\n  * @param {Object} map The key, value pairs that will be replacing the tokens.\r\n  * @return {String} The formatted string.\r\n  **/\r\n  function format(format) {\r\n    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\r\n      var map = arguments[1];\r\n      return format.replace(/\\${([\\w\\-\\_]+)}/g, function(match, key) { \r\n        return typeof map[key] !== \"undefined\" ? map[key] : match;\r\n      });\r\n    } else {\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      return format.replace(/{(\\d+)}/g, function(match, index) { \r\n        return typeof args[index] !== \"undefined\" ? args[index] : match;\r\n      });\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Calculate the absolute position of an element.\r\n  *\r\n  * @static\r\n  * @method getAbsolutePosition\r\n  * @param {HTMLElement} el The element.\r\n  * @return {Object} An object with the properties left and top\r\n  *                  where top and left tell the position of the\r\n  *                  element from the top-left corner in pixels.\r\n  **/\r\n  function getAbsolutePosition(el) {\r\n    var left = el.offsetLeft || 0;\r\n    var top = el.offsetTop || 0;\r\n    \r\n    if (el.offsetParent) {\r\n      var parentAbsolutePosition = getAbsolutePosition(el.offsetParent);\r\n      left += parentAbsolutePosition.left;\r\n      top += parentAbsolutePosition.top;\r\n    }\r\n    \r\n    return { left: left, top: top }; \r\n  }\r\n  \r\n  // Expose functions\r\n  exports.getAbsolutePosition = getAbsolutePosition;\r\n  exports.format = format;\r\n  exports.hasClass = hasClass;\r\n  exports.removeClass = removeClass;\r\n  exports.addClass = addClass;\r\n  exports.each = each;\r\n  exports.isArray = isArray;\r\n  exports.inArray = inArray;\r\n  exports.bind = bind;\r\n  exports.asyncCall = asyncCall;\r\n  exports.defineLockedProperty = defineLockedProperty;\r\n  exports.addEventListener = addEventListener;\r\n  exports.removeEventListener = removeEventListener;\r\n  exports.now = now;\r\n  exports.trimLeft = trimLeft;\r\n  exports.trimRight = trimRight;\r\n  exports.map = map;\r\n  exports.setCookie = setCookie;\r\n  exports.getCookie = getCookie;\r\n  exports.getCookies = getCookies;\r\n  exports.endsWith = endsWith;\r\n  exports.inject = inject;\r\n  exports.isJSONString = isJSONString;\r\n  exports.xhr = xhr;\r\n  exports.buildArgumentList = buildArgumentList;\r\n  exports.bindFunctionCallbacks = bindFunctionCallbacks;\r\n  exports.extend = extend;\r\n  exports.throttle = throttle;\r\n  exports.clone = clone;\r\n  exports.removeDuplicates = removeDuplicates;\r\n  exports.escapeRegExp = escapeRegExp;\r\n  exports.toBlob = toBlob;\r\n  exports.createObjectURL = createObjectURL;\r\n  exports.revokeObjectURL = revokeObjectURL;\r\n  exports.getRandomArbitrary = getRandomArbitrary;\r\n  exports.getRandomInt = getRandomInt;\r\n  exports.generateToken = generateToken;\r\n  exports.escapeECMAVariable = escapeECMAVariable;\r\n  exports.indexOfArray = indexOfArray;\r\n  exports.getKeys = getKeys;\r\n  exports.setProperty = setProperty;\r\n  exports.defineProperty = defineProperty;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/utils.js");

eval("/**\r\n* The player API\r\n*\r\n* @namespace Player\r\n* @class API\r\n**/\r\ndefine(\'player/api\',[\"exports\", \"utils\"], function(exports, utils){\r\n  /**\r\n  * Get the player API.\r\n  *\r\n  * @static\r\n  * @method getAPI\r\n  * @return {Object} The player API.\r\n  **/\r\n  function getAPI() {\r\n    if (!apiCache) {\r\n      apiCache = bindPlayerAPI();\r\n    }\r\n    return apiCache;\r\n  }\r\n  \r\n  /**\r\n  * Set the player API.\r\n  *\r\n  * @static\r\n  * @method setAPI\r\n  * @param {Object} api The player API.\r\n  **/\r\n  function setAPI(api) {\r\n    apiCache = api;\r\n  }\r\n  \r\n  /**\r\n  * Bind the player API from the #movie_player element\r\n  * into an object.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method bindPlayerAPI\r\n  * @return {Object} The player API.\r\n  **/\r\n  function bindPlayerAPI() {\r\n    var player = document.getElementById(\"movie_player\");\r\n    var api = {};\r\n    \r\n    if (player && player.getApiInterface) {\r\n      var apiInterface = player.getApiInterface();\r\n      for (var i = 0, len = apiInterface.length; i < len; i++) {\r\n        api[apiInterface[i]] = utils.bind(player, player[apiInterface[i]]);\r\n      }\r\n    }\r\n    return api;\r\n  }\r\n  \r\n  /**\r\n  * The cached player API.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property apiCache\r\n  * @type Object\r\n  **/\r\n  var apiCache = null;\r\n  \r\n  exports.getAPI = getAPI;\r\n  exports.setAPI = setAPI;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/api.js");

eval("define(\'console\',[\"exports\", \"utils\"], function(exports, utils){\r\n  function setEnabled(b) {\r\n    enabled = b;\r\n  }\r\n  \r\n  function log() {\r\n    if (!enabled) return function(){};\r\n    return console.log.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function error() {\r\n    if (!enabled) return function(){};\r\n    return console.error.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function warn() {\r\n    if (!enabled) return function(){};\r\n    return console.warn.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function debug() {\r\n    if (!enabled) return function(){};\r\n    return console.debug.bind(console, \"injected[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  var sessionToken = (typeof consoleSessionToken === \"string\" ? consoleSessionToken : utils.generateToken(null, 8));\r\n  \r\n  var enabled = true;\r\n  \r\n  exports.sessionToken = sessionToken;\r\n  \r\n  utils.defineLockedProperty(exports, \"log\", function(){}, log);\r\n  utils.defineLockedProperty(exports, \"error\", function(){}, error);\r\n  utils.defineLockedProperty(exports, \"warn\", function(){}, warn);\r\n  utils.defineLockedProperty(exports, \"debug\", function(){}, debug);\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/console.js");

eval("/**\r\n* Handles the player configuration.\r\n*\r\n* @namespace Player\r\n* @class Config\r\n**/\r\ndefine(\'player/config\',[\"exports\", \"utils\", \"unsafeWindow\", \"console\"], function(exports, utils, uw, con){\r\n  /**\r\n  * Get the configuration for the player.\r\n  *\r\n  * @static\r\n  * @method getConfig\r\n  * @return {Object} The player configuration.\r\n  **/\r\n  function getConfig() {\r\n    return config;\r\n  }\r\n  \r\n  /**\r\n  * Set the configuration of the player.\r\n  *\r\n  * @static\r\n  * @method SetConfig\r\n  * @param {Object} cfg The configuration object.\r\n  **/\r\n  \r\n  /**\r\n  * Set a property for the configuration of the player.\r\n  *\r\n  * @static\r\n  * @method SetConfig\r\n  * @param {String} key The name of the property.\r\n  * @param {any} value The value of the property.\r\n  **/\r\n  function setConfig(cfg, value) {\r\n    if (typeof cfg === \"string\") {\r\n      utils.setProperty(config, cfg, value, true);\r\n    } else {\r\n      config = cfg;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Set the persistent configuration of the player.\r\n  *\r\n  * @static\r\n  * @method setPersistentConfig\r\n  * @param {Object} cfg The configuration object.\r\n  **/\r\n  \r\n  /**\r\n  * Set a property for the persistent configuration of the player.\r\n  *\r\n  * @static\r\n  * @method setPersistentConfig\r\n  * @param {String} key The name of the property.\r\n  * @param {any} value The value of the property.\r\n  **/\r\n  function setPersistentConfig(cfg, value) {\r\n    if (typeof cfg === \"string\") {\r\n      utils.setProperty(persistentConfig, cfg, value, true);\r\n    } else {\r\n      persistentConfig = cfg;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Get the persistent configuration for the player.\r\n  *\r\n  * @static\r\n  * @method getPersistentConfig\r\n  * @return {Object} The persistent player configuration.\r\n  **/\r\n  function getPersistentConfig() {\r\n    return persistentConfig;\r\n  }\r\n  \r\n  /**\r\n  * The config setter function for `uw.ytplayer`.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method configSetter\r\n  * @param {Object} cfg The configuration object.\r\n  **/\r\n  function configSetter(cfg) {\r\n    setConfig(cfg); // set the configuration. Keep the reference\r\n  }\r\n  \r\n  /**\r\n  * The config getter function for `uw.ytplayer`.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method configGetter\r\n  * @return {Object} Returns persistent config and the default config merged.\r\n  **/\r\n  function configGetter() {\r\n    var cfg = getConfig();\r\n    if (!cfg) return cfg;\r\n    cfg = utils.clone(cfg);\r\n    var persistentCfg = utils.clone(persistentConfig);\r\n    utils.extend(persistentCfg, cfg, true);\r\n    return persistentCfg;\r\n  }\r\n  \r\n  /**\r\n  * The configuration of the player.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property config\r\n  * @type Object\r\n  **/\r\n  var config = {};\r\n  \r\n  /**\r\n  * The persistent configuration of the player.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property persistentConfig\r\n  * @type Object\r\n  **/\r\n  var persistentConfig = {};\r\n  \r\n  // Make sure that ytplayer variable is set\r\n  uw.ytplayer = uw.ytplayer || {};\r\n  \r\n  config = uw.ytplayer.config || {};\r\n  \r\n  // Make sure that YouTube doesn\'t override the ytplayer variable or adding an unwanted property to ytplayer.\r\n  utils.defineLockedProperty(uw.ytplayer, \"config\", configSetter, configGetter);\r\n  \r\n  exports.getConfig = getConfig;\r\n  exports.setConfig = setConfig;\r\n  exports.setPersistentConfig = setPersistentConfig;\r\n  exports.getPersistentConfig = getPersistentConfig;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/config.js");

eval("define(\'unsafeYouTubeCenter\',[\"unsafeWindow\"], function(uw){\r\n  var ytcenter = {};\r\n  ytcenter.player = {};\r\n  \r\n  uw.ytcenter = ytcenter;\r\n  \r\n  return ytcenter;\r\n});\n//# sourceURL=/unsafeYouTubeCenter.js");

eval("define(\'player/onYouTubePlayerReady\',[\"exports\", \"unsafeWindow\", \"./api\", \"./config\", \"utils\", \"unsafeYouTubeCenter\", \"../console\"], function(exports, uw, playerAPI, config, utils, uytc, con){\r\n  function onPlayerReady(api) {\r\n    con.debug(\"Player is ready\");\r\n    playerAPI.setAPI(api);\r\n    \r\n    if (typeof api === \"object\") {\r\n      for (var i = 0, len = listeners.length; i < len; i++) {\r\n        listeners[i].apply(null, arguments);\r\n      }\r\n    }\r\n  }\r\n  \r\n  function addListener(callback) {\r\n    listeners.push(callback);\r\n  }\r\n  \r\n  function removeListener(callback) {\r\n    for (var i = 0, len = listeners.length; i < len; i++) {\r\n      if (listeners[i] === callback) {\r\n        listeners.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  function onDelayed() {\r\n    con.debug(\"Using delayed method\");\r\n    var api = playerAPI.getAPI();\r\n    if (api && typeof api.getPlayerState === \"function\") {\r\n      try {\r\n        api.getPlayerState();\r\n      } catch (e) {\r\n        setTimeout(onDelayed, 500);\r\n        return;\r\n      }\r\n      onPlayerReady(api);\r\n    }\r\n  }\r\n  \r\n  var listeners = [];\r\n  \r\n  config.setPersistentConfig(\"args.jsapicallback\", \"ytcenter.player.onReady\");\r\n  uytc.player.onReady = utils.bind(this, onPlayerReady);\r\n  uw.onYouTubePlayerReady = onPlayerReady;\r\n  \r\n  var cfg = config.getConfig();\r\n  if (cfg.loaded) {\r\n    onDelayed();\r\n  }\r\n  \r\n  exports.addListener = addListener;\r\n  exports.removeListener = removeListener;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/onYouTubePlayerReady.js");

eval("define(\'pageload\',[\"utils\", \"console\"], function(utils, con){\r\n  function addEventListener(event, callback) {\r\n    if (!listeners.hasOwnProperty(event)) {\r\n      listeners[event] = [];\r\n    }\r\n    listeners[event].push(callback);\r\n    \r\n    // Make sure the added event listener is executed!\r\n    var readyState = pageStates.indexOf(event);\r\n    if (readyState <= lastState) {\r\n      callback();\r\n    }\r\n  }\r\n  \r\n  function removeEventListener(event, callback) {\r\n    if (!listeners.hasOwnProperty(event)) {\r\n      return;\r\n    }\r\n    var l = listeners[event];\r\n    for (var i = 0, len = l.length; i < len; i++) {\r\n      if (l[i] === callback) {\r\n        l[i].splice(i, 1);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  \r\n  function callListeners(event) {\r\n    var list = listeners[event];\r\n    for (var i = 0, len = list.length; i < len; i++) {\r\n      list[i]();\r\n    }\r\n  }\r\n  \r\n  function update() {\r\n    var readyState = pageStates.indexOf(document.readyState);\r\n    \r\n    for (var i = 0, len = pageStates.length; i < len; i++) {\r\n      if (lastState < i && i <= readyState && utils.isArray(listeners[pageStates[i]])) {\r\n        callListeners(pageStates[i]);\r\n      }\r\n    }\r\n    \r\n    lastState = readyState;\r\n  }\r\n  \r\n  function init() {\r\n    utils.addEventListener(document, \"readystatechange\", update, true);\r\n    utils.addEventListener(document, \"DOMContentLoaded\", update, true);\r\n    update();\r\n  }\r\n  \r\n  var listeners = {};\r\n  var pageStates = [\"uninitialized\", \"loading\", \"interactive\", \"complete\"];\r\n  var lastState = -1;\r\n  \r\n  init();\r\n  \r\n  return {\r\n    addEventListener: addEventListener,\r\n    removeEventListener: removeEventListener\r\n  };\r\n});\n//# sourceURL=/pageload.js");

eval("define(\'ytready\',[\"exports\", \"./pageload\", \"unsafeWindow\"], function(exports, pageload, uw){\r\n  function addEventListener(path, callback) {\r\n    if (!paths[path]) paths[path] = [];\r\n    paths[path].push(callback);\r\n    \r\n    update();\r\n  }\r\n  \r\n  function removeEventListener(path, callback) {\r\n    if (!paths[path]) return;\r\n    for (var i = 0, len = paths[path].length; i < len; i++) {\r\n      if (paths[path][i] === callback) {\r\n        paths[path].splice(i, 1);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Checks if the path in unsafeWindow is defined.\r\n  *\r\n  * @method propertyExists\r\n  * @param {String} path The path to the property.\r\n  * @return {Boolean} Returns true if the property exists otherwise false.\r\n  **/\r\n  function propertyExists(path) {\r\n    var tokens = path.split(\".\");\r\n    \r\n    var target = uw;\r\n    \r\n    for (var i = 0, len = tokens.length; i < len; i++) {\r\n      if (target[tokens[i]]) {\r\n        target = target[tokens[i]];\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * Checks if the added path listeners exist\r\n  * and if they do then call the callbacks\r\n  * for that specific path listener.\r\n  *\r\n  * @method update\r\n  **/\r\n  function update() {\r\n    for (var path in paths) {\r\n      if (paths[path]) {\r\n        if (propertyExists(path)) {\r\n          var callbacks = paths[path];\r\n          for (var i = 0, len = callbacks.length; i < len; i++) {\r\n            callbacks[i]();\r\n          }\r\n          paths[path] = null;\r\n        }\r\n      }\r\n    }\r\n    timerUpdate();\r\n  }\r\n  \r\n  function isWorking() {\r\n    for (var path in paths) {\r\n      if (paths[path]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function timerUpdate() {\r\n    clearTimeout(timer);\r\n    if (isWorking()) {\r\n      setTimeout(update, timerInterval);\r\n    }\r\n  }\r\n  \r\n  var timerInterval = 1000;\r\n  \r\n  var timer = null;\r\n  var paths = { };\r\n  \r\n  // Attach the update to the page load.\r\n  pageload.addEventListener(\"uninitialized\", update);\r\n  pageload.addEventListener(\"loading\", update);\r\n  pageload.addEventListener(\"interactive\", update);\r\n  pageload.addEventListener(\"complete\", update);\r\n  \r\n  \r\n  /* Exports */\r\n  exports.addEventListener = addEventListener;\r\n  exports.removeEventListener = removeEventListener;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/ytready.js");

eval("/**\r\n* An enum for the caller origin.\r\n*\r\n* @namespace Player.Listeners\r\n* @class Origins\r\n**/\r\ndefine(\'player/listeners/origins\',[\"exports\"], function(exports){\r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property PLAYER\r\n  * @type Number\r\n  **/\r\n  exports.PLAYER = 0;\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property PROPERTY\r\n  * @type Number\r\n  **/\r\n  exports.PROPERTY = 1;\r\n  \r\n  return exports;\r\n})\n//# sourceURL=/player/listeners/origins.js");

eval("/**\r\n* The events for the player listener.\r\n*\r\n* @namespace Player.Listeners\r\n* @class Events\r\n**/\r\ndefine(\'player/listeners/events\',[\"exports\"], function(exports){\r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onApiChange\r\n  * @type String\r\n  **/\r\n  exports.onApiChange = \"onApiChange\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onCueRangeEnter\r\n  * @type String\r\n  **/\r\n  exports.onCueRangeEnter = \"onCueRangeEnter\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onCueRangeExit\r\n  * @type String\r\n  **/\r\n  exports.onCueRangeExit = \"onCueRangeExit\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onError\r\n  * @type String\r\n  **/\r\n  exports.onError = \"onError\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onNavigate\r\n  * @type String\r\n  **/\r\n  exports.onNavigate = \"onNavigate\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onPlaybackQualityChange\r\n  * @type String\r\n  **/\r\n  exports.onPlaybackQualityChange = \"onPlaybackQualityChange\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onStateChange\r\n  * @type String\r\n  **/\r\n  exports.onStateChange = \"onStateChange\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onTabOrderChange\r\n  * @type String\r\n  **/\r\n  exports.onTabOrderChange = \"onTabOrderChange\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onVolumeChange\r\n  * @type String\r\n  **/\r\n  exports.onVolumeChange = \"onVolumeChange\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onAdStart\r\n  * @type String\r\n  **/\r\n  exports.onAdStart = \"onAdStart\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onReady\r\n  * @type String\r\n  **/\r\n  exports.onReady = \"onReady\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property RATE_SENTIMENT\r\n  * @type String\r\n  **/\r\n  exports.RATE_SENTIMENT = \"RATE_SENTIMENT\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property SHARE_CLICKED\r\n  * @type String\r\n  **/\r\n  exports.SHARE_CLICKED = \"SHARE_CLICKED\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property SIZE_CLICKED\r\n  * @type String\r\n  **/\r\n  exports.SIZE_CLICKED = \"SIZE_CLICKED\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property WATCH_LATER\r\n  * @type String\r\n  **/\r\n  exports.WATCH_LATER = \"WATCH_LATER\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property AdvertiserVideoView\r\n  * @type String\r\n  **/\r\n  exports.AdvertiserVideoView = \"AdvertiserVideoView\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property captionschanged\r\n  * @type String\r\n  **/\r\n  exports.captionschanged = \"captionschanged\";\r\n  \r\n  /**\r\n  * @static\r\n  * @readOnly\r\n  * @property onRemoteReceiverSelected\r\n  * @type String\r\n  **/\r\n  exports.onRemoteReceiverSelected = \"onRemoteReceiverSelected\";\r\n  \r\n  return exports;\r\n})\n//# sourceURL=/player/listeners/events.js");

eval("/**\r\n* Handles the player listeners.\r\n*\r\n* @namespace Player\r\n* @class Listeners\r\n**/\r\ndefine(\'player/listeners\',[\"exports\", \"../utils\", \"./api\", \"../unsafeWindow\", \"../console\", \"./onYouTubePlayerReady\", \"../ytready\", \"./listeners/origins\", \"./listeners/events\"],\r\nfunction(exports, utils, playerAPI, uw, con, onReady, ytready, Origin, Events){\r\n  /**\r\n  * Get the YouTube listener for the passed event.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getYouTubeListener\r\n  * @param {String} event The event name.\r\n  * @return {Function} Returns the YouTube listener with the given event name.\r\n  **/\r\n  function getYouTubeListener(event) {\r\n    var ytEvent = getListenerName(event);\r\n    return ytListeners[ytEvent];\r\n  }\r\n  \r\n  /**\r\n  * The latest player id and player uid registered in the global window.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getPlayerListenerDetails\r\n  * @return {Object} An object with the `id` property and the `uid` property.\r\n  **/\r\n  function getPlayerListenerDetails() {\r\n    var id = 1;\r\n    var uid = null;\r\n    \r\n    utils.each(uw, function(key, value){\r\n      if (key.indexOf(\"ytPlayer\") === 0) {\r\n        if (key.indexOf(\"player_uid_\") !== -1) {\r\n          var uidMatch = key.match(/player_uid_([0-9]+)_([0-9]+)$/);\r\n          \r\n          uid = parseInt(uidMatch[1], 10);\r\n          i = parseInt(uidMatch[2], 10);\r\n          \r\n          if (i > id) {\r\n            id = i;\r\n          }\r\n        } else {\r\n          var idMatch = key.match(/player([0-9]+)$/);\r\n          i = parseInt(idMatch[1], 10);\r\n          if (i > id) {\r\n            id = i;\r\n          }\r\n        }\r\n      }\r\n    });\r\n    \r\n    return { id: id, uid: uid };\r\n  }\r\n  \r\n  /**\r\n  * The property name of the event in the global window.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getListenerName\r\n  * @param {String} event The event name.\r\n  * @return {String} The property name of the event.\r\n  **/\r\n  function getListenerName(event) {\r\n    if (playerListenerDetails.uid !== null) {\r\n      return \"ytPlayer\" + event + \"player_uid_\" + playerListenerDetails.uid + \"_\" + playerListenerDetails.id;\r\n    } else {\r\n      return \"ytPlayer\" + event + \"player\" + playerListenerDetails.id;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * The setter function for the event property in the global window.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method ytListenerContainerSetter\r\n  * @param {String} event The event name.\r\n  * @param {Function} func The event listener.\r\n  **/\r\n  function ytListenerContainerSetter(event, func) {\r\n    var ytEvent = getListenerName(event);\r\n    ytListeners[ytEvent] = func;\r\n  }\r\n  \r\n  /**\r\n  * The getter function for the event property in the global window.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method ytListenerContainerGetter\r\n  * @param {String} event The event name.\r\n  * @return {Function} The event listener.\r\n  **/\r\n  function ytListenerContainerGetter(event) {\r\n    return utils.bind(null, callListener, event, Origin.PROPERTY);\r\n  }\r\n  \r\n  /**\r\n  * Handles the added listeners and YouTube\'s listeners.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method callListener\r\n  * @param {String} event The event name.\r\n  * @param {PlayerListenersOrigin} origin The call origin.\r\n  * @return {any} The return value of the called listeners.\r\n  **/\r\n  function callListener(event, origin) {\r\n    function generateThisObject() {\r\n      return {\r\n        getOriginalListener: utils.bind(null, getYouTubeListener, event)\r\n      };\r\n    }\r\n    \r\n    var ytEvent = getListenerName(event);\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    var returnVal = null;\r\n    \r\n    con.debug(\"Listener \" + event + \" called from [\" + origin + \"]\", args);\r\n    \r\n    if (enabled && origin === Origin.PLAYER && (!events.hasOwnProperty(event) || (events.hasOwnProperty(event) && !events[event].override))) {\r\n      /* Override is false and the origin is from the player; call the YouTube Center listeners */\r\n      if (events.hasOwnProperty(event)) {\r\n        for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n          returnVal = events[event].listeners[i].apply(null, args);\r\n        }\r\n      }\r\n    } else if (enabled && origin === Origin.PROPERTY) {\r\n      if (events.hasOwnProperty(event) && events[event].override) {\r\n        /* Override is true and the origin is from the global window; call the YouTube Center listeners */\r\n        for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n          events[event].listeners[i].apply(generateThisObject(), args);\r\n        }\r\n      } else if (ytListeners[ytEvent]) {\r\n        if (apiNotAvailable) {\r\n          /* API is not available therefore call YouTube Center listeners as YouTube listener is called  */\r\n          for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n            returnVal = events[event].listeners[i].apply(null, args);\r\n          }\r\n        }\r\n        \r\n        /* Override is false and the origin is from the global window; call the YouTube listener */\r\n        returnVal = ytListeners[ytEvent].apply(uw, args);\r\n      }\r\n    } else if (!enabled) {\r\n      /* Everything is disabled; call the YouTube listener */\r\n      returnVal = ytListeners[ytEvent].apply(uw, args);\r\n    }\r\n    return returnVal;\r\n  }\r\n  \r\n  /**\r\n  * Adding the listeners to the player.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method addPlayerListener\r\n  **/\r\n  function addPlayerListener() {\r\n    var api = playerAPI.getAPI();\r\n    var event;\r\n    \r\n    if (api && api.addEventListener) {\r\n      apiNotAvailable = false;\r\n      for (event in events) {\r\n        if (events.hasOwnProperty(event)) {\r\n          playerListener[event] = utils.bind(null, callListener, event, Origin.PLAYER);\r\n          api.addEventListener(event, playerListener[event]);\r\n        }\r\n      }\r\n    } else {\r\n      apiNotAvailable = true;\r\n      con.error(\"[Player Listener] Player API is not available!\");\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Initializing the global listeners.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method initGlobalListeners\r\n  **/\r\n  function initGlobalListeners() {\r\n    if (globalListenersInitialized) return; // Make sure that this function is only called once.\r\n    globalListenersInitialized = true;\r\n    for (var event in events) {\r\n      if (events.hasOwnProperty(event)) {\r\n        var ytEvent = getListenerName(event);\r\n        if (uw[ytEvent]) {\r\n          ytListeners[ytEvent] = uw[ytEvent];\r\n        }\r\n        utils.defineLockedProperty(uw, ytEvent,\r\n          utils.bind(null, ytListenerContainerSetter, event),\r\n          utils.bind(null, ytListenerContainerGetter, event)\r\n        );\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Initializing the player listener wrapper.\r\n  *\r\n  * @static\r\n  * @method init\r\n  **/\r\n  function init() {\r\n    if (enabled) return;\r\n    \r\n    con.debug(\"Init player listener\");\r\n    \r\n    var api = playerAPI.getAPI();\r\n    playerListenerDetails = getPlayerListenerDetails();\r\n    \r\n    enabled = true; // Indicate that the it\'s active.\r\n\r\n    // Add the listeners normally to the player\r\n    addPlayerListener();\r\n    \r\n    // Replace the global listeners with custom listeners in case the override property is set to true\r\n    initGlobalListeners();\r\n  }\r\n  \r\n  /**\r\n  * Adding an event listener.\r\n  *\r\n  * @static\r\n  * @method addEventListener\r\n  * @param {String} event The event name.\r\n  * @param {Function} listener The listener.\r\n  **/\r\n  function addEventListener(event, listener) {\r\n    if (!events.hasOwnProperty(event)) return;\r\n    \r\n    removeEventListener(event, listener); // Make sure that there is only one instance of the listener registered.\r\n    events[event].listeners.push(listener);\r\n  }\r\n  \r\n  /**\r\n  * Removing an event listener.\r\n  *\r\n  * @static\r\n  * @method removeEventListener\r\n  * @param {String} event The event name.\r\n  * @param {Function} listener The listener.\r\n  **/\r\n  function removeEventListener(event, listener) {\r\n    if (!events.hasOwnProperty(event)) return;\r\n    for (var i = 0, len = events[event].listeners.length; i < len; i++) {\r\n      if (events[event].listeners[i] === listener) {\r\n        return events[event].listeners.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Set the event to override the YouTube\'s event listener\r\n  * so that they won\'t be called except if done so manually.\r\n  *\r\n  * @static\r\n  * @method setOverride\r\n  * @param {String} event The event name.\r\n  * @param {Boolean} override Whether the event should be set to override.\r\n  **/\r\n  function setOverride(event, override) {\r\n    if (!events.hasOwnProperty(event)) return;\r\n    events[event].override = !!override;\r\n  }\r\n  \r\n  /**\r\n  * Unload the player listeners added to the player\r\n  * through the player API.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method unloadPlayerListeners\r\n  **/\r\n  function unloadPlayerListeners() {\r\n    var api = playerAPI.getAPI();\r\n    var event;\r\n    \r\n    if (api && api.removeEventListener) {\r\n      for (event in events) {\r\n        if (events.hasOwnProperty(event)) {\r\n          api.removeEventListener(event, playerListener[event]);\r\n          delete playerListener[event];\r\n        }\r\n      }\r\n    } else {\r\n      con.error(\"[Player Listener] Player API is not available!\");\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Unload the player listener wrapper.\r\n  *\r\n  * @static\r\n  * @method unload\r\n  **/\r\n  function unload() {\r\n    unloadPlayerListeners();\r\n    enabled = false;\r\n    apiNotAvailable = true;\r\n  }\r\n  \r\n  /**\r\n  * The cached player id and uid.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property playerListenerDetails\r\n  * @type Object\r\n  **/\r\n  var playerListenerDetails = { id: 1, uid: null };\r\n  \r\n  /**\r\n  * The leaked YouTube listeners.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property ytListeners\r\n  * @type Object\r\n  **/\r\n  var ytListeners = {};\r\n  \r\n  /**\r\n  * The cached player listeners.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property playerListener\r\n  * @type Object\r\n  **/\r\n  var playerListener = {};\r\n  \r\n  /**\r\n  * If the player listeners handler is enabled.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property enabled\r\n  * @type Boolean\r\n  **/\r\n  var enabled = false;\r\n  \r\n  /**\r\n  * If the global listeners are initialized.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property globalListenersInitialized\r\n  * @type Boolean\r\n  **/\r\n  var globalListenersInitialized = false;\r\n  \r\n  /**\r\n  * If the player API is available.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property apiNotAvailable\r\n  * @type Boolean\r\n  **/\r\n  var apiNotAvailable = true;\r\n  \r\n  /**\r\n  * The event listeners and options.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property events\r\n  * @type Object\r\n  **/\r\n  var events = {};\r\n  for (var event in Events) {\r\n    if (Events.hasOwnProperty(event)) {\r\n      events[event] = { override: false, listeners: [] };\r\n    }\r\n  }\r\n  \r\n  // Intialize the player listeners at player on ready.\r\n  onReady.addListener(init);\r\n  \r\n  /* Exports */\r\n  exports.addEventListener = addEventListener;\r\n  exports.removeEventListener = removeEventListener;\r\n  exports.setOverride = setOverride;\r\n  exports.init = init;\r\n  exports.unload = unload;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/listeners.js");

eval("define(\'window\',[], function(){\r\n  function getInnerWidth() {\r\n    return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r\n  }\r\n  function getInnerHeight() {\r\n    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\r\n  }\r\n  \r\n  function getClientWidth() {\r\n    return document.documentElement.clientWidth || window.innerWidth || document.body.clientWidth;\r\n  }\r\n  \r\n  function getClientHeight() {\r\n    return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;\r\n  }\r\n  \r\n  function addEventListener(event, callback, capture) {\r\n    window.addEventListener(event, callback, capture);\r\n  }\r\n  \r\n  return {\r\n    getClientWidth: getClientWidth,\r\n    getClientHeight: getClientHeight,\r\n    getInnerWidth: getInnerWidth,\r\n    getInnerHeight: getInnerHeight,\r\n    addEventListener: addEventListener\r\n  }\r\n});\n//# sourceURL=/window.js");

eval("define(\'player/size\',[\"exports\", \"./listeners\", \"./player\", \"window\", \"utils\"], function(exports, listeners, player, win, utils){\r\n  function onPlayerSizeChange(large) {\r\n    if (large) {\r\n      setSize(largeSize);\r\n    } else {\r\n      setSize(smallSize);\r\n    }\r\n    update();\r\n  }\r\n  \r\n  function setSize(nSize) {\r\n    size = nSize;\r\n    update();\r\n  }\r\n  \r\n  function update() {\r\n    var playerEl = document.getElementById(\"player\");\r\n    var playerAPIEl = document.getElementById(\"player-api\");\r\n    var playerTheaterBackgroundEl = document.getElementById(\"theater-background\");\r\n    \r\n    utils.removeClass(playerEl, \"watch-small watch-medium watch-large\");\r\n    if (size.large) {\r\n      utils.addClass(playerEl, \"watch-large\");\r\n    } else {\r\n      utils.addClass(playerEl, \"watch-small\");\r\n    }\r\n    \r\n    var dim = getPlayerDimension();\r\n    if (size.large) {\r\n      playerEl.style.width = dim.width + \"px\";\r\n    } else {\r\n      playerEl.style.width = \"auto\";\r\n    }\r\n    playerTheaterBackgroundEl.style.height = dim.height + \"px\";\r\n    \r\n    playerAPIEl.style.width = dim.width + \"px\";\r\n    playerAPIEl.style.height = dim.height + \"px\";\r\n    \r\n    var contentContainerEl = document.getElementById(\"watch7-container\");\r\n    if (size.large) {\r\n      utils.addClass(contentContainerEl, \"watch-wide\");\r\n    } else {\r\n      utils.removeClass(contentContainerEl, \"watch-wide\");\r\n    }\r\n    \r\n    var sidebarEl = document.getElementById(\"watch7-sidebar\");\r\n    if (size.large) {\r\n      sidebarEl.style.top = \"\";\r\n    } else {\r\n      sidebarEl.style.top = \"-\" + dim.height + \"px\";\r\n    }\r\n  }\r\n  \r\n  function getPlayerDimension() {\r\n    var playerEl = document.getElementById(\"player\");\r\n    \r\n    var width = null;\r\n    var height = null;\r\n    \r\n    if (typeof size.width === \"number\") {\r\n      if (size.widthUnit === \"%\") {\r\n        width = size.width/100*win.getClientWidth();\r\n      } else {\r\n        width = size.width;\r\n      }\r\n    }\r\n    \r\n    if (typeof size.width === \"number\") {\r\n      if (size.heightUnit === \"%\") {\r\n        height = size.height/100*win.getClientHeight();\r\n        // if (something.isTopBar())\r\n        height -= 50;\r\n      } else {\r\n        height = size.height;\r\n      }\r\n    }\r\n    \r\n    var ratio = getRatio();\r\n    \r\n    if (typeof width !== \"number\") {\r\n      if (typeof height === \"number\") {\r\n        width = height*ratio;\r\n      } else {\r\n        width = getDefaultWidth();\r\n      }\r\n    }\r\n    \r\n    if (typeof height !== \"number\") {\r\n      if (typeof width === \"number\") {\r\n        height = width/ratio;\r\n      } else {\r\n        height = getDefaultHeight();\r\n      }\r\n    }\r\n    \r\n    // Controlbar + Progressbar height\r\n    var controlbarHeight = player.getControlbarHeight();\r\n    height += controlbarHeight;\r\n    \r\n    // Multi camera additional height\r\n    if (utils.hasClass(playerEl, \"watch-multicamera\") && player.getType === \"flash\") {\r\n      height += 80;\r\n    }\r\n    \r\n    return {\r\n      width: Math.floor(width),\r\n      height: Math.floor(height)\r\n    };\r\n  }\r\n  \r\n  function setSmallPlayerSize(small) {\r\n    smallSize = small;\r\n  }\r\n  \r\n  function setLargePlayerSize(large) {\r\n    largeSize = large;\r\n  }\r\n  \r\n  function getRatio() {\r\n    return 16/9;\r\n  }\r\n  \r\n  function getDefaultWidth() {\r\n    return 640;\r\n  }\r\n  \r\n  function getDefaultHeight() {\r\n    return getDefaultWidth()/getRatio();\r\n  }\r\n  \r\n  var smallSize = {\r\n    width: 1280,\r\n    widthUnit: \"px\",\r\n    large: true\r\n  };\r\n  var largeSize = {\r\n    width: 1920,\r\n    widthUnit: \"px\",\r\n    large: true\r\n  };\r\n  \r\n  var size = {\r\n    width: 1280,\r\n    height: 720,\r\n    widthUnit: \"px\",\r\n    heightUnit: \"px\",\r\n    large: true\r\n  };\r\n  \r\n  listeners.setOverride(\"SIZE_CLICKED\", true);\r\n  listeners.addEventListener(\"SIZE_CLICKED\", onPlayerSizeChange);\r\n  \r\n  win.addEventListener(\"resize\", utils.throttle(update, 100));\r\n  \r\n  /* Exports */\r\n  exports.setSize = setSize;\r\n  exports.getRatio = getRatio;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/size.js");

eval("/**\r\n* @namespace Player\r\n* @class ElementType\r\n**/\r\ndefine(\'player/ElementType\',[\"exports\"], function(exports){\r\n  \r\n  /**\r\n  * @static\r\n  * @property EMBEDDED\r\n  * @type String\r\n  **/\r\n  exports.EMBEDDED = \"embedded\";\r\n  \r\n  /**\r\n  * @static\r\n  * @property WATCH\r\n  * @type String\r\n  **/\r\n  exports.WATCH = \"watch\";\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/player/ElementType.js");

eval("/**\r\n* The YouTube player.\r\n*\r\n* @namespace Player\r\n* @class Player\r\n**/\r\ndefine(\'player/player\',[\"exports\", \"./api\", \"./config\", \"unsafeWindow\", \"./size\", \"./ElementType\", \"../utils\"], function(exports, playerAPI, playerConfig, uw, size, ElementType, utils){\r\n  function getElementType() {\r\n    \r\n  }\r\n  \r\n  /**\r\n  * Get the current player type, which can either be HTML5 or flash.\r\n  *\r\n  * @static\r\n  * @method getType\r\n  * @return {String} The player type.\r\n  **/\r\n  function getType() {\r\n    var api = playerAPI.getAPI();\r\n    if (api && typeof api.getPlayerType === \"function\") {\r\n      return api.getPlayerType();\r\n    }\r\n    var cfg = playerConfig.getConfig();\r\n    if (cfg.html5) {\r\n      return \"html5\";\r\n    } else {\r\n      return \"flash\";\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Setting the player type to either HTML5 or flash\r\n  *\r\n  * @static\r\n  * @method setType\r\n  * @param {String} type The desired player type (HTML5 or flash).\r\n  **/\r\n  function setType(type) {\r\n    var currentType = getType();\r\n    if (type === currentType) {\r\n      return; // Do nothing as it\'s already the desired player type\r\n    } else {\r\n      var api = playerAPI.getAPI();\r\n      playerConfig.setConfig(\"html5\", (type === \"html5\" ? true : false)); // Setting the property html5 to either true or false\r\n      \r\n      // Soft-reloading the player. If YouTube detects that the html5 property has changed it will change the player.\r\n      if (api && typeof api.loadNewVideoConfig === \"function\") {\r\n        api.loadNewVideoConfig(uw.ytplayer.config);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Get the controlbar height.\r\n  *\r\n  * @static\r\n  * @method getControlbarHeight\r\n  * @return {Number} The height of the controlbar on the player.\r\n  **/\r\n  function getControlbarHeight() {\r\n    var none = 0;\r\n    var onlyControlbar = 3;\r\n    var onlyProgressbar = 30;\r\n    var both = 35;\r\n    \r\n    var cfg = playerConfig.getConfig();\r\n    var autohide = null;\r\n    \r\n    if (cfg && cfg.args && typeof cfg.args.autohide === \"string\") {\r\n      autohide = cfg.args.autohide;\r\n    } else if (getType() === \"html5\") {\r\n      var ratio = size.getRatio();\r\n      if (ratio < 1.35) {\r\n        autohide = \"3\";\r\n      }\r\n    }\r\n    \r\n    switch (autohide) {\r\n      case \"0\": return both;\r\n      case \"1\": return none;\r\n      case \"3\": return onlyControlbar;\r\n      case \"2\": default: return onlyProgressbar;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Calling yt.player.Application.create to tell YouTube to\r\n  * create the YouTube player again and dispose of the old\r\n  * player.\r\n  *\r\n  * @static\r\n  * @method reload\r\n  **/\r\n  function reload() {\r\n    if (uw && uw.yt && uw.yt.player && uw.yt.player.Application && typeof uw.yt.player.Application.create === \"function\") {\r\n      uw.yt.player.Application.create(\"player-api\", playerConfig.getConfig());\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * An object that contains the player\'s API.\r\n  *\r\n  * @static\r\n  * @property api\r\n  * @type Object\r\n  * @readOnly\r\n  **/\r\n  utils.defineProperty(exports, \"api\", playerAPI.getAPI, function(){});\r\n  \r\n  /**\r\n  * Get the player API.\r\n  *\r\n  * @static\r\n  * @method getAPI\r\n  * @return {Object} The player api.\r\n  * @deprecated Use `player.api` instead.\r\n  **/\r\n  exports.getAPI = playerAPI.getAPI;\r\n  \r\n  exports.getType = getType;\r\n  exports.setType = setType;\r\n  exports.getControlbarHeight = getControlbarHeight;\r\n  exports.getConfig = playerConfig.getConfig;\r\n  exports.setConfig = playerConfig.setConfig;\r\n  exports.reload = reload;\r\n  return exports;\r\n});\n//# sourceURL=/player/player.js");

eval("define(\'placement-dragdrop\',[\"exports\", \"./utils\"], function(exports, utils){\r\n  function getTargetedGroup(x, y, groups) {\r\n    var distance = null;\r\n    var heightGroup = null;\r\n    \r\n    for (var i = 0, len = groups.length; i < len; i++) {\r\n      // Group element\r\n      var group = groups[i];\r\n      \r\n      // Getting the absolute position of the group element\r\n      var absolutePosition = utils.getAbsolutePosition(group);\r\n      \r\n      /*\r\n      * The points on the rectangle, which represents the group element.\r\n      * px is 1 and 2,\r\n      * py is 1 and 3,\r\n      * pWidth is 2 and 4,\r\n      * pHeight is 3 and 4\r\n      * 1------------2\r\n      * |            |\r\n      * |            |\r\n      * 3------------4\r\n      */\r\n      var px = absolutePosition.left;\r\n      var py = absolutePosition.top;\r\n      var pWidth = absolutePosition.left + group.offsetWidth;\r\n      var pHeight = absolutePosition.top + group.offsetHeight;\r\n      \r\n      // Detecting if the (x, y) point is inside or touches the group element (rectangle)\r\n      if (x >= px && x <= pWidth && y >= py && y <= pHeight) {\r\n        return group;\r\n      } else if (y >= py && y <= pHeight) {\r\n        var tmpDist = null;\r\n        if (x < px) {\r\n          // Left side\r\n          tmpDist = px - x;\r\n        } else if (x > pWidth) {\r\n          // Right side\r\n          tmpDist = x - pWidth;\r\n        } else {\r\n          continue; // This should never happen.\r\n        }\r\n        if (distance === null || tmpDist < distance) {\r\n          heightGroup = group;\r\n          distance = tmpDist;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return heightGroup;\r\n  }\r\n  \r\n  function getRelativeGroupChild(x, y, group) {\r\n    // The cursor is inside a group element.\r\n    if (group !== null) {\r\n      var groupChildren = group.children;\r\n      \r\n      // Iterate through every child of group\r\n      for (var i = 0, len = groupChildren.length; i < len; i++) {\r\n        var child = groupChildren[i];\r\n        // Making sure that an element is not placed beside itself.\r\n        if (child !== refMoveableElement && child !== refTargetedElement) {\r\n          // Get the child\'s absolute position on the page\r\n          var absolutePosition = utils.getAbsolutePosition(child);\r\n          \r\n          // The for loop iterates through the children chronological, which means that\r\n          // it only needs to look if the x-value of the cursor is before half of the\r\n          // child element.\r\n          if (x <= child.offsetWidth/2 + absolutePosition.left && y <= child.offsetHeight + absolutePosition.top) {\r\n            return child;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // No child was found, return null\r\n    return null;\r\n  }\r\n  \r\n  function mousemoveListener(e) {\r\n    if (!mousedown || !moduleEnabled) return;\r\n    e = e || window.event;\r\n    \r\n    // If user is using touch, make sure that it detects the touch instead of mouse.\r\n    if (e && e.type.indexOf(\"touch\") !== -1 && e.changedTouches && e.changedTouches.length > 0 && e.changedTouches[0]) {\r\n      e = e.changedTouches[0];\r\n    }\r\n    \r\n    // The (x, y) coordinate of the mouse cursor on the page\r\n    var x = e.pageX;\r\n    var y = e.pageY;\r\n    \r\n    // Update the moveable element position\r\n    refMoveableElement.style.top = (y - (relativeMousePosition.y || 0)) + \"px\";\r\n    refMoveableElement.style.left = (x - (relativeMousePosition.x || 0)) + \"px\";\r\n    \r\n    // Get the targeted group with the (x, y) coordinate of the cursor\r\n    var group = getTargetedGroup(x, y, groupElements);\r\n    \r\n    if (group) {\r\n      // Get the relative group child element\r\n      var child = getRelativeGroupChild(x, y, group);\r\n      \r\n      // Make sure that targeted element does have a parent to remove\r\n      // the element from\r\n      if (refTargetedElement.parentNode) {\r\n        refTargetedElement.parentNode.removeChild(refTargetedElement);\r\n      }\r\n      \r\n      if (child) {\r\n        // A child was found insert the targeted element before said child\r\n        group.insertBefore(refTargetedElement, child);\r\n      } else {\r\n        // A child was not found just append the element to the group\r\n        group.appendChild(refTargetedElement);\r\n      }\r\n    }\r\n    \r\n    // Prevent default action\r\n    if (e && e.preventDefault) {\r\n      e.preventDefault();\r\n    } else {\r\n      window.event.returnValue = false;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function mousedownListener(e) {\r\n    if (mousedown || !moduleEnabled) return;\r\n    \r\n    e = e || window.event;\r\n    \r\n    var targetedElement = e.target;\r\n    while (targetedElement) {\r\n      if (!targetedElement.parentNode) return; // Targeted element not in a container\r\n      \r\n      // Is the targeted element a child of groupElements\r\n      // and if so then we break out of this loop\r\n      if (utils.inArray(groupElements, targetedElement.parentNode)) {\r\n        break;\r\n      }\r\n      \r\n      // The desired element is a child to one of the containers.\r\n      targetedElement = targetedElement.parentNode;\r\n    }\r\n    \r\n    mousedown = true;\r\n    \r\n    // Relative position to targeted element\r\n    var absolutePosition = utils.getAbsolutePosition(targetedElement);\r\n    relativeMousePosition = {\r\n      x: e.pageX - absolutePosition.left,\r\n      y: e.pageY - absolutePosition.top\r\n    };\r\n    \r\n    // Create the moveable element\r\n    var moveableElement = createMoveableElement(targetedElement);\r\n    \r\n    // Make the targeted element invisible\r\n    utils.addClass(targetedElement, \"placementsystem-target\");\r\n    //targetedElement.style.visibility = \"hidden\";\r\n    \r\n    // Store two references for later use\r\n    refMoveableElement = moveableElement;\r\n    refTargetedElement = targetedElement;\r\n    \r\n    document.body.appendChild(moveableElement);\r\n    \r\n    // Add mouseup, mousemove, touchend and touchmove event listener\r\n    utils.addEventListener(document, \"mousemove\", mousemoveListener, false);\r\n    utils.addEventListener(document, \"touchmove\", mousemoveListener, false);\r\n    \r\n    // Prevent default action\r\n    if (e && e.preventDefault) {\r\n      e.preventDefault();\r\n    } else {\r\n      window.event.returnValue = false;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function mouseupListener(e) {\r\n    if (!mousedown || !moduleEnabled || !refTargetedElement) return;\r\n    mousedown = false;\r\n    \r\n    e = e || window.event;\r\n    \r\n    // Make the targeted element visible\r\n    utils.removeClass(refTargetedElement, \"placementsystem-target\");\r\n    //refTargetedElement.style.visibility = \"\";\r\n    \r\n    // Remove the moveable element from the DOM\r\n    refMoveableElement.parentNode.removeChild(refMoveableElement);\r\n    \r\n    // Remove relative mouse position\r\n    relativeMousePosition = null;\r\n    \r\n    // Remove stored references\r\n    refMoveableElement = null;\r\n    refTargetedElement = null;\r\n    \r\n    // Remove mousemove and touchmove event listener\r\n    utils.removeEventListener(document, \"mousemove\", mousemoveListener, false);\r\n    utils.removeEventListener(document, \"touchmove\", mousemoveListener, false);\r\n    \r\n    // Prevent default action\r\n    if (e && e.preventDefault) {\r\n      e.preventDefault();\r\n    } else {\r\n      window.event.returnValue = false;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function setGroupElements(groups) {\r\n    groupElements = groups;\r\n  }\r\n  \r\n  function setMoveableElementPosition(el, moveableElement) {\r\n    var absolutePosition = utils.getAbsolutePosition(el);\r\n    \r\n    // Give the moveable an absolute position, which will be\r\n    // on top of the original element.\r\n    moveableElement.style.position = \"absolute\";\r\n    moveableElement.style.top = absolutePosition.top + \"px\";\r\n    moveableElement.style.left = absolutePosition.left + \"px\";\r\n    moveableElement.style.zIndex = \"1999999999999\";\r\n  }\r\n  \r\n  function createMoveableElement(el) {\r\n    function removeTooltip(el) {\r\n      // Removes tooltip from element\r\n      el.title = \"\";\r\n      el.setAttribute(\"data-button-action\", \"\");\r\n      el.setAttribute(\"data-tooltip-text\", \"\");\r\n      utils.removeClass(el, \"yt-uix-tooltip\");\r\n      \r\n      // Removes tooltip from children\r\n      var children = el.children;\r\n      for (var i = 0, len = children.length; i < len; i++) {\r\n        removeTooltip(children[i]);\r\n      }\r\n    }\r\n    var moveableElement = el.cloneNode(true);\r\n    \r\n    // Move the moveable element on top of the targeted element\r\n    setMoveableElementPosition(el, moveableElement);\r\n    \r\n    // Removes tooltip from the moveable element\r\n    removeTooltip(moveableElement);\r\n    \r\n    return moveableElement;\r\n  }\r\n  \r\n  function setEnabled(enabled) {\r\n    moduleEnabled = enabled;\r\n    \r\n    utils.removeEventListener(document, \"mousemove\", mousemoveListener, false);\r\n    utils.removeEventListener(document, \"touchmove\", mousemoveListener, false);\r\n    \r\n    utils.removeEventListener(document, \"mousedown\", mousedownListener, false);\r\n    utils.removeEventListener(document, \"touchstart\", mousedownListener, false);\r\n    \r\n    utils.removeEventListener(document, \"mouseup\", mouseupListener, false);\r\n    utils.removeEventListener(document, \"touchend\", mouseupListener, false);\r\n    \r\n    if (enabled) {\r\n      utils.addEventListener(document, \"mousedown\", mousedownListener, false);\r\n      utils.addEventListener(document, \"touchstart\", mousedownListener, false);\r\n      \r\n      utils.addEventListener(document, \"mouseup\", mouseupListener, false);\r\n      utils.addEventListener(document, \"touchend\", mouseupListener, false);\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * An array of where the moveable elements can be placed in.\r\n  *\r\n  * @property groupElements\r\n  * @type HTMLElement[]\r\n  **/\r\n  var groupElements = [ ];\r\n  \r\n  // A reference to the moveable and targeted elements for use in mousemove\r\n  var relativeMousePosition = null;\r\n  var refMoveableElement = null;\r\n  var refTargetedElement = null;\r\n  \r\n  // Local properties\r\n  /**\r\n  * Used to check if the drag \'n\' drop is enabled.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property moduleEnabled\r\n  * @type Boolean\r\n  **/\r\n  var moduleEnabled = false;\r\n  \r\n  /**\r\n  * Used to check if the left mouse button is pressed,\r\n  * and if it is then it should move the element.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property mousedown\r\n  * @type Boolean\r\n  **/\r\n  var mousedown = false;\r\n  \r\n  // Throttle the listener as it can be taxing for the users system.\r\n  mousemoveListener = utils.throttle(mousemoveListener, 50);\r\n  \r\n  exports.setGroupElements = setGroupElements;\r\n  exports.setEnabled = setEnabled;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/placement-dragdrop.js");

eval("define(\'element-placement\',[\"exports\", \"./utils\", \"./placement-dragdrop\", \"./pageload\"], function(exports, utils, dragdrop, pageload){\r\n  /**\r\n  * Adding an element to a defined group.\r\n  *\r\n  * @static\r\n  * @method addElement\r\n  * @param {String} id The id of the group.\r\n  * @param {HTMLElement} element The element that will be added to the group.\r\n  **/\r\n  function addElement(id, elementId, element) {\r\n    if (!groups[id]) throw \"Group \" + id + \" has not been created!\";\r\n    groups[id].children.push({ id: elementId, element: element });\r\n    \r\n    // Append the element to the group element\r\n    groups[id].element.appendChild(element);\r\n  }\r\n  \r\n  /**\r\n  * Creating a group where the elements will be placed in.\r\n  *\r\n  * @statc\r\n  * @method createGroup\r\n  * @param {String} id The id of the group.\r\n  * @param {HTMLElement} element The group element.\r\n  * @param {Object} options The options for the group.\r\n  **/\r\n  function createGroup(id, element, options) {\r\n    if (groups[id]) throw \"Group \" + id + \" has already been created!\";\r\n    groups[id] = {\r\n      element: element, // The container element where the children resides\r\n      options: options, // The options for that specific group\r\n      children: []\r\n    };\r\n  }\r\n  \r\n  /**\r\n  * Returns the unique ID for the given element.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getElementUniqueId\r\n  * @param {HTMLElement} element The element to get the element from.\r\n  * @return {String} The unique ID for the element.\r\n  **/\r\n  function getElementUniqueId(element) {\r\n    var classes = utils.listClass(element);\r\n    for (var i = 0, len = classes.length; i < len; i++) {\r\n      if (classes[i] !== \"\") {\r\n        classes[i] = encodeURIComponent(classes[i]);\r\n      }\r\n    }\r\n    \r\n    if (classes.length > 0) {\r\n      classes = \".\" + classes.join(\".\");\r\n      if (classes[classes.length - 1] === \".\") {\r\n        classes = classes.substring(0, classes.length - 1);\r\n      }\r\n    } else {\r\n      classes = \"\";\r\n    }\r\n    \r\n    var id = getGroupIdByElement(element);\r\n    if (typeof id === \"string\") {\r\n      id = \"@\" + encodeURIComponent(id);\r\n    } else {\r\n      id = element.getAttribute(\"id\");\r\n      if (id) {\r\n        id = \"#\" + encodeURIComponent(id);\r\n      } else {\r\n        id = \"\";\r\n      }\r\n    }\r\n    \r\n    var tagName = encodeURIComponent(element.tagName);\r\n    \r\n    var uid = null;\r\n    \r\n    var parent = element.parentNode && element.parentNode instanceof HTMLElement;\r\n    \r\n    if (!id && !classes && parent) {\r\n      var parentNode = element.parentNode;\r\n      for (var i = 0, len = parentNode.children.length; i < len; i++) {\r\n        if (parentNode.children[i] === element) {\r\n          uid = tagName + \"[\" + i + \"]\"\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      uid = tagName + id + classes;\r\n    }\r\n    \r\n    if (!id && parent) {\r\n      return getElementUniqueId(element.parentNode) + \" \" + uid;\r\n    } else {\r\n      return uid;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Returns the HTMLElement with a specific unique ID.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getElementByUniqueId\r\n  * @param {String} id The unique ID.\r\n  * @return {HTMLElement} The element with the unique ID.\r\n  **/\r\n  function getElementByUniqueId(uid) {\r\n    var tokens = uid.split(\" \");\r\n    var element = null;\r\n    for (var i = 0, len = tokens.length; i < len; i++) {\r\n      var match = /([a-zA-Z0-9_%\\-]+)(\\[[0-9]+\\])?((\\#|\\@)[a-zA-Z0-9_%\\-]+)?((\\.[a-zA-Z0-9_%\\-]+)*)/g.exec(tokens[i]);\r\n      var tagName = decodeURIComponent(match[1]);\r\n      var childIndex = null;\r\n      if (match[2]) {\r\n        childIndex = parseInt(match[2].substring(1, match[2].length - 1), 10);\r\n      }\r\n      var id = null;\r\n      var regId = false;\r\n      if (match[3]) {\r\n        if (match[3].substring(0, 1) === \"@\") {\r\n          // The element is a registered group.\r\n          regId = true;\r\n        }\r\n        id = decodeURIComponent(match[3].substring(1));\r\n      }\r\n      \r\n      var classes = [];\r\n      if (match[5]) {\r\n        classes = match[5].substring(1).split(\".\");\r\n      }\r\n      for (var j = 0, lenj = classes.length; j < lenj; j++) {\r\n        classes[j] = decodeURIComponent(classes[j]);\r\n      }\r\n      \r\n      var doc = document;\r\n      if (element) {\r\n        doc = element;\r\n      }\r\n      var continues = false;\r\n      if (id) {\r\n        if (regId) {\r\n          element = getGroupElementByUniqueId(id);\r\n        } else {\r\n          element = document.getElementById(id);\r\n        }\r\n      } else if (classes.length > 0) {\r\n        var elements = doc.getElementsByClassName(classes.join(\" \"));\r\n        for (var j = 0, lenj = elements.length; j < lenj; j++) {\r\n          if (elements[j].tagName.toLowerCase() === tagName.toLowerCase()) {\r\n            element = elements[j];\r\n            continues = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!continues) return null;\r\n      } else if (typeof childIndex === \"number\") {\r\n        var elements = doc.getElementsByTagName(tagName);\r\n        for (var j = 0, lenj = elements.length; j < lenj; j++) {\r\n          if (elements[j] && elements[j].parentNode && elements[j].parentNode instanceof HTMLElement && elements[j].parentNode.children[childIndex] === elements[j]) {\r\n            element = elements[j];\r\n            continues = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!continues) return null;\r\n      } else {\r\n        element = doc.getElementsByTagName(tagName)[0];\r\n      }\r\n      \r\n      if (!element) {\r\n        return null;\r\n      }\r\n    }\r\n    \r\n    return element;\r\n  }\r\n  \r\n  /**\r\n  * Get the group element by an unique ID.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getGroupElementByUniqueId\r\n  * @param {String} id The unique Id of the group element.\r\n  * @return {HTMLElement} The group element.\r\n  **/\r\n  function getGroupElementByUniqueId(id) {\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        if (key === id) {\r\n          return groups[key].element;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n  * Get the group ID by element.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getGroupIdByElement\r\n  * @param {HTMLElement} el The group element.\r\n  * @return {String} The unique Id of the group element.\r\n  **/\r\n  function getGroupIdByElement(el) {\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        if (groups[key].element === el) {\r\n          return key;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n  * Get a registered element\'s unique ID.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getRegisteredElementUniqueId\r\n  * @param {HTMLElement} el The registered element.\r\n  * @return {String} Returns the unique ID of registered element.\r\n  **/\r\n  function getRegisteredElementUniqueId(el) {\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        var children = groups[key].children;\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n          if (el === children[i].element) {\r\n            return children[i].id;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n  * Get a registered element by its unique ID.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getRegisteredElementByUniqueId\r\n  * @param {String} id The unique ID of the element.\r\n  * @return {HTMLElement} Returns the element.\r\n  **/\r\n  function getRegisteredElementByUniqueId(id) {\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        var children = groups[key].children;\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n          if (id === children[i].id) {\r\n            return children[i].element;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n  * Check if an element is registered.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method isElementRegistered\r\n  * @param {HTMLElement} el The element to check if its registered.\r\n  * @return {Boolean} Returns true if element is registered otherwise return false.\r\n  **/\r\n  function isElementRegistered(el) {\r\n    for (var id in groups) {\r\n      if (groups.hasOwnProperty(id)) {\r\n        if (isElementInGroup(el, id)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  /**\r\n  * Check if an element is registered in a specific group.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method isElementRegistered\r\n  * @param {HTMLElement} el The element to check if its registered.\r\n  * @param {String} groupId The group ID.\r\n  * @return {Boolean} Returns true if element is registered in specified group otherwise return false.\r\n  **/\r\n  function isElementInGroup(el, groupId) {\r\n    if (!groups[groupId]) return false;\r\n    \r\n    var children = groups[groupId].children;\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n      if (children[i].element === el) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  /**\r\n  * Create a reference state to use as an reference when elements have been moved.\r\n  *\r\n  * @static\r\n  * @method createReferenceState\r\n  * @return {Object} The reference state.\r\n  **/\r\n  function createReferenceState() {\r\n    var map = {};\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        var group = groups[key];\r\n        \r\n        var groupElements = [];\r\n        var el = group.element;\r\n        if (el && el.children) {\r\n          var children = el.children;\r\n          for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            var data = { };\r\n            if (isElementRegistered(child)) {\r\n              data.type = REGISTERED;\r\n              data.uniqueId = getRegisteredElementUniqueId(child);\r\n              data.element = child;\r\n            } else {\r\n              data.type = NONREGISTERED;\r\n              data.uniqueId = getElementUniqueId(child);\r\n              data.element = child;\r\n            }\r\n            groupElements.push(data);\r\n          }\r\n        }\r\n        map[key] = groupElements;\r\n      }\r\n    }\r\n    return map;\r\n  }\r\n  \r\n  /**\r\n  * Get the unique ID of an referenced element.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getReferencedUniqueId\r\n  * @param {HTMLElement} el The element.\r\n  * @return {String} Returns the unique ID of element.\r\n  **/\r\n  function getReferencedUniqueId(el) {\r\n    if (!referenceState) return null;\r\n    \r\n    for (var key in referenceState) {\r\n      if (referenceState.hasOwnProperty(key)) {\r\n        var group = referenceState[key];\r\n        for (var i = 0, len = group.length; i < len; i++) {\r\n          if (el === group[i].element) {\r\n            return group[i].uniqueId;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n  * Get the reference element by the unique ID.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getReferencedElement\r\n  * @param {String} el The unique ID.\r\n  * @return {String} Returns the element given by the unique ID.\r\n  **/\r\n  function getReferencedElement(id) {\r\n    if (!referenceState) return null;\r\n    \r\n    for (var key in referenceState) {\r\n      if (referenceState.hasOwnProperty(key)) {\r\n        var group = referenceState[key];\r\n        for (var i = 0, len = group.length; i < len; i++) {\r\n          if (id === group[i].uniqueId) {\r\n            return group[i].element;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n  * Get the current state.\r\n  *\r\n  * @static\r\n  * @method getState\r\n  * @return {Object} Returns the state object.\r\n  **/\r\n  function getState() {\r\n    var map = {};\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        var group = groups[key];\r\n        \r\n        var groupElements = [];\r\n        var el = group.element;\r\n        if (el && el.children) {\r\n          var children = el.children;\r\n          for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            var data = { };\r\n            if (isElementRegistered(child)) {\r\n              data.type = REGISTERED;\r\n              data.uniqueId = getRegisteredElementUniqueId(child);\r\n            } else {\r\n              data.type = NONREGISTERED;\r\n              data.uniqueId = getReferencedUniqueId(child, referenceState) || getElementUniqueId(child);\r\n            }\r\n            groupElements.push(data);\r\n          }\r\n        }\r\n        map[key] = groupElements;\r\n      }\r\n    }\r\n    return map;\r\n  }\r\n  \r\n  /**\r\n  * Set the state.\r\n  *\r\n  * @static\r\n  * @method setState\r\n  * @param {Object} state The state to be applied.\r\n  **/\r\n  function setState(state) {\r\n    utils.each(state, function(groupId, elements){\r\n      if (!groups[groupId]) con.warn(\"Group \" + groupId + \" does not exist!\");\r\n      \r\n      var group = groups[groupId];\r\n      for (var i = 0, len = elements.length; i < len; i++) {\r\n        var element = elements[i];\r\n        var el = null;\r\n        if (element.type === REGISTERED) {\r\n          el = getRegisteredElementByUniqueId(element.uniqueId);\r\n        } else if (element.type === NONREGISTERED) {\r\n          el = getReferencedElement(element.uniqueId, referenceState) || getElementByUniqueId(element.uniqueId);\r\n        }\r\n        \r\n        if (el !== null) {\r\n          if (el.parentNode) {\r\n            el.parentNode.removeChild(el);\r\n          }\r\n          \r\n          group.element.appendChild(el);\r\n        } else {\r\n          con.warn(\"Unknown element in settings\", element);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n  * Enable/disable the drag \'n\' drop.\r\n  *\r\n  * @static\r\n  * @method setMoveable\r\n  * @param {Boolean} enabled Whether the drag \'n\' drop should be enabled.\r\n  **/\r\n  function setMoveable(enabled) {\r\n    dragdrop.setGroupElements(getGroupElements());\r\n    dragdrop.setEnabled(enabled);\r\n  }\r\n  \r\n  /**\r\n  * Get every registered element in every group.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method getGroupElements\r\n  * @return {HTMLElement[]} Returns every registered element in every registered group.\r\n  **/\r\n  function getGroupElements() {\r\n    var groupElements = [];\r\n    for (var key in groups) {\r\n      if (groups.hasOwnProperty(key)) {\r\n        groupElements.push(groups[key].element);\r\n      }\r\n    }\r\n    return groupElements;\r\n  }\r\n  \r\n  /**\r\n  * Clear every registered group and registered elements.\r\n  *\r\n  * @static\r\n  * @method clearGroups\r\n  **/\r\n  function clearGroups() {\r\n    groups = {};\r\n  }\r\n  \r\n  /**\r\n  * Set the reference state.\r\n  *\r\n  * @static\r\n  * @method setReferenceState\r\n  * @param {Object} state The reference state.\r\n  **/\r\n  function setReferenceState(state) {\r\n    referenceState = state;\r\n  }\r\n  \r\n  /**\r\n  * Initialize the reference state and move elements.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method init\r\n  **/\r\n  function init() {\r\n    setReferenceState(createReferenceState());\r\n    \r\n    \r\n  }\r\n  \r\n  /**\r\n  * Value given to registered elements.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property REGISTERED\r\n  * @type {Number}\r\n  * @default 0\r\n  **/\r\n  var REGISTERED = 0;\r\n  \r\n  /**\r\n  * Value given to not registered elements.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property NONREGISTERED\r\n  * @type {Number}\r\n  * @default 1\r\n  **/\r\n  var NONREGISTERED = 1;\r\n  \r\n  /**\r\n  * The registered groups and its registered element children\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property groups\r\n  * @type {Object}\r\n  **/\r\n  var groups = {};\r\n  \r\n  /**\r\n  * The reference state.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property referenceState\r\n  * @type {Object}\r\n  **/\r\n  var referenceState = null;\r\n  \r\n  pageload.addEventListener(\"interactive\", init);\r\n  \r\n  /* Make the API public */\r\n  exports.setMoveable = setMoveable;\r\n  exports.addElement = addElement;\r\n  exports.createGroup = createGroup;\r\n  exports.getState = getState;\r\n  exports.setState = setState;\r\n  exports.createReferenceState = createReferenceState;\r\n  exports.setReferenceState = setReferenceState;\r\n  exports.clearGroups = clearGroups;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/element-placement.js");

eval("/**\r\n* A group module for the element-placment module.\r\n*\r\n* @class SentimentActions\r\n**/\r\ndefine(\'element-placement/watch8-ytcenter-buttons\',[\"exports\", \"../element-placement\", \"../utils\", \"../pageload\"], function(exports, placement, utils, pageload){\r\n  function onInteractive() {\r\n    // Create the group element\r\n    var element = document.createElement(\"div\");\r\n    element.setAttribute(\"id\", id);\r\n    \r\n    var parentElement = document.getElementById(\"watch8-action-buttons\");\r\n    if (parentElement) {\r\n      if (parentElement.children.length === 0) {\r\n        parentElement.appendChild(element);\r\n      } else {\r\n        parentElement.insertBefore(element, parentElement.children[0]);\r\n      }\r\n    }\r\n    \r\n    // Create the group\r\n    placement.createGroup(id, element);\r\n    \r\n    // Make sure that elements are no more added to the buffer\r\n    groupCreated = true;\r\n    \r\n    // Add buffered elements to the group\r\n    if (groupBuffer.length > 0) {\r\n      for (var i = 0, len = groupBuffer.length; i < len; i++) {\r\n        placement.addElement(id, groupBuffer[i][0], groupBuffer[i][1]); // Adding the element to the group\r\n      }\r\n      groupBuffer = []; // Remove reference for every buffered element.\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Add an element to the group.\r\n  *\r\n  * @static\r\n  * @method addElement\r\n  * @param {String} id An unique id for the element\r\n  * @param {HTMLElement} el A HTMLElement that will be added to the group.\r\n  **/\r\n  function addElement(uid, el) {\r\n    if (groupCreated) {\r\n      placement.addElement(id, uid, el);\r\n    } else {\r\n      groupBuffer.push([ uid, el ]);\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * The id of the group.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property id\r\n  * @type String\r\n  * @readOnly\r\n  **/\r\n  var id = \"watch8-ytcenter-buttons\";\r\n  \r\n  /**\r\n  * Indicates whether the group has been created yet.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property groupCreated\r\n  * @type Boolean\r\n  **/\r\n  var groupCreated = false;\r\n  \r\n  /**\r\n  * The buffered element.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property groupBuffer\r\n  * @type HTMLElement[]\r\n  **/\r\n  var groupBuffer = [];\r\n  \r\n  // Make sure that the group is created when the page has loaded every DOM element.\r\n  pageload.addEventListener(\"interactive\", onInteractive);\r\n  \r\n  exports.addElement = addElement;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/element-placement/watch8-ytcenter-buttons.js");

eval("define(\'css\',[\"exports\", \"./console\"], function(exports, con){\r\n  function isCSSElementEnabled(id) {\r\n    for (var i = 0, len = enabledCSSElements.length; i < len; i++) {\r\n      if (enabledCSSElements[i] === id) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n  \r\n  function createCSSElement(id) {\r\n    var el = document.createElement(\"style\");\r\n    el.setAttribute(\"id\", prefix + id);\r\n    el.setAttribute(\"type\", \"text\\/css\");\r\n    el.appendChild(document.createTextNode(cssObject[id]));\r\n    \r\n    return el;\r\n  }\r\n  \r\n  function appendCSSElement(id) {\r\n    var el = cssElements[id];\r\n    removeChildFromParent(el);\r\n    \r\n    if (document && document.body) {\r\n      document.body.appendChild(el);\r\n    } else if (document && document.head) {\r\n      document.head.appendChild(el);\r\n    } else if (document && document.documentElement) {\r\n      document.documentElement.appendChild(el);\r\n    } else if (document) {\r\n      document.appendChild(el);\r\n    } else {\r\n      con.error(\"Browser document not found.\");\r\n    }\r\n  }\r\n  \r\n  function removeChildFromParent(el) {\r\n    if (el.parentNode) {\r\n      el.parentNode.removeChild(el);\r\n    }\r\n  }\r\n  \r\n  function setCSSElementEnabled(id, enabled) {\r\n    if (!cssObject.hasOwnProperty(id)) {\r\n      con.error(\"CSS Element \" + id + \" was not registered, make sure that it wasn\'t misspelled!\");\r\n      return;\r\n    }\r\n    \r\n    var pos = isCSSElementEnabled(id);\r\n    if (enabled) {\r\n      if (pos === -1) {\r\n        enabledCSSElements.push(id);\r\n        if (!cssElements[id]) {\r\n          cssElements[id] = createCSSElement(id);\r\n        }\r\n        appendCSSElement(id);\r\n      }\r\n    } else {\r\n      if (pos !== -1) {\r\n        enabledCSSElements.splice(pos, 1);\r\n        removeChildFromParent(cssElements[id]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  var prefix = \"ytcenter-\";\r\n  \r\n  var cssObject = {\"yt-uix\":\".ytcenter-uix-button-toggled{border-color:#c6c6c6!important;background-color:#e9e9e9!important;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,.2)!important;-ms-box-shadow:inset 0 1px 1px rgba(0,0,0,.2)!important;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.2)!important;box-shadow:inset 0 1px 1px rgba(0,0,0,.2)!important;filter:progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr=#fff8f8f8, EndColorStr=#ffeeeeee)!important;background-image:-moz-linear-gradient(top,#f8f8f8 0,#eee 100%)!important;background-image:-ms-linear-gradient(top,#f8f8f8 0,#eee 100%)!important;background-image:-o-linear-gradient(top,#f8f8f8 0,#eee 100%)!important;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#f8f8f8),color-stop(100%,#eee))!important;background-image:-webkit-linear-gradient(top,#f8f8f8 0,#eee 100%)!important;background-image:linear-gradient(to bottom,#f8f8f8 0,#eee 100%)!important}\"};\r\n  var cssElements = {};\r\n  var enabledCSSElements = [];\r\n  \r\n  exports.setEnabled = setCSSElementEnabled;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/css.js");

eval("define(\'buttons/repeat\',[\"exports\", \"../utils\", \"../player/listeners\", \"../player/player\", \"../element-placement/watch8-ytcenter-buttons\", \"../css\"], function(exports, utils, listener, player, group, css){\r\n  function createButton() {\r\n    var btn = document.createElement(\"button\");\r\n    btn.setAttribute(\"type\", \"button\");\r\n    btn.setAttribute(\"role\", \"button\");\r\n    btn.setAttribute(\"onclick\", \";return false;\");\r\n    btn.setAttribute(\"title\", \"Toggle repeat\");\r\n    btn.setAttribute(\"data-tooltip-text\", \"Toggle repeat\");\r\n    btn.className = \"yt-uix-button yt-uix-tooltip yt-uix-button-opacity\";\r\n    \r\n    var text = document.createElement(\"span\");\r\n    text.className = \"yt-uix-button-content\";\r\n    text.textContent = \"Repeat\";\r\n    \r\n    btn.appendChild(text);\r\n    \r\n    btn.addEventListener(\"click\", toggleRepeat, false);\r\n    return btn;\r\n  }\r\n  \r\n  function toggleRepeat(e) {\r\n    repeat = !repeat;\r\n    \r\n    if (repeat) {\r\n      utils.removeClass(repeatButton, \"yt-uix-button-opacity\");\r\n      utils.addClass(repeatButton, \"ytcenter-uix-button-toggled\");\r\n    } else {\r\n      utils.addClass(repeatButton, \"yt-uix-button-opacity\");\r\n      utils.removeClass(repeatButton, \"ytcenter-uix-button-toggled\");\r\n    }\r\n  }\r\n  \r\n  function onStateChange(state) {\r\n    if (state === 0 && repeat) {\r\n      player.api.playVideo();\r\n    }\r\n  }\r\n  \r\n  function getButton() {\r\n    return repeatButton;\r\n  }\r\n  \r\n  var repeat = false;\r\n  var repeatButton = createButton();\r\n  \r\n  group.addElement(\"/*should probably have a guid here*/\", repeatButton);\r\n  \r\n  listener.addEventListener(\"onStateChange\", onStateChange);\r\n  \r\n  css.setEnabled(\"yt-uix\", true);\r\n  \r\n  exports.getButton = getButton;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/buttons/repeat.js");

eval("define(\'main\',[\"buttons/repeat\"], function(repeatButton){\r\n  \r\n});\n//# sourceURL=/main.js");


require(["main"]);
}());
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJtYWluLWFsbC5qcyIsCiAgInNvdXJjZXMiOiBbCiAgICAiLi4vdmVuZG9yL2FsbW9uZC5qcyIsCiAgICAidW5zYWZlV2luZG93LmpzIiwKICAgICJoZWxwZXIvc3VwcG9ydC5qcyIsCiAgICAidXRpbHMuanMiLAogICAgInBsYXllci9hcGkuanMiLAogICAgImNvbnNvbGUuanMiLAogICAgInBsYXllci9jb25maWcuanMiLAogICAgInVuc2FmZVlvdVR1YmVDZW50ZXIuanMiLAogICAgInBsYXllci9vbllvdVR1YmVQbGF5ZXJSZWFkeS5qcyIsCiAgICAicGFnZWxvYWQuanMiLAogICAgInl0cmVhZHkuanMiLAogICAgInBsYXllci9saXN0ZW5lcnMvb3JpZ2lucy5qcyIsCiAgICAicGxheWVyL2xpc3RlbmVycy9ldmVudHMuanMiLAogICAgInBsYXllci9saXN0ZW5lcnMuanMiLAogICAgIndpbmRvdy5qcyIsCiAgICAicGxheWVyL3NpemUuanMiLAogICAgInBsYXllci9FbGVtZW50VHlwZS5qcyIsCiAgICAicGxheWVyL3BsYXllci5qcyIsCiAgICAicGxhY2VtZW50LWRyYWdkcm9wLmpzIiwKICAgICJlbGVtZW50LXBsYWNlbWVudC5qcyIsCiAgICAiZWxlbWVudC1wbGFjZW1lbnQvd2F0Y2g4LXl0Y2VudGVyLWJ1dHRvbnMuanMiLAogICAgImNzcy5qcyIsCiAgICAiYnV0dG9ucy9yZXBlYXQuanMiLAogICAgIm1haW4uanMiCiAgXSwKICAibmFtZXMiOiBbXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEFDSkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQUNBLEFDRkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQ0RBLEFERUE7QUNEQTtBQ0RBLEFERUE7QUNEQTtBQUNBLEFDRkE7QUFDQTtBQUNBIiwKICAic291cmNlc0NvbnRlbnQiOiBbCiAgICAiZXZhbChcIi8qKlxcclxcbiAqIEBsaWNlbnNlIGFsbW9uZCAwLjIuOSBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgVGhlIERvam8gRm91bmRhdGlvbiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcclxcbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXFxyXFxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL2FsbW9uZCBmb3IgZGV0YWlsc1xcclxcbiAqL1xcclxcbi8vR29pbmcgc2xvcHB5IHRvIGF2b2lkIFxcJ3VzZSBzdHJpY3RcXCcgc3RyaW5nIGNvc3QsIGJ1dCBzdHJpY3QgcHJhY3RpY2VzIHNob3VsZFxcclxcbi8vYmUgZm9sbG93ZWQuXFxyXFxuLypqc2xpbnQgc2xvcHB5OiB0cnVlICovXFxyXFxuLypnbG9iYWwgc2V0VGltZW91dDogZmFsc2UgKi9cXHJcXG5cXHJcXG52YXIgcmVxdWlyZWpzLCByZXF1aXJlLCBkZWZpbmU7XFxyXFxuKGZ1bmN0aW9uICh1bmRlZikge1xcclxcbiAgICB2YXIgbWFpbiwgcmVxLCBtYWtlTWFwLCBoYW5kbGVycyxcXHJcXG4gICAgICAgIGRlZmluZWQgPSB7fSxcXHJcXG4gICAgICAgIHdhaXRpbmcgPSB7fSxcXHJcXG4gICAgICAgIGNvbmZpZyA9IHt9LFxcclxcbiAgICAgICAgZGVmaW5pbmcgPSB7fSxcXHJcXG4gICAgICAgIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXFxyXFxuICAgICAgICBhcHMgPSBbXS5zbGljZSxcXHJcXG4gICAgICAgIGpzU3VmZml4UmVnRXhwID0gL1xcXFwuanMkLztcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gaGFzUHJvcChvYmosIHByb3ApIHtcXHJcXG4gICAgICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIHByb3ApO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBHaXZlbiBhIHJlbGF0aXZlIG1vZHVsZSBuYW1lLCBsaWtlIC4vc29tZXRoaW5nLCBub3JtYWxpemUgaXQgdG9cXHJcXG4gICAgICogYSByZWFsIG5hbWUgdGhhdCBjYW4gYmUgbWFwcGVkIHRvIGEgcGF0aC5cXHJcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIHJlbGF0aXZlIG5hbWVcXHJcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJhc2VOYW1lIGEgcmVhbCBuYW1lIHRoYXQgdGhlIG5hbWUgYXJnIGlzIHJlbGF0aXZlXFxyXFxuICAgICAqIHRvLlxcclxcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBub3JtYWxpemVkIG5hbWVcXHJcXG4gICAgICovXFxyXFxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xcclxcbiAgICAgICAgdmFyIG5hbWVQYXJ0cywgbmFtZVNlZ21lbnQsIG1hcFZhbHVlLCBmb3VuZE1hcCwgbGFzdEluZGV4LFxcclxcbiAgICAgICAgICAgIGZvdW5kSSwgZm91bmRTdGFyTWFwLCBzdGFySSwgaSwgaiwgcGFydCxcXHJcXG4gICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZSAmJiBiYXNlTmFtZS5zcGxpdChcXFwiL1xcXCIpLFxcclxcbiAgICAgICAgICAgIG1hcCA9IGNvbmZpZy5tYXAsXFxyXFxuICAgICAgICAgICAgc3Rhck1hcCA9IChtYXAgJiYgbWFwW1xcJypcXCddKSB8fCB7fTtcXHJcXG5cXHJcXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cXHJcXG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUuY2hhckF0KDApID09PSBcXFwiLlxcXCIpIHtcXHJcXG4gICAgICAgICAgICAvL0lmIGhhdmUgYSBiYXNlIG5hbWUsIHRyeSB0byBub3JtYWxpemUgYWdhaW5zdCBpdCxcXHJcXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXFxyXFxuICAgICAgICAgICAgLy9iZSByZWxhdGl2ZSB0byBiYXNlVXJsIGluIHRoZSBlbmQuXFxyXFxuICAgICAgICAgICAgaWYgKGJhc2VOYW1lKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vQ29udmVydCBiYXNlTmFtZSB0byBhcnJheSwgYW5kIGxvcCBvZmYgdGhlIGxhc3QgcGFydCxcXHJcXG4gICAgICAgICAgICAgICAgLy9zbyB0aGF0IC4gbWF0Y2hlcyB0aGF0IFxcXCJkaXJlY3RvcnlcXFwiIGFuZCBub3QgbmFtZSBvZiB0aGUgYmFzZU5hbWVcXCdzXFxyXFxuICAgICAgICAgICAgICAgIC8vbW9kdWxlLiBGb3IgaW5zdGFuY2UsIGJhc2VOYW1lIG9mIFxcXCJvbmUvdHdvL3RocmVlXFxcIiwgbWFwcyB0b1xcclxcbiAgICAgICAgICAgICAgICAvL1xcXCJvbmUvdHdvL3RocmVlLmpzXFxcIiwgYnV0IHdlIHdhbnQgdGhlIGRpcmVjdG9yeSwgXFxcIm9uZS90d29cXFwiIGZvclxcclxcbiAgICAgICAgICAgICAgICAvL3RoaXMgbm9ybWFsaXphdGlvbi5cXHJcXG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoXFwnL1xcJyk7XFxyXFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG5hbWUubGVuZ3RoIC0gMTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gTm9kZSAuanMgYWxsb3dhbmNlOlxcclxcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLm5vZGVJZENvbXBhdCAmJiBqc1N1ZmZpeFJlZ0V4cC50ZXN0KG5hbWVbbGFzdEluZGV4XSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVbbGFzdEluZGV4XSA9IG5hbWVbbGFzdEluZGV4XS5yZXBsYWNlKGpzU3VmZml4UmVnRXhwLCBcXCdcXCcpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvL3N0YXJ0IHRyaW1Eb3RzXFxyXFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSArPSAxKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gbmFtZVtpXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSBcXFwiLlxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpLCAxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFxcXCIuLlxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAobmFtZVsyXSA9PT0gXFwnLi5cXCcgfHwgbmFtZVswXSA9PT0gXFwnLi5cXCcpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRW5kIG9mIHRoZSBsaW5lLiBLZWVwIGF0IGxlYXN0IG9uZSBub24tZG90XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGF0aCBzZWdtZW50IGF0IHRoZSBmcm9udCBzbyBpdCBjYW4gYmUgbWFwcGVkXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdGx5IHRvIGRpc2suIE90aGVyd2lzZSwgdGhlcmUgaXMgbGlrZWx5XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm8gcGF0aCBtYXBwaW5nIGZvciBhIHBhdGggc3RhcnRpbmcgd2l0aCBcXCcuLlxcJy5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBzdGlsbCBmYWlsLCBidXQgY2F0Y2hlcyB0aGUgbW9zdCByZWFzb25hYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNlcyBvZiAuLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGkgLSAxLCAyKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAvL2VuZCB0cmltRG90c1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5qb2luKFxcXCIvXFxcIik7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXFwnLi9cXCcpID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIE5vIGJhc2VOYW1lLCBzbyB0aGlzIGlzIElEIGlzIHJlc29sdmVkIHJlbGF0aXZlXFxyXFxuICAgICAgICAgICAgICAgIC8vIHRvIGJhc2VVcmwsIHB1bGwgb2ZmIHRoZSBsZWFkaW5nIGRvdC5cXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDIpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vQXBwbHkgbWFwIGNvbmZpZyBpZiBhdmFpbGFibGUuXFxyXFxuICAgICAgICBpZiAoKGJhc2VQYXJ0cyB8fCBzdGFyTWFwKSAmJiBtYXApIHtcXHJcXG4gICAgICAgICAgICBuYW1lUGFydHMgPSBuYW1lLnNwbGl0KFxcJy9cXCcpO1xcclxcblxcclxcbiAgICAgICAgICAgIGZvciAoaSA9IG5hbWVQYXJ0cy5sZW5ndGg7IGkgPiAwOyBpIC09IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZVNlZ21lbnQgPSBuYW1lUGFydHMuc2xpY2UoMCwgaSkuam9pbihcXFwiL1xcXCIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVBhcnRzKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvL0ZpbmQgdGhlIGxvbmdlc3QgYmFzZU5hbWUgc2VnbWVudCBtYXRjaCBpbiB0aGUgY29uZmlnLlxcclxcbiAgICAgICAgICAgICAgICAgICAgLy9TbywgZG8gam9pbnMgb24gdGhlIGJpZ2dlc3QgdG8gc21hbGxlc3QgbGVuZ3RocyBvZiBiYXNlUGFydHMuXFxyXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBiYXNlUGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBtYXBbYmFzZVBhcnRzLnNsaWNlKDAsIGopLmpvaW4oXFwnL1xcJyldO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFzZU5hbWUgc2VnbWVudCBoYXMgIGNvbmZpZywgZmluZCBpZiBpdCBoYXMgb25lIGZvclxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBuYW1lLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFZhbHVlW25hbWVTZWdtZW50XTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01hdGNoLCB1cGRhdGUgbmFtZSB0byB0aGUgbmV3IHZhbHVlLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXAgPSBtYXBWYWx1ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSSA9IGk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGEgc3RhciBtYXAgbWF0Y2gsIGJ1dCBqdXN0IGhvbGQgb24gdG8gaXQsXFxyXFxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUgaXMgYSBzaG9ydGVyIHNlZ21lbnQgbWF0Y2ggbGF0ZXIgaW4gYSBtYXRjaGluZ1xcclxcbiAgICAgICAgICAgICAgICAvL2NvbmZpZywgdGhlbiBmYXZvciBvdmVyIHRoaXMgc3RhciBtYXAuXFxyXFxuICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFyTWFwICYmIHN0YXJNYXAgJiYgc3Rhck1hcFtuYW1lU2VnbWVudF0pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3Rhck1hcCA9IHN0YXJNYXBbbmFtZVNlZ21lbnRdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3RhckkgPSBpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmICghZm91bmRNYXAgJiYgZm91bmRTdGFyTWFwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGZvdW5kTWFwID0gZm91bmRTdGFyTWFwO1xcclxcbiAgICAgICAgICAgICAgICBmb3VuZEkgPSBzdGFySTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XFxyXFxuICAgICAgICAgICAgICAgIG5hbWVQYXJ0cy5zcGxpY2UoMCwgZm91bmRJLCBmb3VuZE1hcCk7XFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lUGFydHMuam9pbihcXCcvXFwnKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICByZXR1cm4gbmFtZTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBtYWtlUmVxdWlyZShyZWxOYW1lLCBmb3JjZVN5bmMpIHtcXHJcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgLy9BIHZlcnNpb24gb2YgYSByZXF1aXJlIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIGEgbW9kdWxlTmFtZVxcclxcbiAgICAgICAgICAgIC8vdmFsdWUgZm9yIGl0ZW1zIHRoYXQgbWF5IG5lZWQgdG9cXHJcXG4gICAgICAgICAgICAvL2xvb2sgdXAgcGF0aHMgcmVsYXRpdmUgdG8gdGhlIG1vZHVsZU5hbWVcXHJcXG4gICAgICAgICAgICByZXR1cm4gcmVxLmFwcGx5KHVuZGVmLCBhcHMuY2FsbChhcmd1bWVudHMsIDApLmNvbmNhdChbcmVsTmFtZSwgZm9yY2VTeW5jXSkpO1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcXHJcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGRlcE5hbWUpIHtcXHJcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcXHJcXG4gICAgICAgICAgICBkZWZpbmVkW2RlcE5hbWVdID0gdmFsdWU7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIGNhbGxEZXAobmFtZSkge1xcclxcbiAgICAgICAgaWYgKGhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcXHJcXG4gICAgICAgICAgICB2YXIgYXJncyA9IHdhaXRpbmdbbmFtZV07XFxyXFxuICAgICAgICAgICAgZGVsZXRlIHdhaXRpbmdbbmFtZV07XFxyXFxuICAgICAgICAgICAgZGVmaW5pbmdbbmFtZV0gPSB0cnVlO1xcclxcbiAgICAgICAgICAgIG1haW4uYXBwbHkodW5kZWYsIGFyZ3MpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKCFoYXNQcm9wKGRlZmluZWQsIG5hbWUpICYmICFoYXNQcm9wKGRlZmluaW5nLCBuYW1lKSkge1xcclxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXCdObyBcXCcgKyBuYW1lKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBkZWZpbmVkW25hbWVdO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vVHVybnMgYSBwbHVnaW4hcmVzb3VyY2UgdG8gW3BsdWdpbiwgcmVzb3VyY2VdXFxyXFxuICAgIC8vd2l0aCB0aGUgcGx1Z2luIGJlaW5nIHVuZGVmaW5lZCBpZiB0aGUgbmFtZVxcclxcbiAgICAvL2RpZCBub3QgaGF2ZSBhIHBsdWdpbiBwcmVmaXguXFxyXFxuICAgIGZ1bmN0aW9uIHNwbGl0UHJlZml4KG5hbWUpIHtcXHJcXG4gICAgICAgIHZhciBwcmVmaXgsXFxyXFxuICAgICAgICAgICAgaW5kZXggPSBuYW1lID8gbmFtZS5pbmRleE9mKFxcJyFcXCcpIDogLTE7XFxyXFxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xcclxcbiAgICAgICAgICAgIHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KTtcXHJcXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxLCBuYW1lLmxlbmd0aCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIE1ha2VzIGEgbmFtZSBtYXAsIG5vcm1hbGl6aW5nIHRoZSBuYW1lLCBhbmQgdXNpbmcgYSBwbHVnaW5cXHJcXG4gICAgICogZm9yIG5vcm1hbGl6YXRpb24gaWYgbmVjZXNzYXJ5LiBHcmFicyBhIHJlZiB0byBwbHVnaW5cXHJcXG4gICAgICogdG9vLCBhcyBhbiBvcHRpbWl6YXRpb24uXFxyXFxuICAgICAqL1xcclxcbiAgICBtYWtlTWFwID0gZnVuY3Rpb24gKG5hbWUsIHJlbE5hbWUpIHtcXHJcXG4gICAgICAgIHZhciBwbHVnaW4sXFxyXFxuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKSxcXHJcXG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXTtcXHJcXG5cXHJcXG4gICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChwcmVmaXgpIHtcXHJcXG4gICAgICAgICAgICBwcmVmaXggPSBub3JtYWxpemUocHJlZml4LCByZWxOYW1lKTtcXHJcXG4gICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL05vcm1hbGl6ZSBhY2NvcmRpbmdcXHJcXG4gICAgICAgIGlmIChwcmVmaXgpIHtcXHJcXG4gICAgICAgICAgICBpZiAocGx1Z2luICYmIHBsdWdpbi5ub3JtYWxpemUpIHtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IHBsdWdpbi5ub3JtYWxpemUobmFtZSwgbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSk7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XFxyXFxuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKTtcXHJcXG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXTtcXHJcXG4gICAgICAgICAgICBuYW1lID0gcGFydHNbMV07XFxyXFxuICAgICAgICAgICAgaWYgKHByZWZpeCkge1xcclxcbiAgICAgICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy9Vc2luZyByaWRpY3Vsb3VzIHByb3BlcnR5IG5hbWVzIGZvciBzcGFjZSByZWFzb25zXFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIGY6IHByZWZpeCA/IHByZWZpeCArIFxcJyFcXCcgKyBuYW1lIDogbmFtZSwgLy9mdWxsTmFtZVxcclxcbiAgICAgICAgICAgIG46IG5hbWUsXFxyXFxuICAgICAgICAgICAgcHI6IHByZWZpeCxcXHJcXG4gICAgICAgICAgICBwOiBwbHVnaW5cXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIG1ha2VDb25maWcobmFtZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gKGNvbmZpZyAmJiBjb25maWcuY29uZmlnICYmIGNvbmZpZy5jb25maWdbbmFtZV0pIHx8IHt9O1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBoYW5kbGVycyA9IHtcXHJcXG4gICAgICAgIHJlcXVpcmU6IGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKG5hbWUpO1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGV4cG9ydHM6IGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGUgPSBkZWZpbmVkW25hbWVdO1xcclxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZSAhPT0gXFwndW5kZWZpbmVkXFwnKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAoZGVmaW5lZFtuYW1lXSA9IHt9KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgbW9kdWxlOiBmdW5jdGlvbiAobmFtZSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIGlkOiBuYW1lLFxcclxcbiAgICAgICAgICAgICAgICB1cmk6IFxcJ1xcJyxcXHJcXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZGVmaW5lZFtuYW1lXSxcXHJcXG4gICAgICAgICAgICAgICAgY29uZmlnOiBtYWtlQ29uZmlnKG5hbWUpXFxyXFxuICAgICAgICAgICAgfTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgbWFpbiA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSkge1xcclxcbiAgICAgICAgdmFyIGNqc01vZHVsZSwgZGVwTmFtZSwgcmV0LCBtYXAsIGksXFxyXFxuICAgICAgICAgICAgYXJncyA9IFtdLFxcclxcbiAgICAgICAgICAgIGNhbGxiYWNrVHlwZSA9IHR5cGVvZiBjYWxsYmFjayxcXHJcXG4gICAgICAgICAgICB1c2luZ0V4cG9ydHM7XFxyXFxuXFxyXFxuICAgICAgICAvL1VzZSBuYW1lIGlmIG5vIHJlbE5hbWVcXHJcXG4gICAgICAgIHJlbE5hbWUgPSByZWxOYW1lIHx8IG5hbWU7XFxyXFxuXFxyXFxuICAgICAgICAvL0NhbGwgdGhlIGNhbGxiYWNrIHRvIGRlZmluZSB0aGUgbW9kdWxlLCBpZiBuZWNlc3NhcnkuXFxyXFxuICAgICAgICBpZiAoY2FsbGJhY2tUeXBlID09PSBcXCd1bmRlZmluZWRcXCcgfHwgY2FsbGJhY2tUeXBlID09PSBcXCdmdW5jdGlvblxcJykge1xcclxcbiAgICAgICAgICAgIC8vUHVsbCBvdXQgdGhlIGRlZmluZWQgZGVwZW5kZW5jaWVzIGFuZCBwYXNzIHRoZSBvcmRlcmVkXFxyXFxuICAgICAgICAgICAgLy92YWx1ZXMgdG8gdGhlIGNhbGxiYWNrLlxcclxcbiAgICAgICAgICAgIC8vRGVmYXVsdCB0byBbcmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlXSBpZiBubyBkZXBzXFxyXFxuICAgICAgICAgICAgZGVwcyA9ICFkZXBzLmxlbmd0aCAmJiBjYWxsYmFjay5sZW5ndGggPyBbXFwncmVxdWlyZVxcJywgXFwnZXhwb3J0c1xcJywgXFwnbW9kdWxlXFwnXSA6IGRlcHM7XFxyXFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpICs9IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgbWFwID0gbWFrZU1hcChkZXBzW2ldLCByZWxOYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IG1hcC5mO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvL0Zhc3QgcGF0aCBDb21tb25KUyBzdGFuZGFyZCBkZXBlbmRlbmNpZXMuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChkZXBOYW1lID09PSBcXFwicmVxdWlyZVxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5yZXF1aXJlKG5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFxcXCJleHBvcnRzXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcXHJcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5leHBvcnRzKG5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdXNpbmdFeHBvcnRzID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcXFwibW9kdWxlXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZSA9IGFyZ3NbaV0gPSBoYW5kbGVycy5tb2R1bGUobmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzUHJvcChkZWZpbmVkLCBkZXBOYW1lKSB8fFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb3Aod2FpdGluZywgZGVwTmFtZSkgfHxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKGRlZmluaW5nLCBkZXBOYW1lKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGNhbGxEZXAoZGVwTmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwLnApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcC5wLmxvYWQobWFwLm4sIG1ha2VSZXF1aXJlKHJlbE5hbWUsIHRydWUpLCBtYWtlTG9hZChkZXBOYW1lKSwge30pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGRlZmluZWRbZGVwTmFtZV07XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFxcJyBtaXNzaW5nIFxcJyArIGRlcE5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIHJldCA9IGNhbGxiYWNrID8gY2FsbGJhY2suYXBwbHkoZGVmaW5lZFtuYW1lXSwgYXJncykgOiB1bmRlZmluZWQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9JZiBzZXR0aW5nIGV4cG9ydHMgdmlhIFxcXCJtb2R1bGVcXFwiIGlzIGluIHBsYXksXFxyXFxuICAgICAgICAgICAgICAgIC8vZmF2b3IgdGhhdCBvdmVyIHJldHVybiB2YWx1ZSBhbmQgZXhwb3J0cy4gQWZ0ZXIgdGhhdCxcXHJcXG4gICAgICAgICAgICAgICAgLy9mYXZvciBhIG5vbi11bmRlZmluZWQgcmV0dXJuIHZhbHVlIG92ZXIgZXhwb3J0cyB1c2UuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChjanNNb2R1bGUgJiYgY2pzTW9kdWxlLmV4cG9ydHMgIT09IHVuZGVmICYmXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlLmV4cG9ydHMgIT09IGRlZmluZWRbbmFtZV0pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSBjanNNb2R1bGUuZXhwb3J0cztcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmIHx8ICF1c2luZ0V4cG9ydHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vVXNlIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXFxyXFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gcmV0O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgLy9NYXkganVzdCBiZSBhbiBvYmplY3QgZGVmaW5pdGlvbiBmb3IgdGhlIG1vZHVsZS4gT25seVxcclxcbiAgICAgICAgICAgIC8vd29ycnkgYWJvdXQgZGVmaW5pbmcgaWYgaGF2ZSBhIG1vZHVsZSBuYW1lLlxcclxcbiAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSBjYWxsYmFjaztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgcmVxdWlyZWpzID0gcmVxdWlyZSA9IHJlcSA9IGZ1bmN0aW9uIChkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSwgZm9yY2VTeW5jLCBhbHQpIHtcXHJcXG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNbZGVwc10pIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpbiB0aGlzIGNhc2UgaXMgcmVhbGx5IHJlbE5hbWVcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2RlcHNdKGNhbGxiYWNrKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgLy9KdXN0IHJldHVybiB0aGUgbW9kdWxlIHdhbnRlZC4gSW4gdGhpcyBzY2VuYXJpbywgdGhlXFxyXFxuICAgICAgICAgICAgLy9kZXBzIGFyZyBpcyB0aGUgbW9kdWxlIG5hbWUsIGFuZCBzZWNvbmQgYXJnIChpZiBwYXNzZWQpXFxyXFxuICAgICAgICAgICAgLy9pcyBqdXN0IHRoZSByZWxOYW1lLlxcclxcbiAgICAgICAgICAgIC8vTm9ybWFsaXplIG1vZHVsZSBuYW1lLCBpZiBpdCBjb250YWlucyAuIG9yIC4uXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxEZXAobWFrZU1hcChkZXBzLCBjYWxsYmFjaykuZik7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKCFkZXBzLnNwbGljZSkge1xcclxcbiAgICAgICAgICAgIC8vZGVwcyBpcyBhIGNvbmZpZyBvYmplY3QsIG5vdCBhbiBhcnJheS5cXHJcXG4gICAgICAgICAgICBjb25maWcgPSBkZXBzO1xcclxcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVwcykge1xcclxcbiAgICAgICAgICAgICAgICByZXEoY29uZmlnLmRlcHMsIGNvbmZpZy5jYWxsYmFjayk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suc3BsaWNlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgaXMgYW4gYXJyYXksIHdoaWNoIG1lYW5zIGl0IGlzIGEgZGVwZW5kZW5jeSBsaXN0LlxcclxcbiAgICAgICAgICAgICAgICAvL0FkanVzdCBhcmdzIGlmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXNcXHJcXG4gICAgICAgICAgICAgICAgZGVwcyA9IGNhbGxiYWNrO1xcclxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHJlbE5hbWU7XFxyXFxuICAgICAgICAgICAgICAgIHJlbE5hbWUgPSBudWxsO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIGRlcHMgPSB1bmRlZjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL1N1cHBvcnQgcmVxdWlyZShbXFwnYVxcJ10pXFxyXFxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xcclxcblxcclxcbiAgICAgICAgLy9JZiByZWxOYW1lIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGFuIGVycmJhY2sgaGFuZGxlcixcXHJcXG4gICAgICAgIC8vc28gcmVtb3ZlIGl0LlxcclxcbiAgICAgICAgaWYgKHR5cGVvZiByZWxOYW1lID09PSBcXCdmdW5jdGlvblxcJykge1xcclxcbiAgICAgICAgICAgIHJlbE5hbWUgPSBmb3JjZVN5bmM7XFxyXFxuICAgICAgICAgICAgZm9yY2VTeW5jID0gYWx0O1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy9TaW11bGF0ZSBhc3luYyBjYWxsYmFjaztcXHJcXG4gICAgICAgIGlmIChmb3JjZVN5bmMpIHtcXHJcXG4gICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIC8vVXNpbmcgYSBub24temVybyB2YWx1ZSBiZWNhdXNlIG9mIGNvbmNlcm4gZm9yIHdoYXQgb2xkIGJyb3dzZXJzXFxyXFxuICAgICAgICAgICAgLy9kbywgYW5kIGxhdGVzdCBicm93c2VycyBcXFwidXBncmFkZVxcXCIgdG8gNCBpZiBsb3dlciB2YWx1ZSBpcyB1c2VkOlxcclxcbiAgICAgICAgICAgIC8vaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0OlxcclxcbiAgICAgICAgICAgIC8vSWYgd2FudCBhIHZhbHVlIGltbWVkaWF0ZWx5LCB1c2UgcmVxdWlyZShcXCdpZFxcJykgaW5zdGVhZCAtLSBzb21ldGhpbmdcXHJcXG4gICAgICAgICAgICAvL3RoYXQgd29ya3MgaW4gYWxtb25kIG9uIHRoZSBnbG9iYWwgbGV2ZWwsIGJ1dCBub3QgZ3VhcmFudGVlZCBhbmRcXHJcXG4gICAgICAgICAgICAvL3VubGlrZWx5IHRvIHdvcmsgaW4gb3RoZXIgQU1EIGltcGxlbWVudGF0aW9ucy5cXHJcXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgbWFpbih1bmRlZiwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgIH0sIDQpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgcmV0dXJuIHJlcTtcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEp1c3QgZHJvcHMgdGhlIGNvbmZpZyBvbiB0aGUgZmxvb3IsIGJ1dCByZXR1cm5zIHJlcSBpbiBjYXNlXFxyXFxuICAgICAqIHRoZSBjb25maWcgcmV0dXJuIHZhbHVlIGlzIHVzZWQuXFxyXFxuICAgICAqL1xcclxcbiAgICByZXEuY29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xcclxcbiAgICAgICAgcmV0dXJuIHJlcShjZmcpO1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogRXhwb3NlIG1vZHVsZSByZWdpc3RyeSBmb3IgZGVidWdnaW5nIGFuZCB0b29saW5nXFxyXFxuICAgICAqL1xcclxcbiAgICByZXF1aXJlanMuX2RlZmluZWQgPSBkZWZpbmVkO1xcclxcblxcclxcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2spIHtcXHJcXG5cXHJcXG4gICAgICAgIC8vVGhpcyBtb2R1bGUgbWF5IG5vdCBoYXZlIGRlcGVuZGVuY2llc1xcclxcbiAgICAgICAgaWYgKCFkZXBzLnNwbGljZSkge1xcclxcbiAgICAgICAgICAgIC8vZGVwcyBpcyBub3QgYW4gYXJyYXksIHNvIHByb2JhYmx5IG1lYW5zXFxyXFxuICAgICAgICAgICAgLy9hbiBvYmplY3QgbGl0ZXJhbCBvciBmYWN0b3J5IGZ1bmN0aW9uIGZvclxcclxcbiAgICAgICAgICAgIC8vdGhlIHZhbHVlLiBBZGp1c3QgYXJncy5cXHJcXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XFxyXFxuICAgICAgICAgICAgZGVwcyA9IFtdO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKCFoYXNQcm9wKGRlZmluZWQsIG5hbWUpICYmICFoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XFxyXFxuICAgICAgICAgICAgd2FpdGluZ1tuYW1lXSA9IFtuYW1lLCBkZXBzLCBjYWxsYmFja107XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIGRlZmluZS5hbWQgPSB7XFxyXFxuICAgICAgICBqUXVlcnk6IHRydWVcXHJcXG4gICAgfTtcXHJcXG59KCkpO1xcclxcblxcbi8vIyBzb3VyY2VVUkw9Ly4uL3ZlbmRvci9hbG1vbmQuanNcIik7XG5cbmRlZmluZShcIi4uL3ZlbmRvci9hbG1vbmRcIiwgZnVuY3Rpb24oKXt9KTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3Vuc2FmZVdpbmRvd1xcJyxbXSwgZnVuY3Rpb24oKXtcXHJcXG4gIHJldHVybiB3aW5kb3c7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vdW5zYWZlV2luZG93LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCIvKipcXHJcXG4qIEEgaGVscGVyIGNsYXNzIHRvIGhlbHAgY2hlY2tpbmcgZm9yIGZlYXR1cmVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cXHJcXG4qIEBuYW1lc3BhY2UgaGVscGVyXFxyXFxuKiBAY2xhc3MgU3VwcG9ydFxcclxcbioqL1xcclxcbmRlZmluZShcXCdoZWxwZXIvc3VwcG9ydFxcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwidW5zYWZlV2luZG93XFxcIl0sIGZ1bmN0aW9uKGV4cG9ydHMsIHV3KXtcXHJcXG4gIC8qKlxcclxcbiAgKiBQZXJmb3JtaW5nIGEgc2ltcGxlIExvY2FsU3RvcmFnZSBzZXQsIGdldCB0ZXN0LlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgbG9jYWxTdG9yYWdlVGVzdFxcclxcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgTG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gbG9jYWxTdG9yYWdlVGVzdCgpIHtcXHJcXG4gICAgdmFyIG1vZCA9IFxcXCJzdXBwb3J0LnRlc3RcXFwiO1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcXHJcXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xcclxcbiAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBgd2Via2l0VVJMYCBpcyBhbiBvYmplY3QuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGlzV2Via2l0VVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgdmFyIGlzV2Via2l0VVJMID0gdHlwZW9mIHV3LndlYmtpdFVSTCA9PT0gXFxcIm9iamVjdFxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBgVVJMYCBpcyBhbiBvYmplY3QuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGlzVVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgdmFyIGlzVVJMID0gdHlwZW9mIHV3LlVSTCA9PT0gXFxcIm9iamVjdFxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBNYXh0aG9uIHJ1bnRpbWUgaXMgYWNjZXNzaWJsZS5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgbWF4dGhvblJ1bnRpbWVcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgbWF4dGhvblJ1bnRpbWUgPSB3aW5kb3cgJiYgd2luZG93LmV4dGVybmFsICYmIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUgJiYgdHlwZW9mIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUgPT09IFxcXCJmdW5jdGlvblxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBgY3JlYXRlT2JqZWN0VVJMYCBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGlzQ3JlYXRlT2JqZWN0VVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgdmFyIGlzQ3JlYXRlT2JqZWN0VVJMID0gZmFsc2U7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBgcmV2b2tlT2JqZWN0VVJMYCBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGlzUmV2b2tlT2JqZWN0VVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgdmFyIGlzUmV2b2tlT2JqZWN0VVJMID0gZmFsc2U7XFxyXFxuICBpZiAoaXNXZWJraXRVUkwpIHtcXHJcXG4gICAgaXNDcmVhdGVPYmplY3RVUkwgPSB0eXBlb2YgdXcud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gICAgaXNSZXZva2VPYmplY3RVUkwgPSB0eXBlb2YgdXcud2Via2l0VVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gIH0gZWxzZSBpZiAoaXNVUkwpIHtcXHJcXG4gICAgaXNDcmVhdGVPYmplY3RVUkwgPSB0eXBlb2YgdXcuVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gICAgaXNSZXZva2VPYmplY3RVUkwgPSB0eXBlb2YgdXcuVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIExvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGxvY2FsU3RvcmFnZVxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMubG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlVGVzdCgpO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tpbmcgaWYgdGhlIEdyZWFzZW1vbmtleSBBUEkgaXMgc3VwcG9ydGVkLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBHcmVhc2Vtb25rZXlcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLkdyZWFzZW1vbmtleSA9ICh0eXBlb2YgR01fc2V0VmFsdWUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmICh0eXBlb2YgR01fc2V0VmFsdWUudG9TdHJpbmcgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8IEdNX3NldFZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZihcXFwibm90IHN1cHBvcnRlZFxcXCIpID09PSAtMSkpO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tpbmcgaWYgYGNyZWF0ZU9iamVjdFVSYCBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGNyZWF0ZU9iamVjdFVSTFxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMuY3JlYXRlT2JqZWN0VVJMID0gaXNDcmVhdGVPYmplY3RVUkw7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBgcmV2b2tlT2JqZWN0VVJMYCBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IHJldm9rZU9iamVjdFVSTFxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMucmV2b2tlT2JqZWN0VVJMID0gaXNSZXZva2VPYmplY3RVUkw7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiB0aGUgYHdlYmtpdFVSTGAgb2JqZWN0IGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgd2Via2l0VVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy53ZWJraXRVUkwgPSBpc1dlYmtpdFVSTDtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIHRoZSBgVVJMYCBvYmplY3QgaXMgc3VwcG9ydGVkLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBVUkxcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLlVSTCA9IGlzVVJMO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tpbmcgaWYgTWF4dGhvbiBydW50aW1lIGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgbWF4dGhvblJ1bnRpbWVcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm1heHRob25SdW50aW1lID0gbWF4dGhvblJ1bnRpbWU7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBNYXh0aG9uIHJ1bnRpbWUgU3RvcmFnZSBvYmplY3QgaXMgc3VwcG9ydGVkLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBtYXh0aG9uUnVudGltZVN0b3JhZ2VcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm1heHRob25SdW50aW1lU3RvcmFnZSA9IG1heHRob25SdW50aW1lICYmIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUoKSAmJiB3aW5kb3cuZXh0ZXJuYWwubXhHZXRSdW50aW1lKCkuc3RvcmFnZTtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIEZpcmVmb3ggZXh0ZW5zaW9uIHBvcnQgaXMgYWNjZXNzaWJsZS5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgZmlyZWZveFBvcnRcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLmZpcmVmb3hQb3J0ID0gdGhpcy5wb3J0ICYmIHR5cGVvZiB0aGlzLnBvcnQucmVxdWVzdCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0aGlzLnBvcnQuc3RvcmFnZSAmJiB0eXBlb2YgdGhpcy5wb3J0Lm9uID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgXFxyXFxuICByZXR1cm4gZXhwb3J0cztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9oZWxwZXIvc3VwcG9ydC5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiLyoqXFxyXFxuKiBAY2xhc3MgVXRpbHNcXHJcXG4qKi9cXHJcXG5kZWZpbmUoXFwndXRpbHNcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcIi4vaGVscGVyL3N1cHBvcnRcXFwiLCBcXFwidW5zYWZlV2luZG93XFxcIl0sIGZ1bmN0aW9uKGV4cG9ydHMsIHN1cHBvcnQsIHV3KXtcXHJcXG4gIGZ1bmN0aW9uIGVhY2gob2JqLCBjYWxsYmFjaykge1xcclxcbiAgICBpZiAoaXNBcnJheShvYmopKSB7XFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgIGlmIChjYWxsYmFjayhpLCBvYmpbaV0pID09PSB0cnVlKSBicmVhaztcXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcclxcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICAgIGlmIChjYWxsYmFjayhrZXksIG9ialtrZXldKSA9PT0gdHJ1ZSkgYnJlYWs7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XFxyXFxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gXFxcIltvYmplY3QgQXJyYXldXFxcIjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYXN5bmNDYWxsKHNjb3BlLCBjYWxsYmFjaykge1xcclxcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kLmFwcGx5KG51bGwsIFtzY29wZSwgY2FsbGJhY2tdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKSksIDApO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBiaW5kKHNjb3BlLCBmdW5jKSB7XFxyXFxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcXHJcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XFxyXFxuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKVxcclxcbiAgICB9O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB0cmltTGVmdChvYmope1xcclxcbiAgICByZXR1cm4gb2JqLnJlcGxhY2UoL15cXFxccysvLCBcXFwiXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRyaW1SaWdodChvYmope1xcclxcbiAgICByZXR1cm4gb2JqLnJlcGxhY2UoL1xcXFxzKyQvLCBcXFwiXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIG1hcChvYmosIGNhbGxiYWNrLCB0aGlzQXJnKSB7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gb2JqLmxlbmd0aCwgYSA9IFtdOyBpIDwgbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGkgaW4gb2JqKSBhW2ldID0gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBvYmpbaV0pO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBhO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogRGVmaW5lIGEgcHJvcGVydHkgd2l0aCBhIGdldHRlciBhbmQgYSBzZXR0ZXIuXFxyXFxuICAqXFxyXFxuICAqIEBtZXRob2QgZGVmaW5lUHJvcGVydHlcXHJcXG4gICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHdoZXJlIHRoZSBwcm9wZXJ0eSByZXNpZGVzIGluLlxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cXHJcXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0IFRoZSBnZXR0ZXIgZnVuY3Rpb24uXFxyXFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldCBUaGUgc2V0dGVyIGZ1bmN0aW9uLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZ2V0LCBzZXQpIHtcXHJcXG4gICAgaWYgKE9iamVjdCAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XFxyXFxuICAgICAgICBcXFwiZ2V0XFxcIjogZ2V0LFxcclxcbiAgICAgICAgXFxcInNldFxcXCI6IHNldFxcclxcbiAgICAgIH0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKGtleSwgZ2V0KTtcXHJcXG4gICAgICBvYmouX19kZWZpbmVTZXR0ZXJfXyhrZXksIHNldCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZGVmaW5lTG9ja2VkUHJvcGVydHkob2JqLCBrZXksIHNldHRlciwgZ2V0dGVyKSB7XFxyXFxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcXFwib2JqZWN0XFxcIikgb2JqID0ge307XFxyXFxuICAgIGlmIChzdXBwb3J0LmllIHx8IHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcXHJcXG4gICAgICAgIGdldDogZ2V0dGVyLFxcclxcbiAgICAgICAgc2V0OiBzZXR0ZXJcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgICByZXR1cm4gb2JqO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKGtleSwgZ2V0dGVyKTtcXHJcXG4gICAgICBvYmouX19kZWZpbmVTZXR0ZXJfXyhrZXksIHNldHRlcik7XFxyXFxuICAgICAgcmV0dXJuIG9iajtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsbSwgZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XFxyXFxuICAgIGlmIChlbG0uYWRkRXZlbnRMaXN0ZW5lcikge1xcclxcbiAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XFxyXFxuICAgIH0gZWxzZSBpZiAoZWxtLmF0dGFjaEV2ZW50KSB7XFxyXFxuICAgICAgZWxtLmF0dGFjaEV2ZW50KFxcXCJvblxcXCIgKyBldmVudCwgY2FsbGJhY2spO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxtLCBldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcXHJcXG4gICAgaWYgKGVsbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XFxyXFxuICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcXHJcXG4gICAgfSBlbHNlIGlmIChlbG0uZGV0YWNoRXZlbnQpIHtcXHJcXG4gICAgICBlbG0uZGV0YWNoRXZlbnQoXFxcIm9uXFxcIiArIGV2ZW50LCBjYWxsYmFjayk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgcmV0dXJuICtuZXcgRGF0ZTtcXHJcXG4gIH07XFxyXFxuICBcXHJcXG4gIC8qIENvb2tpZXMgKi9cXHJcXG4gIGZ1bmN0aW9uIHNldENvb2tpZShuYW1lLCB2YWx1ZSwgZG9tYWluLCBwYXRoLCBleHBpcmVzKSB7XFxyXFxuICAgIGRvbWFpbiA9IGRvbWFpbiA/IFxcXCI7ZG9tYWluPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZG9tYWluKSA6IFxcXCJcXFwiO1xcclxcbiAgICBwYXRoID0gcGF0aCA/IFxcXCI7cGF0aD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpIDogXFxcIlxcXCI7XFxyXFxuICAgIGV4cGlyZXMgPSAwID4gZXhwaXJlcyA/IFxcXCJcXFwiIDogMCA9PSBleHBpcmVzID8gXFxcIjtleHBpcmVzPVxcXCIgKyAobmV3IERhdGUoMTk3MCwgMSwgMSkpLnRvVVRDU3RyaW5nKCkgOiBcXFwiO2V4cGlyZXM9XFxcIiArIChuZXcgRGF0ZShub3coKSArIDFFMyAqIGV4cGlyZXMpKS50b1VUQ1N0cmluZygpO1xcclxcbiAgICBcXHJcXG4gICAgZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgXFxcIj1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGRvbWFpbiArIHBhdGggKyBleHBpcmVzO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRDb29raWUoa2V5KSB7XFxyXFxuICAgIHJldHVybiBnZXRDb29raWVzKClba2V5XTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0Q29va2llcygpIHtcXHJcXG4gICAgdmFyIGMgPSBkb2N1bWVudC5jb29raWUsIHYgPSAwLCBjb29raWVzID0ge307XFxyXFxuICAgIGlmIChkb2N1bWVudC5jb29raWUubWF0Y2goL15cXFxccypcXFxcJFZlcnNpb249KD86XFxcIjFcXFwifDEpO1xcXFxzKiguKikvKSkge1xcclxcbiAgICAgIGMgPSBSZWdFeHAuJDE7XFxyXFxuICAgICAgdiA9IDE7XFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKHYgPT09IDApIHtcXHJcXG4gICAgICBtYXAoYy5zcGxpdCgvWyw7XS8pLCBmdW5jdGlvbihjb29raWUpIHtcXHJcXG4gICAgICAgIHZhciBwYXJ0cyA9IGNvb2tpZS5zcGxpdCgvPS8sIDIpLFxcclxcbiAgICAgICAgICAgIG5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQodHJpbUxlZnQocGFydHNbMF0pKSxcXHJcXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBkZWNvZGVVUklDb21wb25lbnQodHJpbVJpZ2h0KHBhcnRzWzFdKSkgOiBudWxsO1xcclxcbiAgICAgICAgY29va2llc1tuYW1lXSA9IHZhbHVlO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIG1hcChjLm1hdGNoKC8oPzpefFxcXFxzKykoWyEjJCUmXFwnKitcXFxcLS4wLTlBLVpeYGEtenx+XSspPShbISMkJSZcXCcqK1xcXFwtLjAtOUEtWl5gYS16fH5dKnxcXFwiKD86W1xcXFx4MjAtXFxcXHg3RVxcXFx4ODBcXFxceEZGXXxcXFxcXFxcXFtcXFxceDAwLVxcXFx4N0ZdKSpcXFwiKSg/PVxcXFxzKlssO118JCkvZyksIGZ1bmN0aW9uKCQwLCAkMSkge1xcclxcbiAgICAgICAgdmFyIG5hbWUgPSAkMCwgdmFsdWUgPSAkMS5jaGFyQXQoMCkgPT09IFxcJ1xcXCJcXCcgPyAkMS5zdWJzdHIoMSwgLTEpLnJlcGxhY2UoL1xcXFxcXFxcKC4pL2csIFxcXCIkMVxcXCIpIDogJDE7XFxyXFxuICAgICAgICBjb29raWVzW25hbWVdID0gdmFsdWU7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGNvb2tpZXM7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KSB7XFxyXFxuICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluamVjdChmdW5jKSB7XFxyXFxuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzY3JpcHRcXFwiKSxcXHJcXG4gICAgICAgIHAgPSAoZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XFxyXFxuICAgIGlmICghcCkge1xcclxcbiAgICAgIHRocm93IFxcXCJDb3VsZCBub3QgaW5qZWN0ISEhXFxcIjtcXHJcXG4gICAgfVxcclxcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcInRleHQvamF2YXNjcmlwdFxcXCIpO1xcclxcbiAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcIihcXFwiICsgZnVuYyArIFxcXCIpKFxcXCIgKyBidWlsZEFyZ3VtZW50TGlzdC5hcHBseShudWxsLCBbZmFsc2VdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSkgKyBcXFwiKTtcXFwiKSk7XFxyXFxuICAgIHAuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcXHJcXG4gICAgcC5yZW1vdmVDaGlsZChzY3JpcHQpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBidWlsZEFyZ3VtZW50TGlzdCh3cmFwKSB7XFxyXFxuICAgIHZhciBsaXN0ID0gW107XFxyXFxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgbGlzdC5wdXNoKFxcXCJcXFxcXFxcIlxcXCIgKyBhcmdzW2ldLnJlcGxhY2UoL1xcXFxcXFxcLywgXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXFwiL2csIFxcXCJcXFxcXFxcXFxcXFxcXFwiXFxcIikgKyBcXFwiXFxcXFxcXCJcXFwiKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzW2ldID09PSBcXFwib2JqZWN0XFxcIikge1xcclxcbiAgICAgICAgbGlzdC5wdXNoKEpTT04uc3RyaW5naWZ5KGFyZ3NbaV0pKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzW2ldID09PSBcXFwidW5kZWZpbmVkXFxcIikge1xcclxcbiAgICAgICAgbGlzdC5wdXNoKFxcXCJudWxsXFxcIik7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGxpc3QucHVzaChhcmdzW2ldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKHdyYXApIHtcXHJcXG4gICAgICByZXR1cm4gXFxcIihcXFwiICsgbGlzdC5qb2luKFxcXCIsXFxcIikgKyBcXFwiKVxcXCI7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgcmV0dXJuIGxpc3Quam9pbihcXFwiLFxcXCIpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGlzSlNPTlN0cmluZyhqc29uKSB7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgSlNPTi5wYXJzZShqc29uKTtcXHJcXG4gICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24geGhyKGRldGFpbHMpIHtcXHJcXG4gICAgdmFyIHhtbGh0dHA7XFxyXFxuICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxyXFxuICAgICAgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcclxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcGVyYSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgdHlwZW9mIG9wZXJhLlhNTEh0dHBSZXF1ZXN0ICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcclxcbiAgICAgIHhtbGh0dHAgPSBuZXcgb3BlcmEuWE1MSHR0cFJlcXVlc3QoKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBpZiAoZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKSB7XFxyXFxuICAgICAgICBkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0oKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgXFxyXFxuICAgICAgcmV0dXJuO1xcclxcbiAgICB9XFxyXFxuICAgIHhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcXHJcXG4gICAgICB2YXIgcmVzcG9uc2VTdGF0ZSA9IHtcXHJcXG4gICAgICAgIHJlc3BvbnNlWE1MOih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAucmVzcG9uc2VYTUwgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgcmVzcG9uc2VUZXh0Oih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAucmVzcG9uc2VUZXh0IDogXFwnXFwnKSxcXHJcXG4gICAgICAgIHJlYWR5U3RhdGU6eG1saHR0cC5yZWFkeVN0YXRlLFxcclxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgc3RhdHVzOih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuc3RhdHVzIDogMCksXFxyXFxuICAgICAgICBzdGF0dXNUZXh0Oih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuc3RhdHVzVGV4dCA6IFxcJ1xcJyksXFxyXFxuICAgICAgICBmaW5hbFVybDooeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLmZpbmFsVXJsIDogXFwnXFwnKVxcclxcbiAgICAgIH07XFxyXFxuICAgICAgaWYgKGRldGFpbHNbXFxcIm9ucmVhZHlzdGF0ZWNoYW5nZVxcXCJdKSB7XFxyXFxuICAgICAgICBkZXRhaWxzW1xcXCJvbnJlYWR5c3RhdGVjaGFuZ2VcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0KSB7XFxyXFxuICAgICAgICBpZiAoZGV0YWlsc1tcXFwib25sb2FkXFxcIl0gJiYgeG1saHR0cC5zdGF0dXMgPj0gMjAwICYmIHhtbGh0dHAuc3RhdHVzIDwgMzAwKSB7XFxyXFxuICAgICAgICAgIGRldGFpbHNbXFxcIm9ubG9hZFxcXCJdKHJlc3BvbnNlU3RhdGUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSAmJiAoeG1saHR0cC5zdGF0dXMgPCAyMDAgfHwgeG1saHR0cC5zdGF0dXMgPj0gMzAwKSkge1xcclxcbiAgICAgICAgICBkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9O1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgIHhtbGh0dHAub3BlbihkZXRhaWxzLm1ldGhvZCwgZGV0YWlscy51cmwpO1xcclxcbiAgICB9IGNhdGNoKGUpIHtcXHJcXG4gICAgICBpZihkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0pIHtcXHJcXG4gICAgICAgIGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSh7cmVzcG9uc2VYTUw6XFwnXFwnLHJlc3BvbnNlVGV4dDpcXCdcXCcscmVhZHlTdGF0ZTo0LHJlc3BvbnNlSGVhZGVyczpcXCdcXCcsc3RhdHVzOjQwMyxzdGF0dXNUZXh0OlxcJ0ZvcmJpZGRlblxcJ30pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKGRldGFpbHMuaGVhZGVycykge1xcclxcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGV0YWlscy5oZWFkZXJzKSB7XFxyXFxuICAgICAgICB4bWxodHRwLnNldFJlcXVlc3RIZWFkZXIocHJvcCwgZGV0YWlscy5oZWFkZXJzW3Byb3BdKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgeG1saHR0cC5zZW5kKCh0eXBlb2YoZGV0YWlscy5kYXRhKSAhPSBcXCd1bmRlZmluZWRcXCcpID8gZGV0YWlscy5kYXRhIDogbnVsbCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8vIFVzZWQgZm9yIHRoZSBtZXNzYWdlIG1vZHVsZSAoc2hvdWxkIHByb2JhYmx5IG1vdmUgdG8gYW5vdGhlciBwbGFjZSlcXHJcXG4gIC8vIEl0IHJlcGxhY2VzIGEgcHJvcGVydHkgaW4gdGhlIG9iaiB0byBhIHByZWRlZmluZWQgZnVuY3Rpb24sIHdoZXJlIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBjYWxsYmFja0lkLCB0YXJnZXQsIHJlZmVyZXJcXHJcXG4gIGZ1bmN0aW9uIGJpbmRGdW5jdGlvbkNhbGxiYWNrcyhvYmosIGZ1bmMsIHRhcmdldCwgcmVmZXJlcikge1xcclxcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcXHJcXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFxcXCJvYmpcXFwiKSB7XFxyXFxuICAgICAgICAgIGJpbmRGdW5jdGlvbkNhbGxiYWNrcyhvYmpba2V5XSk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICAgICAgaWYgKG9ialtrZXldLmluZGV4T2YoXFxcIkAvKG1lc3NhZ2UuY2FsbGJhY2spL1xcXCIpID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrSWQgPSBvYmpba2V5XS5zcGxpdChcXFwiQC8obWVzc2FnZS5jYWxsYmFjaykvXFxcIilbMV07XFxyXFxuICAgICAgICAgICAgb2JqW2tleV0gPSBiaW5kKG51bGwsIGZ1bmMsIGNhbGxiYWNrSWQsIHRhcmdldCwgcmVmZXJlcik7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZGVmYXVsdHMsIGRlZXApIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFxcXCJvYmplY3RcXFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJVbnN1cHBvcnRlZCB0eXBlIGZvciBvYmouXFxcIik7XFxyXFxuICAgIGlmICh0eXBlb2YgZGVmYXVsdHMgIT09IFxcXCJvYmplY3RcXFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJVbnN1cHBvcnRlZCB0eXBlIGZvciBkZWZhdWx0cy5cXFwiKTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xcclxcbiAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgZGVmYXVsdHNba2V5XSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgZGVlcCkge1xcclxcbiAgICAgICAgICBleHRlbmQob2JqW2tleV0sIGRlZmF1bHRzW2tleV0sIGRlZXApO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c1trZXldO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gb2JqO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpbkFycmF5KGtleSwgYXJyKSB7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoYXJyW2ldID09PSBrZXkpIHtcXHJcXG4gICAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gZmFsc2U7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGxpc3RDbGFzc2VzKGVsKSB7XFxyXFxuICAgIGlmICghZWwgfHwgIWVsLmNsYXNzTmFtZSkgcmV0dXJuIFtdO1xcclxcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lLnNwbGl0KFxcXCIgXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcXHJcXG4gICAgdmFyIGNsYXNzZXMgPSBsaXN0Q2xhc3NlcyhlbCk7XFxyXFxuICAgIHZhciBhZGRMaXN0ID0gY2xhc3NOYW1lLnNwbGl0KFxcXCIgXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYWRkTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmICghaW5BcnJheShhZGRMaXN0W2ldLCBjbGFzc2VzKSkge1xcclxcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9IFxcXCIgXFxcIiArIGFkZExpc3RbaV07XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBlbC5jbGFzc05hbWU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcXHJcXG4gICAgdmFyIGNsYXNzZXMgPSBsaXN0Q2xhc3NlcyhlbCk7XFxyXFxuICAgIHZhciByZW1vdmVMaXN0ID0gY2xhc3NOYW1lLnNwbGl0KFxcXCIgXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgYnVmZmVyID0gW107XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKCFpbkFycmF5KGNsYXNzZXNbaV0sIHJlbW92ZUxpc3QpKSB7XFxyXFxuICAgICAgICBidWZmZXIucHVzaChjbGFzc2VzW2ldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGVsLmNsYXNzTmFtZSA9IGJ1ZmZlci5qb2luKFxcXCIgXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbGFzc05hbWUpIHtcXHJcXG4gICAgcmV0dXJuIGluQXJyYXkoY2xhc3NOYW1lLCBsaXN0Q2xhc3NlcyhlbCkpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBkZWxheSwgb3B0aW9ucyl7XFxyXFxuICAgIGZ1bmN0aW9uIHRpbWVvdXQoKSB7XFxyXFxuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlO1xcclxcbiAgICAgIHRpbWVyID0gbnVsbDtcXHJcXG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xcclxcbiAgICB9XFxyXFxuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQsIHRpbWVyID0gbnVsbCwgcHJldmlvdXMgPSAwO1xcclxcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXHJcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XFxyXFxuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlLCBkdDtcXHJcXG4gICAgICBcXHJcXG4gICAgICBjb250ZXh0ID0gdGhpcztcXHJcXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xcclxcbiAgICAgIFxcclxcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XFxyXFxuICAgICAgZHQgPSBkZWxheSAtIChub3cgLSBwcmV2aW91cyk7XFxyXFxuICAgICAgXFxyXFxuICAgICAgaWYgKGR0IDw9IDApIHtcXHJcXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxyXFxuICAgICAgICB0aW1lciA9IG51bGw7XFxyXFxuICAgICAgICBwcmV2aW91cyA9IG5vdztcXHJcXG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XFxyXFxuICAgICAgfSBlbHNlIGlmICghdGltZXIgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcXHJcXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aW1lb3V0LCBkdCk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxyXFxuICAgIH07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGNsb25lKG9iaikge1xcclxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhhcnIpIHtcXHJcXG4gICAgdmFyIHVuaXF1ZUFyciA9IFtdO1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKCFpbkFycmF5KHVuaXF1ZUFyciwgYXJyW2ldKSkge1xcclxcbiAgICAgICAgdW5pcXVlQXJyLnB1c2goYXJyW2ldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHJldHVybiB1bmlxdWVBcnI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcXHJcXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxcXC1cXFxcW1xcXFxdXFxcXC9cXFxce1xcXFx9XFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcP1xcXFwuXFxcXFxcXFxcXFxcXlxcXFwkXFxcXHxdL2csIFxcXCJcXFxcXFxcXCQmXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRvQmxvYihieXRlcywgY29udGVudFR5cGUpIHtcXHJcXG4gICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZSB8fCBcXFwidGV4dC9wbGFpblxcXCI7XFxyXFxuICAgIHZhciBzbGljZVNpemUgPSA1MTI7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgYnl0ZXNMZW5ndGggPSBieXRlcy5sZW5ndGg7XFxyXFxuICAgIHZhciBzbGljZXNDb3VudCA9IE1hdGguY2VpbChieXRlc0xlbmd0aCAvIHNsaWNlU2l6ZSk7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgYnl0ZUFycmF5cyA9IG5ldyBBcnJheShzbGljZXNDb3VudCk7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBzbGljZUluZGV4ID0gMDsgc2xpY2VJbmRleCA8IHNsaWNlc0NvdW50OyArK3NsaWNlSW5kZXgpIHtcXHJcXG4gICAgICB2YXIgYmVnaW4gPSBzbGljZUluZGV4ICogc2xpY2VTaXplO1xcclxcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihiZWdpbiArIHNsaWNlU2l6ZSwgYnl0ZXNMZW5ndGgpO1xcclxcbiAgICAgIFxcclxcbiAgICAgIHZhciBzbGljZUJ5dGVzID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcXHJcXG4gICAgICBmb3IgKHZhciBvZmZzZXQgPSBiZWdpbiwgaSA9IDAgOyBvZmZzZXQgPCBlbmQ7ICsraSwgKytvZmZzZXQpIHtcXHJcXG4gICAgICAgIHNsaWNlQnl0ZXNbaV0gPSBieXRlc1tvZmZzZXRdLmNoYXJDb2RlQXQoMCk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGJ5dGVBcnJheXNbc2xpY2VJbmRleF0gPSBuZXcgVWludDhBcnJheShzbGljZUJ5dGVzKTtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZTogY29udGVudFR5cGUgfSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChibG9iKSB7XFxyXFxuICAgIGlmIChzdXBwb3J0LmNyZWF0ZU9iamVjdFVSTCkge1xcclxcbiAgICAgIGlmIChzdXBwb3J0LndlYmtpdFVSTCkge1xcclxcbiAgICAgICAgcmV0dXJuIHV3LndlYmtpdFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJldHVybiB1dy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB0aHJvdyBcXFwiY3JlYXRlT2JqZWN0VVJMIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIhXFxcIjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZXZva2VPYmplY3RVUkwodXJsKSB7XFxyXFxuICAgIGlmIChzdXBwb3J0LnJldm9rZU9iamVjdFVSTCkge1xcclxcbiAgICAgIGlmIChzdXBwb3J0LndlYmtpdFVSTCkge1xcclxcbiAgICAgICAgcmV0dXJuIHV3LndlYmtpdFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIHV3LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdGhyb3cgXFxcInJldm9rZU9iamVjdFVSTCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIVxcXCI7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcclxcbiAgZnVuY3Rpb24gZ2V0UmFuZG9tQXJiaXRyYXJ5KG1pbiwgbWF4KSB7XFxyXFxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8vIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiAoaW5jbHVkZWQpIGFuZCBtYXggKGV4Y2x1ZGVkKVxcclxcbiAgZnVuY3Rpb24gZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XFxyXFxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8vIFJldHVybnMgYSByYW5kb20gc3RyaW5nIG9mIGNoYXJhY3RlcnMgb2YgY2hhcnMgd2l0aCB0aGUgbGVuZ3RoIG9mIGxlbmd0aFxcclxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVUb2tlbihjaGFycywgbGVuZ3RoKSB7XFxyXFxuICAgIGlmICh0eXBlb2YgY2hhcnMgIT09IFxcXCJzdHJpbmdcXFwiKSBjaGFycyA9IFxcXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OS1fXFxcIjtcXHJcXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggIT09IFxcXCJudW1iZXJcXFwiKSBsZW5ndGggPSA2NDtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcXHJcXG4gICAgXFxyXFxuICAgIHZhciB0b2tlbiA9IFxcXCJcXFwiO1xcclxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgdG9rZW4gKz0gY2hhcnNbZ2V0UmFuZG9tSW50KDAsIGNoYXJzTGVuZ3RoKV07XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHJldHVybiB0b2tlbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXNjYXBlRUNNQVZhcmlhYmxlKGtleSwgZGVmYXVsdEtleSkge1xcclxcbiAgICBrZXkgPSBrZXkucmVwbGFjZSgvW14wLTlhLXpBLVpfXFxcXCRdL2csIFxcXCJcXFwiKTtcXHJcXG4gICAgd2hpbGUgKC8kWzAtOV0vZy50ZXN0KGtleSkgJiYga2V5Lmxlbmd0aCA+IDApIHtcXHJcXG4gICAgICBpZiAoa2V5ID09PSBcXFwiXFxcIikgcmV0dXJuIGRlZmF1bHRLZXk7XFxyXFxuICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygxKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4ga2V5O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpbmRleE9mQXJyYXkodmFsdWUsIGFycikge1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGFycltpXSA9PT0gdmFsdWUpIHtcXHJcXG4gICAgICAgIHJldHVybiBpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gLTE7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldEtleXMob2JqKSB7XFxyXFxuICAgIHZhciBrZXlzID0gW107XFxyXFxuICAgIGVhY2gob2JqLCBmdW5jdGlvbihrZXkpe1xcclxcbiAgICAgIGtleXMucHVzaChrZXkpO1xcclxcbiAgICB9KTtcXHJcXG4gICAgcmV0dXJuIGtleXM7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHNldFByb3BlcnR5KHRhcmdldCwgcGF0aCwgdmFsdWUsIGNyZWF0ZVBhdGgpIHtcXHJcXG4gICAgdmFyIHRva2VucyA9IHBhdGguc3BsaXQoXFxcIi5cXFwiKTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGggLSAxOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAodGFyZ2V0W3Rva2Vuc1tpXV0pIHtcXHJcXG4gICAgICAgIHRhcmdldCA9IHRhcmdldFt0b2tlbnNbaV1dO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBpZiAoY3JlYXRlUGF0aCkge1xcclxcbiAgICAgICAgICB0YXJnZXRbdG9rZW5zW2ldXSA9IHt9O1xcclxcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zW2ldXTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHRocm93IFxcXCJQYXRoIFxcXCIgKyBwYXRoICsgXFxcIiBkb2VzIG5vdCBleGlzdCBmb3JcXFwiLCB0YXJnZXQ7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHRhcmdldFt0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogUmVwbGFjZXMgZWFjaCBmb3JtYXQgaXRlbSBpbiBhIHNwZWNpZmllZCBzdHJpbmcgd2l0aCB0aGUgdGV4dCBlcXVpdmFsZW50IG9mIGEgY29ycmVzcG9uZGluZyBvYmplY3RcXCdzIHZhbHVlLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgZm9ybWF0XFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgQSBjb21wb3NpdGUgZm9ybWF0IHN0cmluZyB0aGF0IGluY2x1ZGVzIG9uZSBvciBtb3JlIGZvcm1hdCBpdGVtcy5cXHJcXG4gICogQHBhcmFtIHthbnl9IFthcmdzXSogVGhlIG9iamVjdCB0byBmb3JtYXQuXFxyXFxuICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyB3aXRoIGVhY2ggZm9ybWF0IGl0ZW0gaW5zZXJ0ZWQuXFxyXFxuICAqKi9cXHJcXG4gIC8qKlxcclxcbiAgKiBSZXBsYWNlcyBlYWNoIHRva2VuIGluIGEgc3BlY2lmaWVkIHN0cmluZyB3aXRoIHRoZSB0ZXh0IGVxdWl2YWxlbnQgb2YgYSBjb3JyZXNwb25kaW5nIGtleVxcJ3MgdmFsdWUuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBmb3JtYXRcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBBIGNvbXBvc2l0ZSBmb3JtYXQgc3RyaW5nIHRoYXQgaW5jbHVkZXMgb25lIG9yIG1vcmUgdG9rZW4gaXRlbXMuXFxyXFxuICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIGtleSwgdmFsdWUgcGFpcnMgdGhhdCB3aWxsIGJlIHJlcGxhY2luZyB0aGUgdG9rZW5zLlxcclxcbiAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0KSB7XFxyXFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgdmFyIG1hcCA9IGFyZ3VtZW50c1sxXTtcXHJcXG4gICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoL1xcXFwkeyhbXFxcXHdcXFxcLVxcXFxfXSspfS9nLCBmdW5jdGlvbihtYXRjaCwga2V5KSB7IFxcclxcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtYXBba2V5XSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBtYXBba2V5XSA6IG1hdGNoO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXHJcXG4gICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoL3soXFxcXGQrKX0vZywgZnVuY3Rpb24obWF0Y2gsIGluZGV4KSB7IFxcclxcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmdzW2luZGV4XSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBhcmdzW2luZGV4XSA6IG1hdGNoO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDYWxjdWxhdGUgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRBYnNvbHV0ZVBvc2l0aW9uXFxyXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50LlxcclxcbiAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGxlZnQgYW5kIHRvcFxcclxcbiAgKiAgICAgICAgICAgICAgICAgIHdoZXJlIHRvcCBhbmQgbGVmdCB0ZWxsIHRoZSBwb3NpdGlvbiBvZiB0aGVcXHJcXG4gICogICAgICAgICAgICAgICAgICBlbGVtZW50IGZyb20gdGhlIHRvcC1sZWZ0IGNvcm5lciBpbiBwaXhlbHMuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldEFic29sdXRlUG9zaXRpb24oZWwpIHtcXHJcXG4gICAgdmFyIGxlZnQgPSBlbC5vZmZzZXRMZWZ0IHx8IDA7XFxyXFxuICAgIHZhciB0b3AgPSBlbC5vZmZzZXRUb3AgfHwgMDtcXHJcXG4gICAgXFxyXFxuICAgIGlmIChlbC5vZmZzZXRQYXJlbnQpIHtcXHJcXG4gICAgICB2YXIgcGFyZW50QWJzb2x1dGVQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb24oZWwub2Zmc2V0UGFyZW50KTtcXHJcXG4gICAgICBsZWZ0ICs9IHBhcmVudEFic29sdXRlUG9zaXRpb24ubGVmdDtcXHJcXG4gICAgICB0b3AgKz0gcGFyZW50QWJzb2x1dGVQb3NpdGlvbi50b3A7XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07IFxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvLyBFeHBvc2UgZnVuY3Rpb25zXFxyXFxuICBleHBvcnRzLmdldEFic29sdXRlUG9zaXRpb24gPSBnZXRBYnNvbHV0ZVBvc2l0aW9uO1xcclxcbiAgZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XFxyXFxuICBleHBvcnRzLmhhc0NsYXNzID0gaGFzQ2xhc3M7XFxyXFxuICBleHBvcnRzLnJlbW92ZUNsYXNzID0gcmVtb3ZlQ2xhc3M7XFxyXFxuICBleHBvcnRzLmFkZENsYXNzID0gYWRkQ2xhc3M7XFxyXFxuICBleHBvcnRzLmVhY2ggPSBlYWNoO1xcclxcbiAgZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXHJcXG4gIGV4cG9ydHMuaW5BcnJheSA9IGluQXJyYXk7XFxyXFxuICBleHBvcnRzLmJpbmQgPSBiaW5kO1xcclxcbiAgZXhwb3J0cy5hc3luY0NhbGwgPSBhc3luY0NhbGw7XFxyXFxuICBleHBvcnRzLmRlZmluZUxvY2tlZFByb3BlcnR5ID0gZGVmaW5lTG9ja2VkUHJvcGVydHk7XFxyXFxuICBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xcclxcbiAgZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcXHJcXG4gIGV4cG9ydHMubm93ID0gbm93O1xcclxcbiAgZXhwb3J0cy50cmltTGVmdCA9IHRyaW1MZWZ0O1xcclxcbiAgZXhwb3J0cy50cmltUmlnaHQgPSB0cmltUmlnaHQ7XFxyXFxuICBleHBvcnRzLm1hcCA9IG1hcDtcXHJcXG4gIGV4cG9ydHMuc2V0Q29va2llID0gc2V0Q29va2llO1xcclxcbiAgZXhwb3J0cy5nZXRDb29raWUgPSBnZXRDb29raWU7XFxyXFxuICBleHBvcnRzLmdldENvb2tpZXMgPSBnZXRDb29raWVzO1xcclxcbiAgZXhwb3J0cy5lbmRzV2l0aCA9IGVuZHNXaXRoO1xcclxcbiAgZXhwb3J0cy5pbmplY3QgPSBpbmplY3Q7XFxyXFxuICBleHBvcnRzLmlzSlNPTlN0cmluZyA9IGlzSlNPTlN0cmluZztcXHJcXG4gIGV4cG9ydHMueGhyID0geGhyO1xcclxcbiAgZXhwb3J0cy5idWlsZEFyZ3VtZW50TGlzdCA9IGJ1aWxkQXJndW1lbnRMaXN0O1xcclxcbiAgZXhwb3J0cy5iaW5kRnVuY3Rpb25DYWxsYmFja3MgPSBiaW5kRnVuY3Rpb25DYWxsYmFja3M7XFxyXFxuICBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcXHJcXG4gIGV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcXHJcXG4gIGV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcXHJcXG4gIGV4cG9ydHMucmVtb3ZlRHVwbGljYXRlcyA9IHJlbW92ZUR1cGxpY2F0ZXM7XFxyXFxuICBleHBvcnRzLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcXHJcXG4gIGV4cG9ydHMudG9CbG9iID0gdG9CbG9iO1xcclxcbiAgZXhwb3J0cy5jcmVhdGVPYmplY3RVUkwgPSBjcmVhdGVPYmplY3RVUkw7XFxyXFxuICBleHBvcnRzLnJldm9rZU9iamVjdFVSTCA9IHJldm9rZU9iamVjdFVSTDtcXHJcXG4gIGV4cG9ydHMuZ2V0UmFuZG9tQXJiaXRyYXJ5ID0gZ2V0UmFuZG9tQXJiaXRyYXJ5O1xcclxcbiAgZXhwb3J0cy5nZXRSYW5kb21JbnQgPSBnZXRSYW5kb21JbnQ7XFxyXFxuICBleHBvcnRzLmdlbmVyYXRlVG9rZW4gPSBnZW5lcmF0ZVRva2VuO1xcclxcbiAgZXhwb3J0cy5lc2NhcGVFQ01BVmFyaWFibGUgPSBlc2NhcGVFQ01BVmFyaWFibGU7XFxyXFxuICBleHBvcnRzLmluZGV4T2ZBcnJheSA9IGluZGV4T2ZBcnJheTtcXHJcXG4gIGV4cG9ydHMuZ2V0S2V5cyA9IGdldEtleXM7XFxyXFxuICBleHBvcnRzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XFxyXFxuICBleHBvcnRzLmRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHk7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3V0aWxzLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCIvKipcXHJcXG4qIFRoZSBwbGF5ZXIgQVBJXFxyXFxuKlxcclxcbiogQG5hbWVzcGFjZSBQbGF5ZXJcXHJcXG4qIEBjbGFzcyBBUElcXHJcXG4qKi9cXHJcXG5kZWZpbmUoXFwncGxheWVyL2FwaVxcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwidXRpbHNcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgdXRpbHMpe1xcclxcbiAgLyoqXFxyXFxuICAqIEdldCB0aGUgcGxheWVyIEFQSS5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldEFQSVxcclxcbiAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwbGF5ZXIgQVBJLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBnZXRBUEkoKSB7XFxyXFxuICAgIGlmICghYXBpQ2FjaGUpIHtcXHJcXG4gICAgICBhcGlDYWNoZSA9IGJpbmRQbGF5ZXJBUEkoKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gYXBpQ2FjaGU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBTZXQgdGhlIHBsYXllciBBUEkuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBzZXRBUElcXHJcXG4gICogQHBhcmFtIHtPYmplY3R9IGFwaSBUaGUgcGxheWVyIEFQSS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gc2V0QVBJKGFwaSkge1xcclxcbiAgICBhcGlDYWNoZSA9IGFwaTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEJpbmQgdGhlIHBsYXllciBBUEkgZnJvbSB0aGUgI21vdmllX3BsYXllciBlbGVtZW50XFxyXFxuICAqIGludG8gYW4gb2JqZWN0LlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgYmluZFBsYXllckFQSVxcclxcbiAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwbGF5ZXIgQVBJLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBiaW5kUGxheWVyQVBJKCkge1xcclxcbiAgICB2YXIgcGxheWVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcIm1vdmllX3BsYXllclxcXCIpO1xcclxcbiAgICB2YXIgYXBpID0ge307XFxyXFxuICAgIFxcclxcbiAgICBpZiAocGxheWVyICYmIHBsYXllci5nZXRBcGlJbnRlcmZhY2UpIHtcXHJcXG4gICAgICB2YXIgYXBpSW50ZXJmYWNlID0gcGxheWVyLmdldEFwaUludGVyZmFjZSgpO1xcclxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcGlJbnRlcmZhY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIGFwaVthcGlJbnRlcmZhY2VbaV1dID0gdXRpbHMuYmluZChwbGF5ZXIsIHBsYXllclthcGlJbnRlcmZhY2VbaV1dKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGFwaTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSBjYWNoZWQgcGxheWVyIEFQSS5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgYXBpQ2FjaGVcXHJcXG4gICogQHR5cGUgT2JqZWN0XFxyXFxuICAqKi9cXHJcXG4gIHZhciBhcGlDYWNoZSA9IG51bGw7XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuZ2V0QVBJID0gZ2V0QVBJO1xcclxcbiAgZXhwb3J0cy5zZXRBUEkgPSBzZXRBUEk7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3BsYXllci9hcGkuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdjb25zb2xlXFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCJ1dGlsc1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBzZXRFbmFibGVkKGIpIHtcXHJcXG4gICAgZW5hYmxlZCA9IGI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGxvZygpIHtcXHJcXG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4gZnVuY3Rpb24oKXt9O1xcclxcbiAgICByZXR1cm4gY29uc29sZS5sb2cuYmluZChjb25zb2xlLCBcXFwiaW5qZWN0ZWRbXFxcIiArIHNlc3Npb25Ub2tlbiArIFxcXCJdXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGVycm9yKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSwgXFxcImluamVjdGVkW1xcXCIgKyBzZXNzaW9uVG9rZW4gKyBcXFwiXVxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB3YXJuKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlLCBcXFwiaW5qZWN0ZWRbXFxcIiArIHNlc3Npb25Ub2tlbiArIFxcXCJdXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSwgXFxcImluamVjdGVkW1xcXCIgKyBzZXNzaW9uVG9rZW4gKyBcXFwiXVxcXCIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgc2Vzc2lvblRva2VuID0gKHR5cGVvZiBjb25zb2xlU2Vzc2lvblRva2VuID09PSBcXFwic3RyaW5nXFxcIiA/IGNvbnNvbGVTZXNzaW9uVG9rZW4gOiB1dGlscy5nZW5lcmF0ZVRva2VuKG51bGwsIDgpKTtcXHJcXG4gIFxcclxcbiAgdmFyIGVuYWJsZWQgPSB0cnVlO1xcclxcbiAgXFxyXFxuICBleHBvcnRzLnNlc3Npb25Ub2tlbiA9IHNlc3Npb25Ub2tlbjtcXHJcXG4gIFxcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkoZXhwb3J0cywgXFxcImxvZ1xcXCIsIGZ1bmN0aW9uKCl7fSwgbG9nKTtcXHJcXG4gIHV0aWxzLmRlZmluZUxvY2tlZFByb3BlcnR5KGV4cG9ydHMsIFxcXCJlcnJvclxcXCIsIGZ1bmN0aW9uKCl7fSwgZXJyb3IpO1xcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkoZXhwb3J0cywgXFxcIndhcm5cXFwiLCBmdW5jdGlvbigpe30sIHdhcm4pO1xcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkoZXhwb3J0cywgXFxcImRlYnVnXFxcIiwgZnVuY3Rpb24oKXt9LCBkZWJ1Zyk7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L2NvbnNvbGUuanNcIik7XG5cbiIsCiAgICAiZXZhbChcIi8qKlxcclxcbiogSGFuZGxlcyB0aGUgcGxheWVyIGNvbmZpZ3VyYXRpb24uXFxyXFxuKlxcclxcbiogQG5hbWVzcGFjZSBQbGF5ZXJcXHJcXG4qIEBjbGFzcyBDb25maWdcXHJcXG4qKi9cXHJcXG5kZWZpbmUoXFwncGxheWVyL2NvbmZpZ1xcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwidXRpbHNcXFwiLCBcXFwidW5zYWZlV2luZG93XFxcIiwgXFxcImNvbnNvbGVcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgdXRpbHMsIHV3LCBjb24pe1xcclxcbiAgLyoqXFxyXFxuICAqIEdldCB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIHBsYXllci5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldENvbmZpZ1xcclxcbiAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwbGF5ZXIgY29uZmlndXJhdGlvbi5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0Q29uZmlnKCkge1xcclxcbiAgICByZXR1cm4gY29uZmlnO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogU2V0IHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBwbGF5ZXIuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBTZXRDb25maWdcXHJcXG4gICogQHBhcmFtIHtPYmplY3R9IGNmZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXFxyXFxuICAqKi9cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFNldCBhIHByb3BlcnR5IGZvciB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcGxheWVyLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgU2V0Q29uZmlnXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxcclxcbiAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gc2V0Q29uZmlnKGNmZywgdmFsdWUpIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBjZmcgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgdXRpbHMuc2V0UHJvcGVydHkoY29uZmlnLCBjZmcsIHZhbHVlLCB0cnVlKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBjb25maWcgPSBjZmc7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFNldCB0aGUgcGVyc2lzdGVudCBjb25maWd1cmF0aW9uIG9mIHRoZSBwbGF5ZXIuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBzZXRQZXJzaXN0ZW50Q29uZmlnXFxyXFxuICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxcclxcbiAgKiovXFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBTZXQgYSBwcm9wZXJ0eSBmb3IgdGhlIHBlcnNpc3RlbnQgY29uZmlndXJhdGlvbiBvZiB0aGUgcGxheWVyLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2Qgc2V0UGVyc2lzdGVudENvbmZpZ1xcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cXHJcXG4gICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIHNldFBlcnNpc3RlbnRDb25maWcoY2ZnLCB2YWx1ZSkge1xcclxcbiAgICBpZiAodHlwZW9mIGNmZyA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICB1dGlscy5zZXRQcm9wZXJ0eShwZXJzaXN0ZW50Q29uZmlnLCBjZmcsIHZhbHVlLCB0cnVlKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBwZXJzaXN0ZW50Q29uZmlnID0gY2ZnO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIHBlcnNpc3RlbnQgY29uZmlndXJhdGlvbiBmb3IgdGhlIHBsYXllci5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldFBlcnNpc3RlbnRDb25maWdcXHJcXG4gICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGVyc2lzdGVudCBwbGF5ZXIgY29uZmlndXJhdGlvbi5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVudENvbmZpZygpIHtcXHJcXG4gICAgcmV0dXJuIHBlcnNpc3RlbnRDb25maWc7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBUaGUgY29uZmlnIHNldHRlciBmdW5jdGlvbiBmb3IgYHV3Lnl0cGxheWVyYC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGNvbmZpZ1NldHRlclxcclxcbiAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gY29uZmlnU2V0dGVyKGNmZykge1xcclxcbiAgICBzZXRDb25maWcoY2ZnKTsgLy8gc2V0IHRoZSBjb25maWd1cmF0aW9uLiBLZWVwIHRoZSByZWZlcmVuY2VcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSBjb25maWcgZ2V0dGVyIGZ1bmN0aW9uIGZvciBgdXcueXRwbGF5ZXJgLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgY29uZmlnR2V0dGVyXFxyXFxuICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBwZXJzaXN0ZW50IGNvbmZpZyBhbmQgdGhlIGRlZmF1bHQgY29uZmlnIG1lcmdlZC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gY29uZmlnR2V0dGVyKCkge1xcclxcbiAgICB2YXIgY2ZnID0gZ2V0Q29uZmlnKCk7XFxyXFxuICAgIGlmICghY2ZnKSByZXR1cm4gY2ZnO1xcclxcbiAgICBjZmcgPSB1dGlscy5jbG9uZShjZmcpO1xcclxcbiAgICB2YXIgcGVyc2lzdGVudENmZyA9IHV0aWxzLmNsb25lKHBlcnNpc3RlbnRDb25maWcpO1xcclxcbiAgICB1dGlscy5leHRlbmQocGVyc2lzdGVudENmZywgY2ZnLCB0cnVlKTtcXHJcXG4gICAgcmV0dXJuIHBlcnNpc3RlbnRDZmc7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcGxheWVyLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBjb25maWdcXHJcXG4gICogQHR5cGUgT2JqZWN0XFxyXFxuICAqKi9cXHJcXG4gIHZhciBjb25maWcgPSB7fTtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSBwZXJzaXN0ZW50IGNvbmZpZ3VyYXRpb24gb2YgdGhlIHBsYXllci5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgcGVyc2lzdGVudENvbmZpZ1xcclxcbiAgKiBAdHlwZSBPYmplY3RcXHJcXG4gICoqL1xcclxcbiAgdmFyIHBlcnNpc3RlbnRDb25maWcgPSB7fTtcXHJcXG4gIFxcclxcbiAgLy8gTWFrZSBzdXJlIHRoYXQgeXRwbGF5ZXIgdmFyaWFibGUgaXMgc2V0XFxyXFxuICB1dy55dHBsYXllciA9IHV3Lnl0cGxheWVyIHx8IHt9O1xcclxcbiAgXFxyXFxuICBjb25maWcgPSB1dy55dHBsYXllci5jb25maWcgfHwge307XFxyXFxuICBcXHJcXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IFlvdVR1YmUgZG9lc25cXCd0IG92ZXJyaWRlIHRoZSB5dHBsYXllciB2YXJpYWJsZSBvciBhZGRpbmcgYW4gdW53YW50ZWQgcHJvcGVydHkgdG8geXRwbGF5ZXIuXFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eSh1dy55dHBsYXllciwgXFxcImNvbmZpZ1xcXCIsIGNvbmZpZ1NldHRlciwgY29uZmlnR2V0dGVyKTtcXHJcXG4gIFxcclxcbiAgZXhwb3J0cy5nZXRDb25maWcgPSBnZXRDb25maWc7XFxyXFxuICBleHBvcnRzLnNldENvbmZpZyA9IHNldENvbmZpZztcXHJcXG4gIGV4cG9ydHMuc2V0UGVyc2lzdGVudENvbmZpZyA9IHNldFBlcnNpc3RlbnRDb25maWc7XFxyXFxuICBleHBvcnRzLmdldFBlcnNpc3RlbnRDb25maWcgPSBnZXRQZXJzaXN0ZW50Q29uZmlnO1xcclxcbiAgXFxyXFxuICByZXR1cm4gZXhwb3J0cztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvY29uZmlnLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwndW5zYWZlWW91VHViZUNlbnRlclxcJyxbXFxcInVuc2FmZVdpbmRvd1xcXCJdLCBmdW5jdGlvbih1dyl7XFxyXFxuICB2YXIgeXRjZW50ZXIgPSB7fTtcXHJcXG4gIHl0Y2VudGVyLnBsYXllciA9IHt9O1xcclxcbiAgXFxyXFxuICB1dy55dGNlbnRlciA9IHl0Y2VudGVyO1xcclxcbiAgXFxyXFxuICByZXR1cm4geXRjZW50ZXI7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vdW5zYWZlWW91VHViZUNlbnRlci5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9vbllvdVR1YmVQbGF5ZXJSZWFkeVxcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwidW5zYWZlV2luZG93XFxcIiwgXFxcIi4vYXBpXFxcIiwgXFxcIi4vY29uZmlnXFxcIiwgXFxcInV0aWxzXFxcIiwgXFxcInVuc2FmZVlvdVR1YmVDZW50ZXJcXFwiLCBcXFwiLi4vY29uc29sZVxcXCJdLCBmdW5jdGlvbihleHBvcnRzLCB1dywgcGxheWVyQVBJLCBjb25maWcsIHV0aWxzLCB1eXRjLCBjb24pe1xcclxcbiAgZnVuY3Rpb24gb25QbGF5ZXJSZWFkeShhcGkpIHtcXHJcXG4gICAgY29uLmRlYnVnKFxcXCJQbGF5ZXIgaXMgcmVhZHlcXFwiKTtcXHJcXG4gICAgcGxheWVyQVBJLnNldEFQSShhcGkpO1xcclxcbiAgICBcXHJcXG4gICAgaWYgKHR5cGVvZiBhcGkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGNhbGxiYWNrKSB7XFxyXFxuICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2spIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGNhbGxiYWNrKSB7XFxyXFxuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIG9uRGVsYXllZCgpIHtcXHJcXG4gICAgY29uLmRlYnVnKFxcXCJVc2luZyBkZWxheWVkIG1ldGhvZFxcXCIpO1xcclxcbiAgICB2YXIgYXBpID0gcGxheWVyQVBJLmdldEFQSSgpO1xcclxcbiAgICBpZiAoYXBpICYmIHR5cGVvZiBhcGkuZ2V0UGxheWVyU3RhdGUgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICB0cnkge1xcclxcbiAgICAgICAgYXBpLmdldFBsYXllclN0YXRlKCk7XFxyXFxuICAgICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgICAgc2V0VGltZW91dChvbkRlbGF5ZWQsIDUwMCk7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgICAgfVxcclxcbiAgICAgIG9uUGxheWVyUmVhZHkoYXBpKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgbGlzdGVuZXJzID0gW107XFxyXFxuICBcXHJcXG4gIGNvbmZpZy5zZXRQZXJzaXN0ZW50Q29uZmlnKFxcXCJhcmdzLmpzYXBpY2FsbGJhY2tcXFwiLCBcXFwieXRjZW50ZXIucGxheWVyLm9uUmVhZHlcXFwiKTtcXHJcXG4gIHV5dGMucGxheWVyLm9uUmVhZHkgPSB1dGlscy5iaW5kKHRoaXMsIG9uUGxheWVyUmVhZHkpO1xcclxcbiAgdXcub25Zb3VUdWJlUGxheWVyUmVhZHkgPSBvblBsYXllclJlYWR5O1xcclxcbiAgXFxyXFxuICB2YXIgY2ZnID0gY29uZmlnLmdldENvbmZpZygpO1xcclxcbiAgaWYgKGNmZy5sb2FkZWQpIHtcXHJcXG4gICAgb25EZWxheWVkKCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcXHJcXG4gIGV4cG9ydHMucmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lcjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGxheWVyL29uWW91VHViZVBsYXllclJlYWR5LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwncGFnZWxvYWRcXCcsW1xcXCJ1dGlsc1xcXCIsIFxcXCJjb25zb2xlXFxcIl0sIGZ1bmN0aW9uKHV0aWxzLCBjb24pe1xcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spIHtcXHJcXG4gICAgaWYgKCFsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xcclxcbiAgICB9XFxyXFxuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFkZGVkIGV2ZW50IGxpc3RlbmVyIGlzIGV4ZWN1dGVkIVxcclxcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHBhZ2VTdGF0ZXMuaW5kZXhPZihldmVudCk7XFxyXFxuICAgIGlmIChyZWFkeVN0YXRlIDw9IGxhc3RTdGF0ZSkge1xcclxcbiAgICAgIGNhbGxiYWNrKCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spIHtcXHJcXG4gICAgaWYgKCFsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgcmV0dXJuO1xcclxcbiAgICB9XFxyXFxuICAgIHZhciBsID0gbGlzdGVuZXJzW2V2ZW50XTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAobFtpXSA9PT0gY2FsbGJhY2spIHtcXHJcXG4gICAgICAgIGxbaV0uc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBjYWxsTGlzdGVuZXJzKGV2ZW50KSB7XFxyXFxuICAgIHZhciBsaXN0ID0gbGlzdGVuZXJzW2V2ZW50XTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBsaXN0W2ldKCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHBhZ2VTdGF0ZXMuaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWdlU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGxhc3RTdGF0ZSA8IGkgJiYgaSA8PSByZWFkeVN0YXRlICYmIHV0aWxzLmlzQXJyYXkobGlzdGVuZXJzW3BhZ2VTdGF0ZXNbaV1dKSkge1xcclxcbiAgICAgICAgY2FsbExpc3RlbmVycyhwYWdlU3RhdGVzW2ldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIGxhc3RTdGF0ZSA9IHJlYWR5U3RhdGU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluaXQoKSB7XFxyXFxuICAgIHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJyZWFkeXN0YXRlY2hhbmdlXFxcIiwgdXBkYXRlLCB0cnVlKTtcXHJcXG4gICAgdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCB1cGRhdGUsIHRydWUpO1xcclxcbiAgICB1cGRhdGUoKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIGxpc3RlbmVycyA9IHt9O1xcclxcbiAgdmFyIHBhZ2VTdGF0ZXMgPSBbXFxcInVuaW5pdGlhbGl6ZWRcXFwiLCBcXFwibG9hZGluZ1xcXCIsIFxcXCJpbnRlcmFjdGl2ZVxcXCIsIFxcXCJjb21wbGV0ZVxcXCJdO1xcclxcbiAgdmFyIGxhc3RTdGF0ZSA9IC0xO1xcclxcbiAgXFxyXFxuICBpbml0KCk7XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXFxyXFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXJcXHJcXG4gIH07XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGFnZWxvYWQuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCd5dHJlYWR5XFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCIuL3BhZ2Vsb2FkXFxcIiwgXFxcInVuc2FmZVdpbmRvd1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCBwYWdlbG9hZCwgdXcpe1xcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihwYXRoLCBjYWxsYmFjaykge1xcclxcbiAgICBpZiAoIXBhdGhzW3BhdGhdKSBwYXRoc1twYXRoXSA9IFtdO1xcclxcbiAgICBwYXRoc1twYXRoXS5wdXNoKGNhbGxiYWNrKTtcXHJcXG4gICAgXFxyXFxuICAgIHVwZGF0ZSgpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHBhdGgsIGNhbGxiYWNrKSB7XFxyXFxuICAgIGlmICghcGF0aHNbcGF0aF0pIHJldHVybjtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGhzW3BhdGhdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKHBhdGhzW3BhdGhdW2ldID09PSBjYWxsYmFjaykge1xcclxcbiAgICAgICAgcGF0aHNbcGF0aF0uc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tzIGlmIHRoZSBwYXRoIGluIHVuc2FmZVdpbmRvdyBpcyBkZWZpbmVkLlxcclxcbiAgKlxcclxcbiAgKiBAbWV0aG9kIHByb3BlcnR5RXhpc3RzXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBwcm9wZXJ0eS5cXHJcXG4gICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgb3RoZXJ3aXNlIGZhbHNlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBwcm9wZXJ0eUV4aXN0cyhwYXRoKSB7XFxyXFxuICAgIHZhciB0b2tlbnMgPSBwYXRoLnNwbGl0KFxcXCIuXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgdGFyZ2V0ID0gdXc7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKHRhcmdldFt0b2tlbnNbaV1dKSB7XFxyXFxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zW2ldXTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNrcyBpZiB0aGUgYWRkZWQgcGF0aCBsaXN0ZW5lcnMgZXhpc3RcXHJcXG4gICogYW5kIGlmIHRoZXkgZG8gdGhlbiBjYWxsIHRoZSBjYWxsYmFja3NcXHJcXG4gICogZm9yIHRoYXQgc3BlY2lmaWMgcGF0aCBsaXN0ZW5lci5cXHJcXG4gICpcXHJcXG4gICogQG1ldGhvZCB1cGRhdGVcXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcbiAgICBmb3IgKHZhciBwYXRoIGluIHBhdGhzKSB7XFxyXFxuICAgICAgaWYgKHBhdGhzW3BhdGhdKSB7XFxyXFxuICAgICAgICBpZiAocHJvcGVydHlFeGlzdHMocGF0aCkpIHtcXHJcXG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHBhdGhzW3BhdGhdO1xcclxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgY2FsbGJhY2tzW2ldKCk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgcGF0aHNbcGF0aF0gPSBudWxsO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB0aW1lclVwZGF0ZSgpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBpc1dvcmtpbmcoKSB7XFxyXFxuICAgIGZvciAodmFyIHBhdGggaW4gcGF0aHMpIHtcXHJcXG4gICAgICBpZiAocGF0aHNbcGF0aF0pIHtcXHJcXG4gICAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gZmFsc2U7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRpbWVyVXBkYXRlKCkge1xcclxcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcclxcbiAgICBpZiAoaXNXb3JraW5nKCkpIHtcXHJcXG4gICAgICBzZXRUaW1lb3V0KHVwZGF0ZSwgdGltZXJJbnRlcnZhbCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIHRpbWVySW50ZXJ2YWwgPSAxMDAwO1xcclxcbiAgXFxyXFxuICB2YXIgdGltZXIgPSBudWxsO1xcclxcbiAgdmFyIHBhdGhzID0geyB9O1xcclxcbiAgXFxyXFxuICAvLyBBdHRhY2ggdGhlIHVwZGF0ZSB0byB0aGUgcGFnZSBsb2FkLlxcclxcbiAgcGFnZWxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcXFwidW5pbml0aWFsaXplZFxcXCIsIHVwZGF0ZSk7XFxyXFxuICBwYWdlbG9hZC5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkaW5nXFxcIiwgdXBkYXRlKTtcXHJcXG4gIHBhZ2Vsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXFxcImludGVyYWN0aXZlXFxcIiwgdXBkYXRlKTtcXHJcXG4gIHBhZ2Vsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNvbXBsZXRlXFxcIiwgdXBkYXRlKTtcXHJcXG4gIFxcclxcbiAgXFxyXFxuICAvKiBFeHBvcnRzICovXFxyXFxuICBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xcclxcbiAgZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0veXRyZWFkeS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiLyoqXFxyXFxuKiBBbiBlbnVtIGZvciB0aGUgY2FsbGVyIG9yaWdpbi5cXHJcXG4qXFxyXFxuKiBAbmFtZXNwYWNlIFBsYXllci5MaXN0ZW5lcnNcXHJcXG4qIEBjbGFzcyBPcmlnaW5zXFxyXFxuKiovXFxyXFxuZGVmaW5lKFxcJ3BsYXllci9saXN0ZW5lcnMvb3JpZ2luc1xcJyxbXFxcImV4cG9ydHNcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cyl7XFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IFBMQVlFUlxcclxcbiAgKiBAdHlwZSBOdW1iZXJcXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5QTEFZRVIgPSAwO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IFBST1BFUlRZXFxyXFxuICAqIEB0eXBlIE51bWJlclxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLlBST1BFUlRZID0gMTtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSlcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvbGlzdGVuZXJzL29yaWdpbnMuanNcIik7XG5cbiIsCiAgICAiZXZhbChcIi8qKlxcclxcbiogVGhlIGV2ZW50cyBmb3IgdGhlIHBsYXllciBsaXN0ZW5lci5cXHJcXG4qXFxyXFxuKiBAbmFtZXNwYWNlIFBsYXllci5MaXN0ZW5lcnNcXHJcXG4qIEBjbGFzcyBFdmVudHNcXHJcXG4qKi9cXHJcXG5kZWZpbmUoXFwncGxheWVyL2xpc3RlbmVycy9ldmVudHNcXCcsW1xcXCJleHBvcnRzXFxcIl0sIGZ1bmN0aW9uKGV4cG9ydHMpe1xcclxcbiAgLyoqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHJlYWRPbmx5XFxyXFxuICAqIEBwcm9wZXJ0eSBvbkFwaUNoYW5nZVxcclxcbiAgKiBAdHlwZSBTdHJpbmdcXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5vbkFwaUNoYW5nZSA9IFxcXCJvbkFwaUNoYW5nZVxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEByZWFkT25seVxcclxcbiAgKiBAcHJvcGVydHkgb25DdWVSYW5nZUVudGVyXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm9uQ3VlUmFuZ2VFbnRlciA9IFxcXCJvbkN1ZVJhbmdlRW50ZXJcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IG9uQ3VlUmFuZ2VFeGl0XFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm9uQ3VlUmFuZ2VFeGl0ID0gXFxcIm9uQ3VlUmFuZ2VFeGl0XFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHJlYWRPbmx5XFxyXFxuICAqIEBwcm9wZXJ0eSBvbkVycm9yXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm9uRXJyb3IgPSBcXFwib25FcnJvclxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEByZWFkT25seVxcclxcbiAgKiBAcHJvcGVydHkgb25OYXZpZ2F0ZVxcclxcbiAgKiBAdHlwZSBTdHJpbmdcXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5vbk5hdmlnYXRlID0gXFxcIm9uTmF2aWdhdGVcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IG9uUGxheWJhY2tRdWFsaXR5Q2hhbmdlXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm9uUGxheWJhY2tRdWFsaXR5Q2hhbmdlID0gXFxcIm9uUGxheWJhY2tRdWFsaXR5Q2hhbmdlXFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHJlYWRPbmx5XFxyXFxuICAqIEBwcm9wZXJ0eSBvblN0YXRlQ2hhbmdlXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm9uU3RhdGVDaGFuZ2UgPSBcXFwib25TdGF0ZUNoYW5nZVxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEByZWFkT25seVxcclxcbiAgKiBAcHJvcGVydHkgb25UYWJPcmRlckNoYW5nZVxcclxcbiAgKiBAdHlwZSBTdHJpbmdcXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5vblRhYk9yZGVyQ2hhbmdlID0gXFxcIm9uVGFiT3JkZXJDaGFuZ2VcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IG9uVm9sdW1lQ2hhbmdlXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLm9uVm9sdW1lQ2hhbmdlID0gXFxcIm9uVm9sdW1lQ2hhbmdlXFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHJlYWRPbmx5XFxyXFxuICAqIEBwcm9wZXJ0eSBvbkFkU3RhcnRcXHJcXG4gICogQHR5cGUgU3RyaW5nXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMub25BZFN0YXJ0ID0gXFxcIm9uQWRTdGFydFxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEByZWFkT25seVxcclxcbiAgKiBAcHJvcGVydHkgb25SZWFkeVxcclxcbiAgKiBAdHlwZSBTdHJpbmdcXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5vblJlYWR5ID0gXFxcIm9uUmVhZHlcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IFJBVEVfU0VOVElNRU5UXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLlJBVEVfU0VOVElNRU5UID0gXFxcIlJBVEVfU0VOVElNRU5UXFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHJlYWRPbmx5XFxyXFxuICAqIEBwcm9wZXJ0eSBTSEFSRV9DTElDS0VEXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLlNIQVJFX0NMSUNLRUQgPSBcXFwiU0hBUkVfQ0xJQ0tFRFxcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEByZWFkT25seVxcclxcbiAgKiBAcHJvcGVydHkgU0laRV9DTElDS0VEXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLlNJWkVfQ0xJQ0tFRCA9IFxcXCJTSVpFX0NMSUNLRURcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IFdBVENIX0xBVEVSXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLldBVENIX0xBVEVSID0gXFxcIldBVENIX0xBVEVSXFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHJlYWRPbmx5XFxyXFxuICAqIEBwcm9wZXJ0eSBBZHZlcnRpc2VyVmlkZW9WaWV3XFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLkFkdmVydGlzZXJWaWRlb1ZpZXcgPSBcXFwiQWR2ZXJ0aXNlclZpZGVvVmlld1xcXCI7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEByZWFkT25seVxcclxcbiAgKiBAcHJvcGVydHkgY2FwdGlvbnNjaGFuZ2VkXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLmNhcHRpb25zY2hhbmdlZCA9IFxcXCJjYXB0aW9uc2NoYW5nZWRcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICogQHByb3BlcnR5IG9uUmVtb3RlUmVjZWl2ZXJTZWxlY3RlZFxcclxcbiAgKiBAdHlwZSBTdHJpbmdcXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5vblJlbW90ZVJlY2VpdmVyU2VsZWN0ZWQgPSBcXFwib25SZW1vdGVSZWNlaXZlclNlbGVjdGVkXFxcIjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSlcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvbGlzdGVuZXJzL2V2ZW50cy5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiLyoqXFxyXFxuKiBIYW5kbGVzIHRoZSBwbGF5ZXIgbGlzdGVuZXJzLlxcclxcbipcXHJcXG4qIEBuYW1lc3BhY2UgUGxheWVyXFxyXFxuKiBAY2xhc3MgTGlzdGVuZXJzXFxyXFxuKiovXFxyXFxuZGVmaW5lKFxcJ3BsYXllci9saXN0ZW5lcnNcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcIi4uL3V0aWxzXFxcIiwgXFxcIi4vYXBpXFxcIiwgXFxcIi4uL3Vuc2FmZVdpbmRvd1xcXCIsIFxcXCIuLi9jb25zb2xlXFxcIiwgXFxcIi4vb25Zb3VUdWJlUGxheWVyUmVhZHlcXFwiLCBcXFwiLi4veXRyZWFkeVxcXCIsIFxcXCIuL2xpc3RlbmVycy9vcmlnaW5zXFxcIiwgXFxcIi4vbGlzdGVuZXJzL2V2ZW50c1xcXCJdLFxcclxcbmZ1bmN0aW9uKGV4cG9ydHMsIHV0aWxzLCBwbGF5ZXJBUEksIHV3LCBjb24sIG9uUmVhZHksIHl0cmVhZHksIE9yaWdpbiwgRXZlbnRzKXtcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIFlvdVR1YmUgbGlzdGVuZXIgZm9yIHRoZSBwYXNzZWQgZXZlbnQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRZb3VUdWJlTGlzdGVuZXJcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxcclxcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgWW91VHViZSBsaXN0ZW5lciB3aXRoIHRoZSBnaXZlbiBldmVudCBuYW1lLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBnZXRZb3VUdWJlTGlzdGVuZXIoZXZlbnQpIHtcXHJcXG4gICAgdmFyIHl0RXZlbnQgPSBnZXRMaXN0ZW5lck5hbWUoZXZlbnQpO1xcclxcbiAgICByZXR1cm4geXRMaXN0ZW5lcnNbeXRFdmVudF07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBUaGUgbGF0ZXN0IHBsYXllciBpZCBhbmQgcGxheWVyIHVpZCByZWdpc3RlcmVkIGluIHRoZSBnbG9iYWwgd2luZG93LlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgZ2V0UGxheWVyTGlzdGVuZXJEZXRhaWxzXFxyXFxuICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGBpZGAgcHJvcGVydHkgYW5kIHRoZSBgdWlkYCBwcm9wZXJ0eS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0UGxheWVyTGlzdGVuZXJEZXRhaWxzKCkge1xcclxcbiAgICB2YXIgaWQgPSAxO1xcclxcbiAgICB2YXIgdWlkID0gbnVsbDtcXHJcXG4gICAgXFxyXFxuICAgIHV0aWxzLmVhY2godXcsIGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xcclxcbiAgICAgIGlmIChrZXkuaW5kZXhPZihcXFwieXRQbGF5ZXJcXFwiKSA9PT0gMCkge1xcclxcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFxcXCJwbGF5ZXJfdWlkX1xcXCIpICE9PSAtMSkge1xcclxcbiAgICAgICAgICB2YXIgdWlkTWF0Y2ggPSBrZXkubWF0Y2goL3BsYXllcl91aWRfKFswLTldKylfKFswLTldKykkLyk7XFxyXFxuICAgICAgICAgIFxcclxcbiAgICAgICAgICB1aWQgPSBwYXJzZUludCh1aWRNYXRjaFsxXSwgMTApO1xcclxcbiAgICAgICAgICBpID0gcGFyc2VJbnQodWlkTWF0Y2hbMl0sIDEwKTtcXHJcXG4gICAgICAgICAgXFxyXFxuICAgICAgICAgIGlmIChpID4gaWQpIHtcXHJcXG4gICAgICAgICAgICBpZCA9IGk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHZhciBpZE1hdGNoID0ga2V5Lm1hdGNoKC9wbGF5ZXIoWzAtOV0rKSQvKTtcXHJcXG4gICAgICAgICAgaSA9IHBhcnNlSW50KGlkTWF0Y2hbMV0sIDEwKTtcXHJcXG4gICAgICAgICAgaWYgKGkgPiBpZCkge1xcclxcbiAgICAgICAgICAgIGlkID0gaTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSk7XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4geyBpZDogaWQsIHVpZDogdWlkIH07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBUaGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgZXZlbnQgaW4gdGhlIGdsb2JhbCB3aW5kb3cuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRMaXN0ZW5lck5hbWVcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxcclxcbiAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBldmVudC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJOYW1lKGV2ZW50KSB7XFxyXFxuICAgIGlmIChwbGF5ZXJMaXN0ZW5lckRldGFpbHMudWlkICE9PSBudWxsKSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCJ5dFBsYXllclxcXCIgKyBldmVudCArIFxcXCJwbGF5ZXJfdWlkX1xcXCIgKyBwbGF5ZXJMaXN0ZW5lckRldGFpbHMudWlkICsgXFxcIl9cXFwiICsgcGxheWVyTGlzdGVuZXJEZXRhaWxzLmlkO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHJldHVybiBcXFwieXRQbGF5ZXJcXFwiICsgZXZlbnQgKyBcXFwicGxheWVyXFxcIiArIHBsYXllckxpc3RlbmVyRGV0YWlscy5pZDtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVGhlIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIGV2ZW50IHByb3BlcnR5IGluIHRoZSBnbG9iYWwgd2luZG93LlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgeXRMaXN0ZW5lckNvbnRhaW5lclNldHRlclxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXFxyXFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGV2ZW50IGxpc3RlbmVyLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiB5dExpc3RlbmVyQ29udGFpbmVyU2V0dGVyKGV2ZW50LCBmdW5jKSB7XFxyXFxuICAgIHZhciB5dEV2ZW50ID0gZ2V0TGlzdGVuZXJOYW1lKGV2ZW50KTtcXHJcXG4gICAgeXRMaXN0ZW5lcnNbeXRFdmVudF0gPSBmdW5jO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVGhlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIGV2ZW50IHByb3BlcnR5IGluIHRoZSBnbG9iYWwgd2luZG93LlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgeXRMaXN0ZW5lckNvbnRhaW5lckdldHRlclxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXFxyXFxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZXZlbnQgbGlzdGVuZXIuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIHl0TGlzdGVuZXJDb250YWluZXJHZXR0ZXIoZXZlbnQpIHtcXHJcXG4gICAgcmV0dXJuIHV0aWxzLmJpbmQobnVsbCwgY2FsbExpc3RlbmVyLCBldmVudCwgT3JpZ2luLlBST1BFUlRZKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEhhbmRsZXMgdGhlIGFkZGVkIGxpc3RlbmVycyBhbmQgWW91VHViZVxcJ3MgbGlzdGVuZXJzLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgY2FsbExpc3RlbmVyXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cXHJcXG4gICogQHBhcmFtIHtQbGF5ZXJMaXN0ZW5lcnNPcmlnaW59IG9yaWdpbiBUaGUgY2FsbCBvcmlnaW4uXFxyXFxuICAqIEByZXR1cm4ge2FueX0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGVkIGxpc3RlbmVycy5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gY2FsbExpc3RlbmVyKGV2ZW50LCBvcmlnaW4pIHtcXHJcXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVUaGlzT2JqZWN0KCkge1xcclxcbiAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICBnZXRPcmlnaW5hbExpc3RlbmVyOiB1dGlscy5iaW5kKG51bGwsIGdldFlvdVR1YmVMaXN0ZW5lciwgZXZlbnQpXFxyXFxuICAgICAgfTtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgdmFyIHl0RXZlbnQgPSBnZXRMaXN0ZW5lck5hbWUoZXZlbnQpO1xcclxcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XFxyXFxuICAgIHZhciByZXR1cm5WYWwgPSBudWxsO1xcclxcbiAgICBcXHJcXG4gICAgY29uLmRlYnVnKFxcXCJMaXN0ZW5lciBcXFwiICsgZXZlbnQgKyBcXFwiIGNhbGxlZCBmcm9tIFtcXFwiICsgb3JpZ2luICsgXFxcIl1cXFwiLCBhcmdzKTtcXHJcXG4gICAgXFxyXFxuICAgIGlmIChlbmFibGVkICYmIG9yaWdpbiA9PT0gT3JpZ2luLlBMQVlFUiAmJiAoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkgfHwgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkgJiYgIWV2ZW50c1tldmVudF0ub3ZlcnJpZGUpKSkge1xcclxcbiAgICAgIC8qIE92ZXJyaWRlIGlzIGZhbHNlIGFuZCB0aGUgb3JpZ2luIGlzIGZyb20gdGhlIHBsYXllcjsgY2FsbCB0aGUgWW91VHViZSBDZW50ZXIgbGlzdGVuZXJzICovXFxyXFxuICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudHNbZXZlbnRdLmxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgICByZXR1cm5WYWwgPSBldmVudHNbZXZlbnRdLmxpc3RlbmVyc1tpXS5hcHBseShudWxsLCBhcmdzKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSBpZiAoZW5hYmxlZCAmJiBvcmlnaW4gPT09IE9yaWdpbi5QUk9QRVJUWSkge1xcclxcbiAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpICYmIGV2ZW50c1tldmVudF0ub3ZlcnJpZGUpIHtcXHJcXG4gICAgICAgIC8qIE92ZXJyaWRlIGlzIHRydWUgYW5kIHRoZSBvcmlnaW4gaXMgZnJvbSB0aGUgZ2xvYmFsIHdpbmRvdzsgY2FsbCB0aGUgWW91VHViZSBDZW50ZXIgbGlzdGVuZXJzICovXFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnNbaV0uYXBwbHkoZ2VuZXJhdGVUaGlzT2JqZWN0KCksIGFyZ3MpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0gZWxzZSBpZiAoeXRMaXN0ZW5lcnNbeXRFdmVudF0pIHtcXHJcXG4gICAgICAgIGlmIChhcGlOb3RBdmFpbGFibGUpIHtcXHJcXG4gICAgICAgICAgLyogQVBJIGlzIG5vdCBhdmFpbGFibGUgdGhlcmVmb3JlIGNhbGwgWW91VHViZSBDZW50ZXIgbGlzdGVuZXJzIGFzIFlvdVR1YmUgbGlzdGVuZXIgaXMgY2FsbGVkICAqL1xcclxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzW2V2ZW50XS5saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgICByZXR1cm5WYWwgPSBldmVudHNbZXZlbnRdLmxpc3RlbmVyc1tpXS5hcHBseShudWxsLCBhcmdzKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgXFxyXFxuICAgICAgICAvKiBPdmVycmlkZSBpcyBmYWxzZSBhbmQgdGhlIG9yaWdpbiBpcyBmcm9tIHRoZSBnbG9iYWwgd2luZG93OyBjYWxsIHRoZSBZb3VUdWJlIGxpc3RlbmVyICovXFxyXFxuICAgICAgICByZXR1cm5WYWwgPSB5dExpc3RlbmVyc1t5dEV2ZW50XS5hcHBseSh1dywgYXJncyk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkKSB7XFxyXFxuICAgICAgLyogRXZlcnl0aGluZyBpcyBkaXNhYmxlZDsgY2FsbCB0aGUgWW91VHViZSBsaXN0ZW5lciAqL1xcclxcbiAgICAgIHJldHVyblZhbCA9IHl0TGlzdGVuZXJzW3l0RXZlbnRdLmFwcGx5KHV3LCBhcmdzKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gcmV0dXJuVmFsO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQWRkaW5nIHRoZSBsaXN0ZW5lcnMgdG8gdGhlIHBsYXllci5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGFkZFBsYXllckxpc3RlbmVyXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGFkZFBsYXllckxpc3RlbmVyKCkge1xcclxcbiAgICB2YXIgYXBpID0gcGxheWVyQVBJLmdldEFQSSgpO1xcclxcbiAgICB2YXIgZXZlbnQ7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoYXBpICYmIGFwaS5hZGRFdmVudExpc3RlbmVyKSB7XFxyXFxuICAgICAgYXBpTm90QXZhaWxhYmxlID0gZmFsc2U7XFxyXFxuICAgICAgZm9yIChldmVudCBpbiBldmVudHMpIHtcXHJcXG4gICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgICAgIHBsYXllckxpc3RlbmVyW2V2ZW50XSA9IHV0aWxzLmJpbmQobnVsbCwgY2FsbExpc3RlbmVyLCBldmVudCwgT3JpZ2luLlBMQVlFUik7XFxyXFxuICAgICAgICAgIGFwaS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBwbGF5ZXJMaXN0ZW5lcltldmVudF0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBhcGlOb3RBdmFpbGFibGUgPSB0cnVlO1xcclxcbiAgICAgIGNvbi5lcnJvcihcXFwiW1BsYXllciBMaXN0ZW5lcl0gUGxheWVyIEFQSSBpcyBub3QgYXZhaWxhYmxlIVxcXCIpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBJbml0aWFsaXppbmcgdGhlIGdsb2JhbCBsaXN0ZW5lcnMuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBpbml0R2xvYmFsTGlzdGVuZXJzXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGluaXRHbG9iYWxMaXN0ZW5lcnMoKSB7XFxyXFxuICAgIGlmIChnbG9iYWxMaXN0ZW5lcnNJbml0aWFsaXplZCkgcmV0dXJuOyAvLyBNYWtlIHN1cmUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIG9uY2UuXFxyXFxuICAgIGdsb2JhbExpc3RlbmVyc0luaXRpYWxpemVkID0gdHJ1ZTtcXHJcXG4gICAgZm9yICh2YXIgZXZlbnQgaW4gZXZlbnRzKSB7XFxyXFxuICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcXHJcXG4gICAgICAgIHZhciB5dEV2ZW50ID0gZ2V0TGlzdGVuZXJOYW1lKGV2ZW50KTtcXHJcXG4gICAgICAgIGlmICh1d1t5dEV2ZW50XSkge1xcclxcbiAgICAgICAgICB5dExpc3RlbmVyc1t5dEV2ZW50XSA9IHV3W3l0RXZlbnRdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkodXcsIHl0RXZlbnQsXFxyXFxuICAgICAgICAgIHV0aWxzLmJpbmQobnVsbCwgeXRMaXN0ZW5lckNvbnRhaW5lclNldHRlciwgZXZlbnQpLFxcclxcbiAgICAgICAgICB1dGlscy5iaW5kKG51bGwsIHl0TGlzdGVuZXJDb250YWluZXJHZXR0ZXIsIGV2ZW50KVxcclxcbiAgICAgICAgKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEluaXRpYWxpemluZyB0aGUgcGxheWVyIGxpc3RlbmVyIHdyYXBwZXIuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBpbml0XFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGluaXQoKSB7XFxyXFxuICAgIGlmIChlbmFibGVkKSByZXR1cm47XFxyXFxuICAgIFxcclxcbiAgICBjb24uZGVidWcoXFxcIkluaXQgcGxheWVyIGxpc3RlbmVyXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgYXBpID0gcGxheWVyQVBJLmdldEFQSSgpO1xcclxcbiAgICBwbGF5ZXJMaXN0ZW5lckRldGFpbHMgPSBnZXRQbGF5ZXJMaXN0ZW5lckRldGFpbHMoKTtcXHJcXG4gICAgXFxyXFxuICAgIGVuYWJsZWQgPSB0cnVlOyAvLyBJbmRpY2F0ZSB0aGF0IHRoZSBpdFxcJ3MgYWN0aXZlLlxcclxcblxcclxcbiAgICAvLyBBZGQgdGhlIGxpc3RlbmVycyBub3JtYWxseSB0byB0aGUgcGxheWVyXFxyXFxuICAgIGFkZFBsYXllckxpc3RlbmVyKCk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBSZXBsYWNlIHRoZSBnbG9iYWwgbGlzdGVuZXJzIHdpdGggY3VzdG9tIGxpc3RlbmVycyBpbiBjYXNlIHRoZSBvdmVycmlkZSBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZVxcclxcbiAgICBpbml0R2xvYmFsTGlzdGVuZXJzKCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBBZGRpbmcgYW4gZXZlbnQgbGlzdGVuZXIuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cXHJcXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xcclxcbiAgICBpZiAoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHJldHVybjtcXHJcXG4gICAgXFxyXFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTsgLy8gTWFrZSBzdXJlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgaW5zdGFuY2Ugb2YgdGhlIGxpc3RlbmVyIHJlZ2lzdGVyZWQuXFxyXFxuICAgIGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogUmVtb3ZpbmcgYW4gZXZlbnQgbGlzdGVuZXIuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cXHJcXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xcclxcbiAgICBpZiAoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHJldHVybjtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGV2ZW50c1tldmVudF0ubGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xcclxcbiAgICAgICAgcmV0dXJuIGV2ZW50c1tldmVudF0ubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFNldCB0aGUgZXZlbnQgdG8gb3ZlcnJpZGUgdGhlIFlvdVR1YmVcXCdzIGV2ZW50IGxpc3RlbmVyXFxyXFxuICAqIHNvIHRoYXQgdGhleSB3b25cXCd0IGJlIGNhbGxlZCBleGNlcHQgaWYgZG9uZSBzbyBtYW51YWxseS5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIHNldE92ZXJyaWRlXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cXHJcXG4gICogQHBhcmFtIHtCb29sZWFufSBvdmVycmlkZSBXaGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgc2V0IHRvIG92ZXJyaWRlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBzZXRPdmVycmlkZShldmVudCwgb3ZlcnJpZGUpIHtcXHJcXG4gICAgaWYgKCFldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSByZXR1cm47XFxyXFxuICAgIGV2ZW50c1tldmVudF0ub3ZlcnJpZGUgPSAhIW92ZXJyaWRlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVW5sb2FkIHRoZSBwbGF5ZXIgbGlzdGVuZXJzIGFkZGVkIHRvIHRoZSBwbGF5ZXJcXHJcXG4gICogdGhyb3VnaCB0aGUgcGxheWVyIEFQSS5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIHVubG9hZFBsYXllckxpc3RlbmVyc1xcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiB1bmxvYWRQbGF5ZXJMaXN0ZW5lcnMoKSB7XFxyXFxuICAgIHZhciBhcGkgPSBwbGF5ZXJBUEkuZ2V0QVBJKCk7XFxyXFxuICAgIHZhciBldmVudDtcXHJcXG4gICAgXFxyXFxuICAgIGlmIChhcGkgJiYgYXBpLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXHJcXG4gICAgICBmb3IgKGV2ZW50IGluIGV2ZW50cykge1xcclxcbiAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcXHJcXG4gICAgICAgICAgYXBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHBsYXllckxpc3RlbmVyW2V2ZW50XSk7XFxyXFxuICAgICAgICAgIGRlbGV0ZSBwbGF5ZXJMaXN0ZW5lcltldmVudF07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGNvbi5lcnJvcihcXFwiW1BsYXllciBMaXN0ZW5lcl0gUGxheWVyIEFQSSBpcyBub3QgYXZhaWxhYmxlIVxcXCIpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBVbmxvYWQgdGhlIHBsYXllciBsaXN0ZW5lciB3cmFwcGVyLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgdW5sb2FkXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIHVubG9hZCgpIHtcXHJcXG4gICAgdW5sb2FkUGxheWVyTGlzdGVuZXJzKCk7XFxyXFxuICAgIGVuYWJsZWQgPSBmYWxzZTtcXHJcXG4gICAgYXBpTm90QXZhaWxhYmxlID0gdHJ1ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSBjYWNoZWQgcGxheWVyIGlkIGFuZCB1aWQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IHBsYXllckxpc3RlbmVyRGV0YWlsc1xcclxcbiAgKiBAdHlwZSBPYmplY3RcXHJcXG4gICoqL1xcclxcbiAgdmFyIHBsYXllckxpc3RlbmVyRGV0YWlscyA9IHsgaWQ6IDEsIHVpZDogbnVsbCB9O1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVGhlIGxlYWtlZCBZb3VUdWJlIGxpc3RlbmVycy5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgeXRMaXN0ZW5lcnNcXHJcXG4gICogQHR5cGUgT2JqZWN0XFxyXFxuICAqKi9cXHJcXG4gIHZhciB5dExpc3RlbmVycyA9IHt9O1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVGhlIGNhY2hlZCBwbGF5ZXIgbGlzdGVuZXJzLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBwbGF5ZXJMaXN0ZW5lclxcclxcbiAgKiBAdHlwZSBPYmplY3RcXHJcXG4gICoqL1xcclxcbiAgdmFyIHBsYXllckxpc3RlbmVyID0ge307XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBJZiB0aGUgcGxheWVyIGxpc3RlbmVycyBoYW5kbGVyIGlzIGVuYWJsZWQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGVuYWJsZWRcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgZW5hYmxlZCA9IGZhbHNlO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogSWYgdGhlIGdsb2JhbCBsaXN0ZW5lcnMgYXJlIGluaXRpYWxpemVkLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBnbG9iYWxMaXN0ZW5lcnNJbml0aWFsaXplZFxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIHZhciBnbG9iYWxMaXN0ZW5lcnNJbml0aWFsaXplZCA9IGZhbHNlO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogSWYgdGhlIHBsYXllciBBUEkgaXMgYXZhaWxhYmxlLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBhcGlOb3RBdmFpbGFibGVcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgYXBpTm90QXZhaWxhYmxlID0gdHJ1ZTtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSBldmVudCBsaXN0ZW5lcnMgYW5kIG9wdGlvbnMuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGV2ZW50c1xcclxcbiAgKiBAdHlwZSBPYmplY3RcXHJcXG4gICoqL1xcclxcbiAgdmFyIGV2ZW50cyA9IHt9O1xcclxcbiAgZm9yICh2YXIgZXZlbnQgaW4gRXZlbnRzKSB7XFxyXFxuICAgIGlmIChFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XFxyXFxuICAgICAgZXZlbnRzW2V2ZW50XSA9IHsgb3ZlcnJpZGU6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gSW50aWFsaXplIHRoZSBwbGF5ZXIgbGlzdGVuZXJzIGF0IHBsYXllciBvbiByZWFkeS5cXHJcXG4gIG9uUmVhZHkuYWRkTGlzdGVuZXIoaW5pdCk7XFxyXFxuICBcXHJcXG4gIC8qIEV4cG9ydHMgKi9cXHJcXG4gIGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XFxyXFxuICBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xcclxcbiAgZXhwb3J0cy5zZXRPdmVycmlkZSA9IHNldE92ZXJyaWRlO1xcclxcbiAgZXhwb3J0cy5pbml0ID0gaW5pdDtcXHJcXG4gIGV4cG9ydHMudW5sb2FkID0gdW5sb2FkO1xcclxcbiAgXFxyXFxuICByZXR1cm4gZXhwb3J0cztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvbGlzdGVuZXJzLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnd2luZG93XFwnLFtdLCBmdW5jdGlvbigpe1xcclxcbiAgZnVuY3Rpb24gZ2V0SW5uZXJXaWR0aCgpIHtcXHJcXG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xcclxcbiAgfVxcclxcbiAgZnVuY3Rpb24gZ2V0SW5uZXJIZWlnaHQoKSB7XFxyXFxuICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0Q2xpZW50V2lkdGgoKSB7XFxyXFxuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0Q2xpZW50SGVpZ2h0KCkge1xcclxcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XFxyXFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgY2FwdHVyZSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGdldENsaWVudFdpZHRoOiBnZXRDbGllbnRXaWR0aCxcXHJcXG4gICAgZ2V0Q2xpZW50SGVpZ2h0OiBnZXRDbGllbnRIZWlnaHQsXFxyXFxuICAgIGdldElubmVyV2lkdGg6IGdldElubmVyV2lkdGgsXFxyXFxuICAgIGdldElubmVySGVpZ2h0OiBnZXRJbm5lckhlaWdodCxcXHJcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lclxcclxcbiAgfVxcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3dpbmRvdy5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYXllci9zaXplXFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCIuL2xpc3RlbmVyc1xcXCIsIFxcXCIuL3BsYXllclxcXCIsIFxcXCJ3aW5kb3dcXFwiLCBcXFwidXRpbHNcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgbGlzdGVuZXJzLCBwbGF5ZXIsIHdpbiwgdXRpbHMpe1xcclxcbiAgZnVuY3Rpb24gb25QbGF5ZXJTaXplQ2hhbmdlKGxhcmdlKSB7XFxyXFxuICAgIGlmIChsYXJnZSkge1xcclxcbiAgICAgIHNldFNpemUobGFyZ2VTaXplKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBzZXRTaXplKHNtYWxsU2l6ZSk7XFxyXFxuICAgIH1cXHJcXG4gICAgdXBkYXRlKCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHNldFNpemUoblNpemUpIHtcXHJcXG4gICAgc2l6ZSA9IG5TaXplO1xcclxcbiAgICB1cGRhdGUoKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xcclxcbiAgICB2YXIgcGxheWVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXFwicGxheWVyXFxcIik7XFxyXFxuICAgIHZhciBwbGF5ZXJBUElFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJwbGF5ZXItYXBpXFxcIik7XFxyXFxuICAgIHZhciBwbGF5ZXJUaGVhdGVyQmFja2dyb3VuZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcInRoZWF0ZXItYmFja2dyb3VuZFxcXCIpO1xcclxcbiAgICBcXHJcXG4gICAgdXRpbHMucmVtb3ZlQ2xhc3MocGxheWVyRWwsIFxcXCJ3YXRjaC1zbWFsbCB3YXRjaC1tZWRpdW0gd2F0Y2gtbGFyZ2VcXFwiKTtcXHJcXG4gICAgaWYgKHNpemUubGFyZ2UpIHtcXHJcXG4gICAgICB1dGlscy5hZGRDbGFzcyhwbGF5ZXJFbCwgXFxcIndhdGNoLWxhcmdlXFxcIik7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdXRpbHMuYWRkQ2xhc3MocGxheWVyRWwsIFxcXCJ3YXRjaC1zbWFsbFxcXCIpO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICB2YXIgZGltID0gZ2V0UGxheWVyRGltZW5zaW9uKCk7XFxyXFxuICAgIGlmIChzaXplLmxhcmdlKSB7XFxyXFxuICAgICAgcGxheWVyRWwuc3R5bGUud2lkdGggPSBkaW0ud2lkdGggKyBcXFwicHhcXFwiO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHBsYXllckVsLnN0eWxlLndpZHRoID0gXFxcImF1dG9cXFwiO1xcclxcbiAgICB9XFxyXFxuICAgIHBsYXllclRoZWF0ZXJCYWNrZ3JvdW5kRWwuc3R5bGUuaGVpZ2h0ID0gZGltLmhlaWdodCArIFxcXCJweFxcXCI7XFxyXFxuICAgIFxcclxcbiAgICBwbGF5ZXJBUElFbC5zdHlsZS53aWR0aCA9IGRpbS53aWR0aCArIFxcXCJweFxcXCI7XFxyXFxuICAgIHBsYXllckFQSUVsLnN0eWxlLmhlaWdodCA9IGRpbS5oZWlnaHQgKyBcXFwicHhcXFwiO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGNvbnRlbnRDb250YWluZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJ3YXRjaDctY29udGFpbmVyXFxcIik7XFxyXFxuICAgIGlmIChzaXplLmxhcmdlKSB7XFxyXFxuICAgICAgdXRpbHMuYWRkQ2xhc3MoY29udGVudENvbnRhaW5lckVsLCBcXFwid2F0Y2gtd2lkZVxcXCIpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKGNvbnRlbnRDb250YWluZXJFbCwgXFxcIndhdGNoLXdpZGVcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgdmFyIHNpZGViYXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJ3YXRjaDctc2lkZWJhclxcXCIpO1xcclxcbiAgICBpZiAoc2l6ZS5sYXJnZSkge1xcclxcbiAgICAgIHNpZGViYXJFbC5zdHlsZS50b3AgPSBcXFwiXFxcIjtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBzaWRlYmFyRWwuc3R5bGUudG9wID0gXFxcIi1cXFwiICsgZGltLmhlaWdodCArIFxcXCJweFxcXCI7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0UGxheWVyRGltZW5zaW9uKCkge1xcclxcbiAgICB2YXIgcGxheWVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXFwicGxheWVyXFxcIik7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgd2lkdGggPSBudWxsO1xcclxcbiAgICB2YXIgaGVpZ2h0ID0gbnVsbDtcXHJcXG4gICAgXFxyXFxuICAgIGlmICh0eXBlb2Ygc2l6ZS53aWR0aCA9PT0gXFxcIm51bWJlclxcXCIpIHtcXHJcXG4gICAgICBpZiAoc2l6ZS53aWR0aFVuaXQgPT09IFxcXCIlXFxcIikge1xcclxcbiAgICAgICAgd2lkdGggPSBzaXplLndpZHRoLzEwMCp3aW4uZ2V0Q2xpZW50V2lkdGgoKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgd2lkdGggPSBzaXplLndpZHRoO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgaWYgKHR5cGVvZiBzaXplLndpZHRoID09PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgIGlmIChzaXplLmhlaWdodFVuaXQgPT09IFxcXCIlXFxcIikge1xcclxcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQvMTAwKndpbi5nZXRDbGllbnRIZWlnaHQoKTtcXHJcXG4gICAgICAgIC8vIGlmIChzb21ldGhpbmcuaXNUb3BCYXIoKSlcXHJcXG4gICAgICAgIGhlaWdodCAtPSA1MDtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICB2YXIgcmF0aW8gPSBnZXRSYXRpbygpO1xcclxcbiAgICBcXHJcXG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXFxcIm51bWJlclxcXCIpIHtcXHJcXG4gICAgICBpZiAodHlwZW9mIGhlaWdodCA9PT0gXFxcIm51bWJlclxcXCIpIHtcXHJcXG4gICAgICAgIHdpZHRoID0gaGVpZ2h0KnJhdGlvO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICB3aWR0aCA9IGdldERlZmF1bHRXaWR0aCgpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09IFxcXCJudW1iZXJcXFwiKSB7XFxyXFxuICAgICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gXFxcIm51bWJlclxcXCIpIHtcXHJcXG4gICAgICAgIGhlaWdodCA9IHdpZHRoL3JhdGlvO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBoZWlnaHQgPSBnZXREZWZhdWx0SGVpZ2h0KCk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICAvLyBDb250cm9sYmFyICsgUHJvZ3Jlc3NiYXIgaGVpZ2h0XFxyXFxuICAgIHZhciBjb250cm9sYmFySGVpZ2h0ID0gcGxheWVyLmdldENvbnRyb2xiYXJIZWlnaHQoKTtcXHJcXG4gICAgaGVpZ2h0ICs9IGNvbnRyb2xiYXJIZWlnaHQ7XFxyXFxuICAgIFxcclxcbiAgICAvLyBNdWx0aSBjYW1lcmEgYWRkaXRpb25hbCBoZWlnaHRcXHJcXG4gICAgaWYgKHV0aWxzLmhhc0NsYXNzKHBsYXllckVsLCBcXFwid2F0Y2gtbXVsdGljYW1lcmFcXFwiKSAmJiBwbGF5ZXIuZ2V0VHlwZSA9PT0gXFxcImZsYXNoXFxcIikge1xcclxcbiAgICAgIGhlaWdodCArPSA4MDtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHtcXHJcXG4gICAgICB3aWR0aDogTWF0aC5mbG9vcih3aWR0aCksXFxyXFxuICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGhlaWdodClcXHJcXG4gICAgfTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0U21hbGxQbGF5ZXJTaXplKHNtYWxsKSB7XFxyXFxuICAgIHNtYWxsU2l6ZSA9IHNtYWxsO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBzZXRMYXJnZVBsYXllclNpemUobGFyZ2UpIHtcXHJcXG4gICAgbGFyZ2VTaXplID0gbGFyZ2U7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldFJhdGlvKCkge1xcclxcbiAgICByZXR1cm4gMTYvOTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdFdpZHRoKCkge1xcclxcbiAgICByZXR1cm4gNjQwO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXREZWZhdWx0SGVpZ2h0KCkge1xcclxcbiAgICByZXR1cm4gZ2V0RGVmYXVsdFdpZHRoKCkvZ2V0UmF0aW8oKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIHNtYWxsU2l6ZSA9IHtcXHJcXG4gICAgd2lkdGg6IDEyODAsXFxyXFxuICAgIHdpZHRoVW5pdDogXFxcInB4XFxcIixcXHJcXG4gICAgbGFyZ2U6IHRydWVcXHJcXG4gIH07XFxyXFxuICB2YXIgbGFyZ2VTaXplID0ge1xcclxcbiAgICB3aWR0aDogMTkyMCxcXHJcXG4gICAgd2lkdGhVbml0OiBcXFwicHhcXFwiLFxcclxcbiAgICBsYXJnZTogdHJ1ZVxcclxcbiAgfTtcXHJcXG4gIFxcclxcbiAgdmFyIHNpemUgPSB7XFxyXFxuICAgIHdpZHRoOiAxMjgwLFxcclxcbiAgICBoZWlnaHQ6IDcyMCxcXHJcXG4gICAgd2lkdGhVbml0OiBcXFwicHhcXFwiLFxcclxcbiAgICBoZWlnaHRVbml0OiBcXFwicHhcXFwiLFxcclxcbiAgICBsYXJnZTogdHJ1ZVxcclxcbiAgfTtcXHJcXG4gIFxcclxcbiAgbGlzdGVuZXJzLnNldE92ZXJyaWRlKFxcXCJTSVpFX0NMSUNLRURcXFwiLCB0cnVlKTtcXHJcXG4gIGxpc3RlbmVycy5hZGRFdmVudExpc3RlbmVyKFxcXCJTSVpFX0NMSUNLRURcXFwiLCBvblBsYXllclNpemVDaGFuZ2UpO1xcclxcbiAgXFxyXFxuICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcXFwicmVzaXplXFxcIiwgdXRpbHMudGhyb3R0bGUodXBkYXRlLCAxMDApKTtcXHJcXG4gIFxcclxcbiAgLyogRXhwb3J0cyAqL1xcclxcbiAgZXhwb3J0cy5zZXRTaXplID0gc2V0U2l6ZTtcXHJcXG4gIGV4cG9ydHMuZ2V0UmF0aW8gPSBnZXRSYXRpbztcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGxheWVyL3NpemUuanNcIik7XG5cbiIsCiAgICAiZXZhbChcIi8qKlxcclxcbiogQG5hbWVzcGFjZSBQbGF5ZXJcXHJcXG4qIEBjbGFzcyBFbGVtZW50VHlwZVxcclxcbioqL1xcclxcbmRlZmluZShcXCdwbGF5ZXIvRWxlbWVudFR5cGVcXCcsW1xcXCJleHBvcnRzXFxcIl0sIGZ1bmN0aW9uKGV4cG9ydHMpe1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgRU1CRURERURcXHJcXG4gICogQHR5cGUgU3RyaW5nXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMuRU1CRURERUQgPSBcXFwiZW1iZWRkZWRcXFwiO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgV0FUQ0hcXHJcXG4gICogQHR5cGUgU3RyaW5nXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMuV0FUQ0ggPSBcXFwid2F0Y2hcXFwiO1xcclxcbiAgXFxyXFxuICByZXR1cm4gZXhwb3J0cztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9wbGF5ZXIvRWxlbWVudFR5cGUuanNcIik7XG5cbiIsCiAgICAiZXZhbChcIi8qKlxcclxcbiogVGhlIFlvdVR1YmUgcGxheWVyLlxcclxcbipcXHJcXG4qIEBuYW1lc3BhY2UgUGxheWVyXFxyXFxuKiBAY2xhc3MgUGxheWVyXFxyXFxuKiovXFxyXFxuZGVmaW5lKFxcJ3BsYXllci9wbGF5ZXJcXCcsW1xcXCJleHBvcnRzXFxcIiwgXFxcIi4vYXBpXFxcIiwgXFxcIi4vY29uZmlnXFxcIiwgXFxcInVuc2FmZVdpbmRvd1xcXCIsIFxcXCIuL3NpemVcXFwiLCBcXFwiLi9FbGVtZW50VHlwZVxcXCIsIFxcXCIuLi91dGlsc1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCBwbGF5ZXJBUEksIHBsYXllckNvbmZpZywgdXcsIHNpemUsIEVsZW1lbnRUeXBlLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBnZXRFbGVtZW50VHlwZSgpIHtcXHJcXG4gICAgXFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIGN1cnJlbnQgcGxheWVyIHR5cGUsIHdoaWNoIGNhbiBlaXRoZXIgYmUgSFRNTDUgb3IgZmxhc2guXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRUeXBlXFxyXFxuICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHBsYXllciB0eXBlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBnZXRUeXBlKCkge1xcclxcbiAgICB2YXIgYXBpID0gcGxheWVyQVBJLmdldEFQSSgpO1xcclxcbiAgICBpZiAoYXBpICYmIHR5cGVvZiBhcGkuZ2V0UGxheWVyVHlwZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgIHJldHVybiBhcGkuZ2V0UGxheWVyVHlwZSgpO1xcclxcbiAgICB9XFxyXFxuICAgIHZhciBjZmcgPSBwbGF5ZXJDb25maWcuZ2V0Q29uZmlnKCk7XFxyXFxuICAgIGlmIChjZmcuaHRtbDUpIHtcXHJcXG4gICAgICByZXR1cm4gXFxcImh0bWw1XFxcIjtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICByZXR1cm4gXFxcImZsYXNoXFxcIjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogU2V0dGluZyB0aGUgcGxheWVyIHR5cGUgdG8gZWl0aGVyIEhUTUw1IG9yIGZsYXNoXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBzZXRUeXBlXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBkZXNpcmVkIHBsYXllciB0eXBlIChIVE1MNSBvciBmbGFzaCkuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIHNldFR5cGUodHlwZSkge1xcclxcbiAgICB2YXIgY3VycmVudFR5cGUgPSBnZXRUeXBlKCk7XFxyXFxuICAgIGlmICh0eXBlID09PSBjdXJyZW50VHlwZSkge1xcclxcbiAgICAgIHJldHVybjsgLy8gRG8gbm90aGluZyBhcyBpdFxcJ3MgYWxyZWFkeSB0aGUgZGVzaXJlZCBwbGF5ZXIgdHlwZVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHZhciBhcGkgPSBwbGF5ZXJBUEkuZ2V0QVBJKCk7XFxyXFxuICAgICAgcGxheWVyQ29uZmlnLnNldENvbmZpZyhcXFwiaHRtbDVcXFwiLCAodHlwZSA9PT0gXFxcImh0bWw1XFxcIiA/IHRydWUgOiBmYWxzZSkpOyAvLyBTZXR0aW5nIHRoZSBwcm9wZXJ0eSBodG1sNSB0byBlaXRoZXIgdHJ1ZSBvciBmYWxzZVxcclxcbiAgICAgIFxcclxcbiAgICAgIC8vIFNvZnQtcmVsb2FkaW5nIHRoZSBwbGF5ZXIuIElmIFlvdVR1YmUgZGV0ZWN0cyB0aGF0IHRoZSBodG1sNSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCBpdCB3aWxsIGNoYW5nZSB0aGUgcGxheWVyLlxcclxcbiAgICAgIGlmIChhcGkgJiYgdHlwZW9mIGFwaS5sb2FkTmV3VmlkZW9Db25maWcgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICAgIGFwaS5sb2FkTmV3VmlkZW9Db25maWcodXcueXRwbGF5ZXIuY29uZmlnKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEdldCB0aGUgY29udHJvbGJhciBoZWlnaHQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRDb250cm9sYmFySGVpZ2h0XFxyXFxuICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgY29udHJvbGJhciBvbiB0aGUgcGxheWVyLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBnZXRDb250cm9sYmFySGVpZ2h0KCkge1xcclxcbiAgICB2YXIgbm9uZSA9IDA7XFxyXFxuICAgIHZhciBvbmx5Q29udHJvbGJhciA9IDM7XFxyXFxuICAgIHZhciBvbmx5UHJvZ3Jlc3NiYXIgPSAzMDtcXHJcXG4gICAgdmFyIGJvdGggPSAzNTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBjZmcgPSBwbGF5ZXJDb25maWcuZ2V0Q29uZmlnKCk7XFxyXFxuICAgIHZhciBhdXRvaGlkZSA9IG51bGw7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoY2ZnICYmIGNmZy5hcmdzICYmIHR5cGVvZiBjZmcuYXJncy5hdXRvaGlkZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXHJcXG4gICAgICBhdXRvaGlkZSA9IGNmZy5hcmdzLmF1dG9oaWRlO1xcclxcbiAgICB9IGVsc2UgaWYgKGdldFR5cGUoKSA9PT0gXFxcImh0bWw1XFxcIikge1xcclxcbiAgICAgIHZhciByYXRpbyA9IHNpemUuZ2V0UmF0aW8oKTtcXHJcXG4gICAgICBpZiAocmF0aW8gPCAxLjM1KSB7XFxyXFxuICAgICAgICBhdXRvaGlkZSA9IFxcXCIzXFxcIjtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHN3aXRjaCAoYXV0b2hpZGUpIHtcXHJcXG4gICAgICBjYXNlIFxcXCIwXFxcIjogcmV0dXJuIGJvdGg7XFxyXFxuICAgICAgY2FzZSBcXFwiMVxcXCI6IHJldHVybiBub25lO1xcclxcbiAgICAgIGNhc2UgXFxcIjNcXFwiOiByZXR1cm4gb25seUNvbnRyb2xiYXI7XFxyXFxuICAgICAgY2FzZSBcXFwiMlxcXCI6IGRlZmF1bHQ6IHJldHVybiBvbmx5UHJvZ3Jlc3NiYXI7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENhbGxpbmcgeXQucGxheWVyLkFwcGxpY2F0aW9uLmNyZWF0ZSB0byB0ZWxsIFlvdVR1YmUgdG9cXHJcXG4gICogY3JlYXRlIHRoZSBZb3VUdWJlIHBsYXllciBhZ2FpbiBhbmQgZGlzcG9zZSBvZiB0aGUgb2xkXFxyXFxuICAqIHBsYXllci5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIHJlbG9hZFxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiByZWxvYWQoKSB7XFxyXFxuICAgIGlmICh1dyAmJiB1dy55dCAmJiB1dy55dC5wbGF5ZXIgJiYgdXcueXQucGxheWVyLkFwcGxpY2F0aW9uICYmIHR5cGVvZiB1dy55dC5wbGF5ZXIuQXBwbGljYXRpb24uY3JlYXRlID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgdXcueXQucGxheWVyLkFwcGxpY2F0aW9uLmNyZWF0ZShcXFwicGxheWVyLWFwaVxcXCIsIHBsYXllckNvbmZpZy5nZXRDb25maWcoKSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwbGF5ZXJcXCdzIEFQSS5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgYXBpXFxyXFxuICAqIEB0eXBlIE9iamVjdFxcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICoqL1xcclxcbiAgdXRpbHMuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImFwaVxcXCIsIHBsYXllckFQSS5nZXRBUEksIGZ1bmN0aW9uKCl7fSk7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIHBsYXllciBBUEkuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRBUElcXHJcXG4gICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGxheWVyIGFwaS5cXHJcXG4gICogQGRlcHJlY2F0ZWQgVXNlIGBwbGF5ZXIuYXBpYCBpbnN0ZWFkLlxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLmdldEFQSSA9IHBsYXllckFQSS5nZXRBUEk7XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuZ2V0VHlwZSA9IGdldFR5cGU7XFxyXFxuICBleHBvcnRzLnNldFR5cGUgPSBzZXRUeXBlO1xcclxcbiAgZXhwb3J0cy5nZXRDb250cm9sYmFySGVpZ2h0ID0gZ2V0Q29udHJvbGJhckhlaWdodDtcXHJcXG4gIGV4cG9ydHMuZ2V0Q29uZmlnID0gcGxheWVyQ29uZmlnLmdldENvbmZpZztcXHJcXG4gIGV4cG9ydHMuc2V0Q29uZmlnID0gcGxheWVyQ29uZmlnLnNldENvbmZpZztcXHJcXG4gIGV4cG9ydHMucmVsb2FkID0gcmVsb2FkO1xcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vcGxheWVyL3BsYXllci5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3BsYWNlbWVudC1kcmFnZHJvcFxcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwiLi91dGlsc1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBnZXRUYXJnZXRlZEdyb3VwKHgsIHksIGdyb3Vwcykge1xcclxcbiAgICB2YXIgZGlzdGFuY2UgPSBudWxsO1xcclxcbiAgICB2YXIgaGVpZ2h0R3JvdXAgPSBudWxsO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIC8vIEdyb3VwIGVsZW1lbnRcXHJcXG4gICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gR2V0dGluZyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGdyb3VwIGVsZW1lbnRcXHJcXG4gICAgICB2YXIgYWJzb2x1dGVQb3NpdGlvbiA9IHV0aWxzLmdldEFic29sdXRlUG9zaXRpb24oZ3JvdXApO1xcclxcbiAgICAgIFxcclxcbiAgICAgIC8qXFxyXFxuICAgICAgKiBUaGUgcG9pbnRzIG9uIHRoZSByZWN0YW5nbGUsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGdyb3VwIGVsZW1lbnQuXFxyXFxuICAgICAgKiBweCBpcyAxIGFuZCAyLFxcclxcbiAgICAgICogcHkgaXMgMSBhbmQgMyxcXHJcXG4gICAgICAqIHBXaWR0aCBpcyAyIGFuZCA0LFxcclxcbiAgICAgICogcEhlaWdodCBpcyAzIGFuZCA0XFxyXFxuICAgICAgKiAxLS0tLS0tLS0tLS0tMlxcclxcbiAgICAgICogfCAgICAgICAgICAgIHxcXHJcXG4gICAgICAqIHwgICAgICAgICAgICB8XFxyXFxuICAgICAgKiAzLS0tLS0tLS0tLS0tNFxcclxcbiAgICAgICovXFxyXFxuICAgICAgdmFyIHB4ID0gYWJzb2x1dGVQb3NpdGlvbi5sZWZ0O1xcclxcbiAgICAgIHZhciBweSA9IGFic29sdXRlUG9zaXRpb24udG9wO1xcclxcbiAgICAgIHZhciBwV2lkdGggPSBhYnNvbHV0ZVBvc2l0aW9uLmxlZnQgKyBncm91cC5vZmZzZXRXaWR0aDtcXHJcXG4gICAgICB2YXIgcEhlaWdodCA9IGFic29sdXRlUG9zaXRpb24udG9wICsgZ3JvdXAub2Zmc2V0SGVpZ2h0O1xcclxcbiAgICAgIFxcclxcbiAgICAgIC8vIERldGVjdGluZyBpZiB0aGUgKHgsIHkpIHBvaW50IGlzIGluc2lkZSBvciB0b3VjaGVzIHRoZSBncm91cCBlbGVtZW50IChyZWN0YW5nbGUpXFxyXFxuICAgICAgaWYgKHggPj0gcHggJiYgeCA8PSBwV2lkdGggJiYgeSA+PSBweSAmJiB5IDw9IHBIZWlnaHQpIHtcXHJcXG4gICAgICAgIHJldHVybiBncm91cDtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHkgPj0gcHkgJiYgeSA8PSBwSGVpZ2h0KSB7XFxyXFxuICAgICAgICB2YXIgdG1wRGlzdCA9IG51bGw7XFxyXFxuICAgICAgICBpZiAoeCA8IHB4KSB7XFxyXFxuICAgICAgICAgIC8vIExlZnQgc2lkZVxcclxcbiAgICAgICAgICB0bXBEaXN0ID0gcHggLSB4O1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh4ID4gcFdpZHRoKSB7XFxyXFxuICAgICAgICAgIC8vIFJpZ2h0IHNpZGVcXHJcXG4gICAgICAgICAgdG1wRGlzdCA9IHggLSBwV2lkdGg7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBjb250aW51ZTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGRpc3RhbmNlID09PSBudWxsIHx8IHRtcERpc3QgPCBkaXN0YW5jZSkge1xcclxcbiAgICAgICAgICBoZWlnaHRHcm91cCA9IGdyb3VwO1xcclxcbiAgICAgICAgICBkaXN0YW5jZSA9IHRtcERpc3Q7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4gaGVpZ2h0R3JvdXA7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldFJlbGF0aXZlR3JvdXBDaGlsZCh4LCB5LCBncm91cCkge1xcclxcbiAgICAvLyBUaGUgY3Vyc29yIGlzIGluc2lkZSBhIGdyb3VwIGVsZW1lbnQuXFxyXFxuICAgIGlmIChncm91cCAhPT0gbnVsbCkge1xcclxcbiAgICAgIHZhciBncm91cENoaWxkcmVuID0gZ3JvdXAuY2hpbGRyZW47XFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IGNoaWxkIG9mIGdyb3VwXFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3VwQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIHZhciBjaGlsZCA9IGdyb3VwQ2hpbGRyZW5baV07XFxyXFxuICAgICAgICAvLyBNYWtpbmcgc3VyZSB0aGF0IGFuIGVsZW1lbnQgaXMgbm90IHBsYWNlZCBiZXNpZGUgaXRzZWxmLlxcclxcbiAgICAgICAgaWYgKGNoaWxkICE9PSByZWZNb3ZlYWJsZUVsZW1lbnQgJiYgY2hpbGQgIT09IHJlZlRhcmdldGVkRWxlbWVudCkge1xcclxcbiAgICAgICAgICAvLyBHZXQgdGhlIGNoaWxkXFwncyBhYnNvbHV0ZSBwb3NpdGlvbiBvbiB0aGUgcGFnZVxcclxcbiAgICAgICAgICB2YXIgYWJzb2x1dGVQb3NpdGlvbiA9IHV0aWxzLmdldEFic29sdXRlUG9zaXRpb24oY2hpbGQpO1xcclxcbiAgICAgICAgICBcXHJcXG4gICAgICAgICAgLy8gVGhlIGZvciBsb29wIGl0ZXJhdGVzIHRocm91Z2ggdGhlIGNoaWxkcmVuIGNocm9ub2xvZ2ljYWwsIHdoaWNoIG1lYW5zIHRoYXRcXHJcXG4gICAgICAgICAgLy8gaXQgb25seSBuZWVkcyB0byBsb29rIGlmIHRoZSB4LXZhbHVlIG9mIHRoZSBjdXJzb3IgaXMgYmVmb3JlIGhhbGYgb2YgdGhlXFxyXFxuICAgICAgICAgIC8vIGNoaWxkIGVsZW1lbnQuXFxyXFxuICAgICAgICAgIGlmICh4IDw9IGNoaWxkLm9mZnNldFdpZHRoLzIgKyBhYnNvbHV0ZVBvc2l0aW9uLmxlZnQgJiYgeSA8PSBjaGlsZC5vZmZzZXRIZWlnaHQgKyBhYnNvbHV0ZVBvc2l0aW9uLnRvcCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgLy8gTm8gY2hpbGQgd2FzIGZvdW5kLCByZXR1cm4gbnVsbFxcclxcbiAgICByZXR1cm4gbnVsbDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbW91c2Vtb3ZlTGlzdGVuZXIoZSkge1xcclxcbiAgICBpZiAoIW1vdXNlZG93biB8fCAhbW9kdWxlRW5hYmxlZCkgcmV0dXJuO1xcclxcbiAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XFxyXFxuICAgIFxcclxcbiAgICAvLyBJZiB1c2VyIGlzIHVzaW5nIHRvdWNoLCBtYWtlIHN1cmUgdGhhdCBpdCBkZXRlY3RzIHRoZSB0b3VjaCBpbnN0ZWFkIG9mIG1vdXNlLlxcclxcbiAgICBpZiAoZSAmJiBlLnR5cGUuaW5kZXhPZihcXFwidG91Y2hcXFwiKSAhPT0gLTEgJiYgZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDAgJiYgZS5jaGFuZ2VkVG91Y2hlc1swXSkge1xcclxcbiAgICAgIGUgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICAvLyBUaGUgKHgsIHkpIGNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIGN1cnNvciBvbiB0aGUgcGFnZVxcclxcbiAgICB2YXIgeCA9IGUucGFnZVg7XFxyXFxuICAgIHZhciB5ID0gZS5wYWdlWTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFVwZGF0ZSB0aGUgbW92ZWFibGUgZWxlbWVudCBwb3NpdGlvblxcclxcbiAgICByZWZNb3ZlYWJsZUVsZW1lbnQuc3R5bGUudG9wID0gKHkgLSAocmVsYXRpdmVNb3VzZVBvc2l0aW9uLnkgfHwgMCkpICsgXFxcInB4XFxcIjtcXHJcXG4gICAgcmVmTW92ZWFibGVFbGVtZW50LnN0eWxlLmxlZnQgPSAoeCAtIChyZWxhdGl2ZU1vdXNlUG9zaXRpb24ueCB8fCAwKSkgKyBcXFwicHhcXFwiO1xcclxcbiAgICBcXHJcXG4gICAgLy8gR2V0IHRoZSB0YXJnZXRlZCBncm91cCB3aXRoIHRoZSAoeCwgeSkgY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yXFxyXFxuICAgIHZhciBncm91cCA9IGdldFRhcmdldGVkR3JvdXAoeCwgeSwgZ3JvdXBFbGVtZW50cyk7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoZ3JvdXApIHtcXHJcXG4gICAgICAvLyBHZXQgdGhlIHJlbGF0aXZlIGdyb3VwIGNoaWxkIGVsZW1lbnRcXHJcXG4gICAgICB2YXIgY2hpbGQgPSBnZXRSZWxhdGl2ZUdyb3VwQ2hpbGQoeCwgeSwgZ3JvdXApO1xcclxcbiAgICAgIFxcclxcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRhcmdldGVkIGVsZW1lbnQgZG9lcyBoYXZlIGEgcGFyZW50IHRvIHJlbW92ZVxcclxcbiAgICAgIC8vIHRoZSBlbGVtZW50IGZyb21cXHJcXG4gICAgICBpZiAocmVmVGFyZ2V0ZWRFbGVtZW50LnBhcmVudE5vZGUpIHtcXHJcXG4gICAgICAgIHJlZlRhcmdldGVkRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlZlRhcmdldGVkRWxlbWVudCk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIFxcclxcbiAgICAgIGlmIChjaGlsZCkge1xcclxcbiAgICAgICAgLy8gQSBjaGlsZCB3YXMgZm91bmQgaW5zZXJ0IHRoZSB0YXJnZXRlZCBlbGVtZW50IGJlZm9yZSBzYWlkIGNoaWxkXFxyXFxuICAgICAgICBncm91cC5pbnNlcnRCZWZvcmUocmVmVGFyZ2V0ZWRFbGVtZW50LCBjaGlsZCk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIC8vIEEgY2hpbGQgd2FzIG5vdCBmb3VuZCBqdXN0IGFwcGVuZCB0aGUgZWxlbWVudCB0byB0aGUgZ3JvdXBcXHJcXG4gICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHJlZlRhcmdldGVkRWxlbWVudCk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9uXFxyXFxuICAgIGlmIChlICYmIGUucHJldmVudERlZmF1bHQpIHtcXHJcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgd2luZG93LmV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBtb3VzZWRvd25MaXN0ZW5lcihlKSB7XFxyXFxuICAgIGlmIChtb3VzZWRvd24gfHwgIW1vZHVsZUVuYWJsZWQpIHJldHVybjtcXHJcXG4gICAgXFxyXFxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcXHJcXG4gICAgXFxyXFxuICAgIHZhciB0YXJnZXRlZEVsZW1lbnQgPSBlLnRhcmdldDtcXHJcXG4gICAgd2hpbGUgKHRhcmdldGVkRWxlbWVudCkge1xcclxcbiAgICAgIGlmICghdGFyZ2V0ZWRFbGVtZW50LnBhcmVudE5vZGUpIHJldHVybjsgLy8gVGFyZ2V0ZWQgZWxlbWVudCBub3QgaW4gYSBjb250YWluZXJcXHJcXG4gICAgICBcXHJcXG4gICAgICAvLyBJcyB0aGUgdGFyZ2V0ZWQgZWxlbWVudCBhIGNoaWxkIG9mIGdyb3VwRWxlbWVudHNcXHJcXG4gICAgICAvLyBhbmQgaWYgc28gdGhlbiB3ZSBicmVhayBvdXQgb2YgdGhpcyBsb29wXFxyXFxuICAgICAgaWYgKHV0aWxzLmluQXJyYXkoZ3JvdXBFbGVtZW50cywgdGFyZ2V0ZWRFbGVtZW50LnBhcmVudE5vZGUpKSB7XFxyXFxuICAgICAgICBicmVhaztcXHJcXG4gICAgICB9XFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gVGhlIGRlc2lyZWQgZWxlbWVudCBpcyBhIGNoaWxkIHRvIG9uZSBvZiB0aGUgY29udGFpbmVycy5cXHJcXG4gICAgICB0YXJnZXRlZEVsZW1lbnQgPSB0YXJnZXRlZEVsZW1lbnQucGFyZW50Tm9kZTtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgbW91c2Vkb3duID0gdHJ1ZTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFJlbGF0aXZlIHBvc2l0aW9uIHRvIHRhcmdldGVkIGVsZW1lbnRcXHJcXG4gICAgdmFyIGFic29sdXRlUG9zaXRpb24gPSB1dGlscy5nZXRBYnNvbHV0ZVBvc2l0aW9uKHRhcmdldGVkRWxlbWVudCk7XFxyXFxuICAgIHJlbGF0aXZlTW91c2VQb3NpdGlvbiA9IHtcXHJcXG4gICAgICB4OiBlLnBhZ2VYIC0gYWJzb2x1dGVQb3NpdGlvbi5sZWZ0LFxcclxcbiAgICAgIHk6IGUucGFnZVkgLSBhYnNvbHV0ZVBvc2l0aW9uLnRvcFxcclxcbiAgICB9O1xcclxcbiAgICBcXHJcXG4gICAgLy8gQ3JlYXRlIHRoZSBtb3ZlYWJsZSBlbGVtZW50XFxyXFxuICAgIHZhciBtb3ZlYWJsZUVsZW1lbnQgPSBjcmVhdGVNb3ZlYWJsZUVsZW1lbnQodGFyZ2V0ZWRFbGVtZW50KTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIE1ha2UgdGhlIHRhcmdldGVkIGVsZW1lbnQgaW52aXNpYmxlXFxyXFxuICAgIHV0aWxzLmFkZENsYXNzKHRhcmdldGVkRWxlbWVudCwgXFxcInBsYWNlbWVudHN5c3RlbS10YXJnZXRcXFwiKTtcXHJcXG4gICAgLy90YXJnZXRlZEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiO1xcclxcbiAgICBcXHJcXG4gICAgLy8gU3RvcmUgdHdvIHJlZmVyZW5jZXMgZm9yIGxhdGVyIHVzZVxcclxcbiAgICByZWZNb3ZlYWJsZUVsZW1lbnQgPSBtb3ZlYWJsZUVsZW1lbnQ7XFxyXFxuICAgIHJlZlRhcmdldGVkRWxlbWVudCA9IHRhcmdldGVkRWxlbWVudDtcXHJcXG4gICAgXFxyXFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW92ZWFibGVFbGVtZW50KTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIEFkZCBtb3VzZXVwLCBtb3VzZW1vdmUsIHRvdWNoZW5kIGFuZCB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJcXHJcXG4gICAgdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIG1vdXNlbW92ZUxpc3RlbmVyLCBmYWxzZSk7XFxyXFxuICAgIHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJ0b3VjaG1vdmVcXFwiLCBtb3VzZW1vdmVMaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICBcXHJcXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvblxcclxcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XFxyXFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHdpbmRvdy5ldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBmYWxzZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbW91c2V1cExpc3RlbmVyKGUpIHtcXHJcXG4gICAgaWYgKCFtb3VzZWRvd24gfHwgIW1vZHVsZUVuYWJsZWQgfHwgIXJlZlRhcmdldGVkRWxlbWVudCkgcmV0dXJuO1xcclxcbiAgICBtb3VzZWRvd24gPSBmYWxzZTtcXHJcXG4gICAgXFxyXFxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcXHJcXG4gICAgXFxyXFxuICAgIC8vIE1ha2UgdGhlIHRhcmdldGVkIGVsZW1lbnQgdmlzaWJsZVxcclxcbiAgICB1dGlscy5yZW1vdmVDbGFzcyhyZWZUYXJnZXRlZEVsZW1lbnQsIFxcXCJwbGFjZW1lbnRzeXN0ZW0tdGFyZ2V0XFxcIik7XFxyXFxuICAgIC8vcmVmVGFyZ2V0ZWRFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiXFxcIjtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFJlbW92ZSB0aGUgbW92ZWFibGUgZWxlbWVudCBmcm9tIHRoZSBET01cXHJcXG4gICAgcmVmTW92ZWFibGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVmTW92ZWFibGVFbGVtZW50KTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFJlbW92ZSByZWxhdGl2ZSBtb3VzZSBwb3NpdGlvblxcclxcbiAgICByZWxhdGl2ZU1vdXNlUG9zaXRpb24gPSBudWxsO1xcclxcbiAgICBcXHJcXG4gICAgLy8gUmVtb3ZlIHN0b3JlZCByZWZlcmVuY2VzXFxyXFxuICAgIHJlZk1vdmVhYmxlRWxlbWVudCA9IG51bGw7XFxyXFxuICAgIHJlZlRhcmdldGVkRWxlbWVudCA9IG51bGw7XFxyXFxuICAgIFxcclxcbiAgICAvLyBSZW1vdmUgbW91c2Vtb3ZlIGFuZCB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJcXHJcXG4gICAgdXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIG1vdXNlbW92ZUxpc3RlbmVyLCBmYWxzZSk7XFxyXFxuICAgIHV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJ0b3VjaG1vdmVcXFwiLCBtb3VzZW1vdmVMaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICBcXHJcXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvblxcclxcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XFxyXFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHdpbmRvdy5ldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBmYWxzZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0R3JvdXBFbGVtZW50cyhncm91cHMpIHtcXHJcXG4gICAgZ3JvdXBFbGVtZW50cyA9IGdyb3VwcztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0TW92ZWFibGVFbGVtZW50UG9zaXRpb24oZWwsIG1vdmVhYmxlRWxlbWVudCkge1xcclxcbiAgICB2YXIgYWJzb2x1dGVQb3NpdGlvbiA9IHV0aWxzLmdldEFic29sdXRlUG9zaXRpb24oZWwpO1xcclxcbiAgICBcXHJcXG4gICAgLy8gR2l2ZSB0aGUgbW92ZWFibGUgYW4gYWJzb2x1dGUgcG9zaXRpb24sIHdoaWNoIHdpbGwgYmVcXHJcXG4gICAgLy8gb24gdG9wIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50LlxcclxcbiAgICBtb3ZlYWJsZUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcXFwiYWJzb2x1dGVcXFwiO1xcclxcbiAgICBtb3ZlYWJsZUVsZW1lbnQuc3R5bGUudG9wID0gYWJzb2x1dGVQb3NpdGlvbi50b3AgKyBcXFwicHhcXFwiO1xcclxcbiAgICBtb3ZlYWJsZUVsZW1lbnQuc3R5bGUubGVmdCA9IGFic29sdXRlUG9zaXRpb24ubGVmdCArIFxcXCJweFxcXCI7XFxyXFxuICAgIG1vdmVhYmxlRWxlbWVudC5zdHlsZS56SW5kZXggPSBcXFwiMTk5OTk5OTk5OTk5OVxcXCI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGNyZWF0ZU1vdmVhYmxlRWxlbWVudChlbCkge1xcclxcbiAgICBmdW5jdGlvbiByZW1vdmVUb29sdGlwKGVsKSB7XFxyXFxuICAgICAgLy8gUmVtb3ZlcyB0b29sdGlwIGZyb20gZWxlbWVudFxcclxcbiAgICAgIGVsLnRpdGxlID0gXFxcIlxcXCI7XFxyXFxuICAgICAgZWwuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWJ1dHRvbi1hY3Rpb25cXFwiLCBcXFwiXFxcIik7XFxyXFxuICAgICAgZWwuc2V0QXR0cmlidXRlKFxcXCJkYXRhLXRvb2x0aXAtdGV4dFxcXCIsIFxcXCJcXFwiKTtcXHJcXG4gICAgICB1dGlscy5yZW1vdmVDbGFzcyhlbCwgXFxcInl0LXVpeC10b29sdGlwXFxcIik7XFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gUmVtb3ZlcyB0b29sdGlwIGZyb20gY2hpbGRyZW5cXHJcXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIHJlbW92ZVRvb2x0aXAoY2hpbGRyZW5baV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB2YXIgbW92ZWFibGVFbGVtZW50ID0gZWwuY2xvbmVOb2RlKHRydWUpO1xcclxcbiAgICBcXHJcXG4gICAgLy8gTW92ZSB0aGUgbW92ZWFibGUgZWxlbWVudCBvbiB0b3Agb2YgdGhlIHRhcmdldGVkIGVsZW1lbnRcXHJcXG4gICAgc2V0TW92ZWFibGVFbGVtZW50UG9zaXRpb24oZWwsIG1vdmVhYmxlRWxlbWVudCk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBSZW1vdmVzIHRvb2x0aXAgZnJvbSB0aGUgbW92ZWFibGUgZWxlbWVudFxcclxcbiAgICByZW1vdmVUb29sdGlwKG1vdmVhYmxlRWxlbWVudCk7XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4gbW92ZWFibGVFbGVtZW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcXHJcXG4gICAgbW9kdWxlRW5hYmxlZCA9IGVuYWJsZWQ7XFxyXFxuICAgIFxcclxcbiAgICB1dGlscy5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgbW91c2Vtb3ZlTGlzdGVuZXIsIGZhbHNlKTtcXHJcXG4gICAgdXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcInRvdWNobW92ZVxcXCIsIG1vdXNlbW92ZUxpc3RlbmVyLCBmYWxzZSk7XFxyXFxuICAgIFxcclxcbiAgICB1dGlscy5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcXFwibW91c2Vkb3duXFxcIiwgbW91c2Vkb3duTGlzdGVuZXIsIGZhbHNlKTtcXHJcXG4gICAgdXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcInRvdWNoc3RhcnRcXFwiLCBtb3VzZWRvd25MaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICBcXHJcXG4gICAgdXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBtb3VzZXVwTGlzdGVuZXIsIGZhbHNlKTtcXHJcXG4gICAgdXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXFxcInRvdWNoZW5kXFxcIiwgbW91c2V1cExpc3RlbmVyLCBmYWxzZSk7XFxyXFxuICAgIFxcclxcbiAgICBpZiAoZW5hYmxlZCkge1xcclxcbiAgICAgIHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJtb3VzZWRvd25cXFwiLCBtb3VzZWRvd25MaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICAgIHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgbW91c2Vkb3duTGlzdGVuZXIsIGZhbHNlKTtcXHJcXG4gICAgICBcXHJcXG4gICAgICB1dGlscy5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIG1vdXNldXBMaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICAgIHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJ0b3VjaGVuZFxcXCIsIG1vdXNldXBMaXN0ZW5lciwgZmFsc2UpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBBbiBhcnJheSBvZiB3aGVyZSB0aGUgbW92ZWFibGUgZWxlbWVudHMgY2FuIGJlIHBsYWNlZCBpbi5cXHJcXG4gICpcXHJcXG4gICogQHByb3BlcnR5IGdyb3VwRWxlbWVudHNcXHJcXG4gICogQHR5cGUgSFRNTEVsZW1lbnRbXVxcclxcbiAgKiovXFxyXFxuICB2YXIgZ3JvdXBFbGVtZW50cyA9IFsgXTtcXHJcXG4gIFxcclxcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIG1vdmVhYmxlIGFuZCB0YXJnZXRlZCBlbGVtZW50cyBmb3IgdXNlIGluIG1vdXNlbW92ZVxcclxcbiAgdmFyIHJlbGF0aXZlTW91c2VQb3NpdGlvbiA9IG51bGw7XFxyXFxuICB2YXIgcmVmTW92ZWFibGVFbGVtZW50ID0gbnVsbDtcXHJcXG4gIHZhciByZWZUYXJnZXRlZEVsZW1lbnQgPSBudWxsO1xcclxcbiAgXFxyXFxuICAvLyBMb2NhbCBwcm9wZXJ0aWVzXFxyXFxuICAvKipcXHJcXG4gICogVXNlZCB0byBjaGVjayBpZiB0aGUgZHJhZyBcXCduXFwnIGRyb3AgaXMgZW5hYmxlZC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgbW9kdWxlRW5hYmxlZFxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIHZhciBtb2R1bGVFbmFibGVkID0gZmFsc2U7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBVc2VkIHRvIGNoZWNrIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLFxcclxcbiAgKiBhbmQgaWYgaXQgaXMgdGhlbiBpdCBzaG91bGQgbW92ZSB0aGUgZWxlbWVudC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgbW91c2Vkb3duXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgdmFyIG1vdXNlZG93biA9IGZhbHNlO1xcclxcbiAgXFxyXFxuICAvLyBUaHJvdHRsZSB0aGUgbGlzdGVuZXIgYXMgaXQgY2FuIGJlIHRheGluZyBmb3IgdGhlIHVzZXJzIHN5c3RlbS5cXHJcXG4gIG1vdXNlbW92ZUxpc3RlbmVyID0gdXRpbHMudGhyb3R0bGUobW91c2Vtb3ZlTGlzdGVuZXIsIDUwKTtcXHJcXG4gIFxcclxcbiAgZXhwb3J0cy5zZXRHcm91cEVsZW1lbnRzID0gc2V0R3JvdXBFbGVtZW50cztcXHJcXG4gIGV4cG9ydHMuc2V0RW5hYmxlZCA9IHNldEVuYWJsZWQ7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3BsYWNlbWVudC1kcmFnZHJvcC5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ2VsZW1lbnQtcGxhY2VtZW50XFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCIuL3V0aWxzXFxcIiwgXFxcIi4vcGxhY2VtZW50LWRyYWdkcm9wXFxcIiwgXFxcIi4vcGFnZWxvYWRcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgdXRpbHMsIGRyYWdkcm9wLCBwYWdlbG9hZCl7XFxyXFxuICAvKipcXHJcXG4gICogQWRkaW5nIGFuIGVsZW1lbnQgdG8gYSBkZWZpbmVkIGdyb3VwLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgYWRkRWxlbWVudFxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBncm91cC5cXHJcXG4gICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdyb3VwLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBhZGRFbGVtZW50KGlkLCBlbGVtZW50SWQsIGVsZW1lbnQpIHtcXHJcXG4gICAgaWYgKCFncm91cHNbaWRdKSB0aHJvdyBcXFwiR3JvdXAgXFxcIiArIGlkICsgXFxcIiBoYXMgbm90IGJlZW4gY3JlYXRlZCFcXFwiO1xcclxcbiAgICBncm91cHNbaWRdLmNoaWxkcmVuLnB1c2goeyBpZDogZWxlbWVudElkLCBlbGVtZW50OiBlbGVtZW50IH0pO1xcclxcbiAgICBcXHJcXG4gICAgLy8gQXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSBncm91cCBlbGVtZW50XFxyXFxuICAgIGdyb3Vwc1tpZF0uZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENyZWF0aW5nIGEgZ3JvdXAgd2hlcmUgdGhlIGVsZW1lbnRzIHdpbGwgYmUgcGxhY2VkIGluLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGNcXHJcXG4gICogQG1ldGhvZCBjcmVhdGVHcm91cFxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBncm91cC5cXHJcXG4gICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZ3JvdXAgZWxlbWVudC5cXHJcXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBncm91cC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gY3JlYXRlR3JvdXAoaWQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcXHJcXG4gICAgaWYgKGdyb3Vwc1tpZF0pIHRocm93IFxcXCJHcm91cCBcXFwiICsgaWQgKyBcXFwiIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCFcXFwiO1xcclxcbiAgICBncm91cHNbaWRdID0ge1xcclxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsIC8vIFRoZSBjb250YWluZXIgZWxlbWVudCB3aGVyZSB0aGUgY2hpbGRyZW4gcmVzaWRlc1xcclxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIFRoZSBvcHRpb25zIGZvciB0aGF0IHNwZWNpZmljIGdyb3VwXFxyXFxuICAgICAgY2hpbGRyZW46IFtdXFxyXFxuICAgIH07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgZ2V0RWxlbWVudFVuaXF1ZUlkXFxyXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBlbGVtZW50IGZyb20uXFxyXFxuICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIGVsZW1lbnQuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRVbmlxdWVJZChlbGVtZW50KSB7XFxyXFxuICAgIHZhciBjbGFzc2VzID0gdXRpbHMubGlzdENsYXNzKGVsZW1lbnQpO1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChjbGFzc2VzW2ldICE9PSBcXFwiXFxcIikge1xcclxcbiAgICAgICAgY2xhc3Nlc1tpXSA9IGVuY29kZVVSSUNvbXBvbmVudChjbGFzc2VzW2ldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIHtcXHJcXG4gICAgICBjbGFzc2VzID0gXFxcIi5cXFwiICsgY2xhc3Nlcy5qb2luKFxcXCIuXFxcIik7XFxyXFxuICAgICAgaWYgKGNsYXNzZXNbY2xhc3Nlcy5sZW5ndGggLSAxXSA9PT0gXFxcIi5cXFwiKSB7XFxyXFxuICAgICAgICBjbGFzc2VzID0gY2xhc3Nlcy5zdWJzdHJpbmcoMCwgY2xhc3Nlcy5sZW5ndGggLSAxKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgY2xhc3NlcyA9IFxcXCJcXFwiO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICB2YXIgaWQgPSBnZXRHcm91cElkQnlFbGVtZW50KGVsZW1lbnQpO1xcclxcbiAgICBpZiAodHlwZW9mIGlkID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgIGlkID0gXFxcIkBcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpO1xcclxcbiAgICAgIGlmIChpZCkge1xcclxcbiAgICAgICAgaWQgPSBcXFwiI1xcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBpZCA9IFxcXCJcXFwiO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgdmFyIHRhZ05hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZWxlbWVudC50YWdOYW1lKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciB1aWQgPSBudWxsO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcXHJcXG4gICAgXFxyXFxuICAgIGlmICghaWQgJiYgIWNsYXNzZXMgJiYgcGFyZW50KSB7XFxyXFxuICAgICAgdmFyIHBhcmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIGlmIChwYXJlbnROb2RlLmNoaWxkcmVuW2ldID09PSBlbGVtZW50KSB7XFxyXFxuICAgICAgICAgIHVpZCA9IHRhZ05hbWUgKyBcXFwiW1xcXCIgKyBpICsgXFxcIl1cXFwiXFxyXFxuICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB1aWQgPSB0YWdOYW1lICsgaWQgKyBjbGFzc2VzO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICBpZiAoIWlkICYmIHBhcmVudCkge1xcclxcbiAgICAgIHJldHVybiBnZXRFbGVtZW50VW5pcXVlSWQoZWxlbWVudC5wYXJlbnROb2RlKSArIFxcXCIgXFxcIiArIHVpZDtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICByZXR1cm4gdWlkO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgdW5pcXVlIElELlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgZ2V0RWxlbWVudEJ5VW5pcXVlSWRcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSB1bmlxdWUgSUQuXFxyXFxuICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCB3aXRoIHRoZSB1bmlxdWUgSUQuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRCeVVuaXF1ZUlkKHVpZCkge1xcclxcbiAgICB2YXIgdG9rZW5zID0gdWlkLnNwbGl0KFxcXCIgXFxcIik7XFxyXFxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIHZhciBtYXRjaCA9IC8oW2EtekEtWjAtOV8lXFxcXC1dKykoXFxcXFtbMC05XStcXFxcXSk/KChcXFxcI3xcXFxcQClbYS16QS1aMC05XyVcXFxcLV0rKT8oKFxcXFwuW2EtekEtWjAtOV8lXFxcXC1dKykqKS9nLmV4ZWModG9rZW5zW2ldKTtcXHJcXG4gICAgICB2YXIgdGFnTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSk7XFxyXFxuICAgICAgdmFyIGNoaWxkSW5kZXggPSBudWxsO1xcclxcbiAgICAgIGlmIChtYXRjaFsyXSkge1xcclxcbiAgICAgICAgY2hpbGRJbmRleCA9IHBhcnNlSW50KG1hdGNoWzJdLnN1YnN0cmluZygxLCBtYXRjaFsyXS5sZW5ndGggLSAxKSwgMTApO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICB2YXIgaWQgPSBudWxsO1xcclxcbiAgICAgIHZhciByZWdJZCA9IGZhbHNlO1xcclxcbiAgICAgIGlmIChtYXRjaFszXSkge1xcclxcbiAgICAgICAgaWYgKG1hdGNoWzNdLnN1YnN0cmluZygwLCAxKSA9PT0gXFxcIkBcXFwiKSB7XFxyXFxuICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgcmVnaXN0ZXJlZCBncm91cC5cXHJcXG4gICAgICAgICAgcmVnSWQgPSB0cnVlO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWQgPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10uc3Vic3RyaW5nKDEpKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgXFxyXFxuICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcXHJcXG4gICAgICBpZiAobWF0Y2hbNV0pIHtcXHJcXG4gICAgICAgIGNsYXNzZXMgPSBtYXRjaFs1XS5zdWJzdHJpbmcoMSkuc3BsaXQoXFxcIi5cXFwiKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBjbGFzc2VzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xcclxcbiAgICAgICAgY2xhc3Nlc1tqXSA9IGRlY29kZVVSSUNvbXBvbmVudChjbGFzc2VzW2pdKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgXFxyXFxuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50O1xcclxcbiAgICAgIGlmIChlbGVtZW50KSB7XFxyXFxuICAgICAgICBkb2MgPSBlbGVtZW50O1xcclxcbiAgICAgIH1cXHJcXG4gICAgICB2YXIgY29udGludWVzID0gZmFsc2U7XFxyXFxuICAgICAgaWYgKGlkKSB7XFxyXFxuICAgICAgICBpZiAocmVnSWQpIHtcXHJcXG4gICAgICAgICAgZWxlbWVudCA9IGdldEdyb3VwRWxlbWVudEJ5VW5pcXVlSWQoaWQpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9IGVsc2UgaWYgKGNsYXNzZXMubGVuZ3RoID4gMCkge1xcclxcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3Nlcy5qb2luKFxcXCIgXFxcIikpO1xcclxcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBlbGVtZW50cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcXHJcXG4gICAgICAgICAgaWYgKGVsZW1lbnRzW2pdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XFxyXFxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2pdO1xcclxcbiAgICAgICAgICAgIGNvbnRpbnVlcyA9IHRydWU7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmICghY29udGludWVzKSByZXR1cm4gbnVsbDtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZEluZGV4ID09PSBcXFwibnVtYmVyXFxcIikge1xcclxcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xcclxcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBlbGVtZW50cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcXHJcXG4gICAgICAgICAgaWYgKGVsZW1lbnRzW2pdICYmIGVsZW1lbnRzW2pdLnBhcmVudE5vZGUgJiYgZWxlbWVudHNbal0ucGFyZW50Tm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGVsZW1lbnRzW2pdLnBhcmVudE5vZGUuY2hpbGRyZW5bY2hpbGRJbmRleF0gPT09IGVsZW1lbnRzW2pdKSB7XFxyXFxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2pdO1xcclxcbiAgICAgICAgICAgIGNvbnRpbnVlcyA9IHRydWU7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmICghY29udGludWVzKSByZXR1cm4gbnVsbDtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgZWxlbWVudCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKVswXTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgXFxyXFxuICAgICAgaWYgKCFlbGVtZW50KSB7XFxyXFxuICAgICAgICByZXR1cm4gbnVsbDtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIHJldHVybiBlbGVtZW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogR2V0IHRoZSBncm91cCBlbGVtZW50IGJ5IGFuIHVuaXF1ZSBJRC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldEdyb3VwRWxlbWVudEJ5VW5pcXVlSWRcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSB1bmlxdWUgSWQgb2YgdGhlIGdyb3VwIGVsZW1lbnQuXFxyXFxuICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgZ3JvdXAgZWxlbWVudC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0R3JvdXBFbGVtZW50QnlVbmlxdWVJZChpZCkge1xcclxcbiAgICBmb3IgKHZhciBrZXkgaW4gZ3JvdXBzKSB7XFxyXFxuICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICBpZiAoa2V5ID09PSBpZCkge1xcclxcbiAgICAgICAgICByZXR1cm4gZ3JvdXBzW2tleV0uZWxlbWVudDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIG51bGw7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIGdyb3VwIElEIGJ5IGVsZW1lbnQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRHcm91cElkQnlFbGVtZW50XFxyXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBncm91cCBlbGVtZW50LlxcclxcbiAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB1bmlxdWUgSWQgb2YgdGhlIGdyb3VwIGVsZW1lbnQuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldEdyb3VwSWRCeUVsZW1lbnQoZWwpIHtcXHJcXG4gICAgZm9yICh2YXIga2V5IGluIGdyb3Vwcykge1xcclxcbiAgICAgIGlmIChncm91cHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgaWYgKGdyb3Vwc1trZXldLmVsZW1lbnQgPT09IGVsKSB7XFxyXFxuICAgICAgICAgIHJldHVybiBrZXk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBudWxsO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogR2V0IGEgcmVnaXN0ZXJlZCBlbGVtZW50XFwncyB1bmlxdWUgSUQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRSZWdpc3RlcmVkRWxlbWVudFVuaXF1ZUlkXFxyXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSByZWdpc3RlcmVkIGVsZW1lbnQuXFxyXFxuICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIHJlZ2lzdGVyZWQgZWxlbWVudC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEVsZW1lbnRVbmlxdWVJZChlbCkge1xcclxcbiAgICBmb3IgKHZhciBrZXkgaW4gZ3JvdXBzKSB7XFxyXFxuICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBncm91cHNba2V5XS5jaGlsZHJlbjtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgICBpZiAoZWwgPT09IGNoaWxkcmVuW2ldLmVsZW1lbnQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV0uaWQ7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIG51bGw7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgYSByZWdpc3RlcmVkIGVsZW1lbnQgYnkgaXRzIHVuaXF1ZSBJRC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldFJlZ2lzdGVyZWRFbGVtZW50QnlVbmlxdWVJZFxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIHVuaXF1ZSBJRCBvZiB0aGUgZWxlbWVudC5cXHJcXG4gICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFJldHVybnMgdGhlIGVsZW1lbnQuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRFbGVtZW50QnlVbmlxdWVJZChpZCkge1xcclxcbiAgICBmb3IgKHZhciBrZXkgaW4gZ3JvdXBzKSB7XFxyXFxuICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBncm91cHNba2V5XS5jaGlsZHJlbjtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgICBpZiAoaWQgPT09IGNoaWxkcmVuW2ldLmlkKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldLmVsZW1lbnQ7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIG51bGw7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIHJlZ2lzdGVyZWQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBpc0VsZW1lbnRSZWdpc3RlcmVkXFxyXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRvIGNoZWNrIGlmIGl0cyByZWdpc3RlcmVkLlxcclxcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgZWxlbWVudCBpcyByZWdpc3RlcmVkIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGlzRWxlbWVudFJlZ2lzdGVyZWQoZWwpIHtcXHJcXG4gICAgZm9yICh2YXIgaWQgaW4gZ3JvdXBzKSB7XFxyXFxuICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcXHJcXG4gICAgICAgIGlmIChpc0VsZW1lbnRJbkdyb3VwKGVsLCBpZCkpIHtcXHJcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBmYWxzZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZCBpbiBhIHNwZWNpZmljIGdyb3VwLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgaXNFbGVtZW50UmVnaXN0ZXJlZFxcclxcbiAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBjaGVjayBpZiBpdHMgcmVnaXN0ZXJlZC5cXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWQgVGhlIGdyb3VwIElELlxcclxcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgZWxlbWVudCBpcyByZWdpc3RlcmVkIGluIHNwZWNpZmllZCBncm91cCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBpc0VsZW1lbnRJbkdyb3VwKGVsLCBncm91cElkKSB7XFxyXFxuICAgIGlmICghZ3JvdXBzW2dyb3VwSWRdKSByZXR1cm4gZmFsc2U7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgY2hpbGRyZW4gPSBncm91cHNbZ3JvdXBJZF0uY2hpbGRyZW47XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChjaGlsZHJlbltpXS5lbGVtZW50ID09PSBlbCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBmYWxzZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENyZWF0ZSBhIHJlZmVyZW5jZSBzdGF0ZSB0byB1c2UgYXMgYW4gcmVmZXJlbmNlIHdoZW4gZWxlbWVudHMgaGF2ZSBiZWVuIG1vdmVkLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgY3JlYXRlUmVmZXJlbmNlU3RhdGVcXHJcXG4gICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVmZXJlbmNlIHN0YXRlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VTdGF0ZSgpIHtcXHJcXG4gICAgdmFyIG1hcCA9IHt9O1xcclxcbiAgICBmb3IgKHZhciBrZXkgaW4gZ3JvdXBzKSB7XFxyXFxuICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNba2V5XTtcXHJcXG4gICAgICAgIFxcclxcbiAgICAgICAgdmFyIGdyb3VwRWxlbWVudHMgPSBbXTtcXHJcXG4gICAgICAgIHZhciBlbCA9IGdyb3VwLmVsZW1lbnQ7XFxyXFxuICAgICAgICBpZiAoZWwgJiYgZWwuY2hpbGRyZW4pIHtcXHJcXG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XFxyXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xcclxcbiAgICAgICAgICAgIHZhciBkYXRhID0geyB9O1xcclxcbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnRSZWdpc3RlcmVkKGNoaWxkKSkge1xcclxcbiAgICAgICAgICAgICAgZGF0YS50eXBlID0gUkVHSVNURVJFRDtcXHJcXG4gICAgICAgICAgICAgIGRhdGEudW5pcXVlSWQgPSBnZXRSZWdpc3RlcmVkRWxlbWVudFVuaXF1ZUlkKGNoaWxkKTtcXHJcXG4gICAgICAgICAgICAgIGRhdGEuZWxlbWVudCA9IGNoaWxkO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICBkYXRhLnR5cGUgPSBOT05SRUdJU1RFUkVEO1xcclxcbiAgICAgICAgICAgICAgZGF0YS51bmlxdWVJZCA9IGdldEVsZW1lbnRVbmlxdWVJZChjaGlsZCk7XFxyXFxuICAgICAgICAgICAgICBkYXRhLmVsZW1lbnQgPSBjaGlsZDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZ3JvdXBFbGVtZW50cy5wdXNoKGRhdGEpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBtYXBba2V5XSA9IGdyb3VwRWxlbWVudHM7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBtYXA7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIHVuaXF1ZSBJRCBvZiBhbiByZWZlcmVuY2VkIGVsZW1lbnQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRSZWZlcmVuY2VkVW5pcXVlSWRcXHJcXG4gICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQuXFxyXFxuICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGVsZW1lbnQuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldFJlZmVyZW5jZWRVbmlxdWVJZChlbCkge1xcclxcbiAgICBpZiAoIXJlZmVyZW5jZVN0YXRlKSByZXR1cm4gbnVsbDtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGtleSBpbiByZWZlcmVuY2VTdGF0ZSkge1xcclxcbiAgICAgIGlmIChyZWZlcmVuY2VTdGF0ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxyXFxuICAgICAgICB2YXIgZ3JvdXAgPSByZWZlcmVuY2VTdGF0ZVtrZXldO1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3VwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgIGlmIChlbCA9PT0gZ3JvdXBbaV0uZWxlbWVudCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBncm91cFtpXS51bmlxdWVJZDtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gbnVsbDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEdldCB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYnkgdGhlIHVuaXF1ZSBJRC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldFJlZmVyZW5jZWRFbGVtZW50XFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBlbCBUaGUgdW5pcXVlIElELlxcclxcbiAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgdGhlIGVsZW1lbnQgZ2l2ZW4gYnkgdGhlIHVuaXF1ZSBJRC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlZEVsZW1lbnQoaWQpIHtcXHJcXG4gICAgaWYgKCFyZWZlcmVuY2VTdGF0ZSkgcmV0dXJuIG51bGw7XFxyXFxuICAgIFxcclxcbiAgICBmb3IgKHZhciBrZXkgaW4gcmVmZXJlbmNlU3RhdGUpIHtcXHJcXG4gICAgICBpZiAocmVmZXJlbmNlU3RhdGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgdmFyIGdyb3VwID0gcmVmZXJlbmNlU3RhdGVba2V5XTtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgICBpZiAoaWQgPT09IGdyb3VwW2ldLnVuaXF1ZUlkKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwW2ldLmVsZW1lbnQ7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIG51bGw7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRTdGF0ZVxcclxcbiAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YXRlIG9iamVjdC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XFxyXFxuICAgIHZhciBtYXAgPSB7fTtcXHJcXG4gICAgZm9yICh2YXIga2V5IGluIGdyb3Vwcykge1xcclxcbiAgICAgIGlmIChncm91cHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2tleV07XFxyXFxuICAgICAgICBcXHJcXG4gICAgICAgIHZhciBncm91cEVsZW1lbnRzID0gW107XFxyXFxuICAgICAgICB2YXIgZWwgPSBncm91cC5lbGVtZW50O1xcclxcbiAgICAgICAgaWYgKGVsICYmIGVsLmNoaWxkcmVuKSB7XFxyXFxuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xcclxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcXHJcXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgfTtcXHJcXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50UmVnaXN0ZXJlZChjaGlsZCkpIHtcXHJcXG4gICAgICAgICAgICAgIGRhdGEudHlwZSA9IFJFR0lTVEVSRUQ7XFxyXFxuICAgICAgICAgICAgICBkYXRhLnVuaXF1ZUlkID0gZ2V0UmVnaXN0ZXJlZEVsZW1lbnRVbmlxdWVJZChjaGlsZCk7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgIGRhdGEudHlwZSA9IE5PTlJFR0lTVEVSRUQ7XFxyXFxuICAgICAgICAgICAgICBkYXRhLnVuaXF1ZUlkID0gZ2V0UmVmZXJlbmNlZFVuaXF1ZUlkKGNoaWxkLCByZWZlcmVuY2VTdGF0ZSkgfHwgZ2V0RWxlbWVudFVuaXF1ZUlkKGNoaWxkKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZ3JvdXBFbGVtZW50cy5wdXNoKGRhdGEpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBtYXBba2V5XSA9IGdyb3VwRWxlbWVudHM7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBtYXA7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBTZXQgdGhlIHN0YXRlLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2Qgc2V0U3RhdGVcXHJcXG4gICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSB0byBiZSBhcHBsaWVkLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xcclxcbiAgICB1dGlscy5lYWNoKHN0YXRlLCBmdW5jdGlvbihncm91cElkLCBlbGVtZW50cyl7XFxyXFxuICAgICAgaWYgKCFncm91cHNbZ3JvdXBJZF0pIGNvbi53YXJuKFxcXCJHcm91cCBcXFwiICsgZ3JvdXBJZCArIFxcXCIgZG9lcyBub3QgZXhpc3QhXFxcIik7XFxyXFxuICAgICAgXFxyXFxuICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2dyb3VwSWRdO1xcclxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcXHJcXG4gICAgICAgIHZhciBlbCA9IG51bGw7XFxyXFxuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUdJU1RFUkVEKSB7XFxyXFxuICAgICAgICAgIGVsID0gZ2V0UmVnaXN0ZXJlZEVsZW1lbnRCeVVuaXF1ZUlkKGVsZW1lbnQudW5pcXVlSWQpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUgPT09IE5PTlJFR0lTVEVSRUQpIHtcXHJcXG4gICAgICAgICAgZWwgPSBnZXRSZWZlcmVuY2VkRWxlbWVudChlbGVtZW50LnVuaXF1ZUlkLCByZWZlcmVuY2VTdGF0ZSkgfHwgZ2V0RWxlbWVudEJ5VW5pcXVlSWQoZWxlbWVudC51bmlxdWVJZCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBcXHJcXG4gICAgICAgIGlmIChlbCAhPT0gbnVsbCkge1xcclxcbiAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xcclxcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICAgIFxcclxcbiAgICAgICAgICBncm91cC5lbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIGNvbi53YXJuKFxcXCJVbmtub3duIGVsZW1lbnQgaW4gc2V0dGluZ3NcXFwiLCBlbGVtZW50KTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0pO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogRW5hYmxlL2Rpc2FibGUgdGhlIGRyYWcgXFwnblxcJyBkcm9wLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2Qgc2V0TW92ZWFibGVcXHJcXG4gICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkIFdoZXRoZXIgdGhlIGRyYWcgXFwnblxcJyBkcm9wIHNob3VsZCBiZSBlbmFibGVkLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBzZXRNb3ZlYWJsZShlbmFibGVkKSB7XFxyXFxuICAgIGRyYWdkcm9wLnNldEdyb3VwRWxlbWVudHMoZ2V0R3JvdXBFbGVtZW50cygpKTtcXHJcXG4gICAgZHJhZ2Ryb3Auc2V0RW5hYmxlZChlbmFibGVkKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEdldCBldmVyeSByZWdpc3RlcmVkIGVsZW1lbnQgaW4gZXZlcnkgZ3JvdXAuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBnZXRHcm91cEVsZW1lbnRzXFxyXFxuICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119IFJldHVybnMgZXZlcnkgcmVnaXN0ZXJlZCBlbGVtZW50IGluIGV2ZXJ5IHJlZ2lzdGVyZWQgZ3JvdXAuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGdldEdyb3VwRWxlbWVudHMoKSB7XFxyXFxuICAgIHZhciBncm91cEVsZW1lbnRzID0gW107XFxyXFxuICAgIGZvciAodmFyIGtleSBpbiBncm91cHMpIHtcXHJcXG4gICAgICBpZiAoZ3JvdXBzLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgIGdyb3VwRWxlbWVudHMucHVzaChncm91cHNba2V5XS5lbGVtZW50KTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGdyb3VwRWxlbWVudHM7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDbGVhciBldmVyeSByZWdpc3RlcmVkIGdyb3VwIGFuZCByZWdpc3RlcmVkIGVsZW1lbnRzLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBtZXRob2QgY2xlYXJHcm91cHNcXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gY2xlYXJHcm91cHMoKSB7XFxyXFxuICAgIGdyb3VwcyA9IHt9O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogU2V0IHRoZSByZWZlcmVuY2Ugc3RhdGUuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBzZXRSZWZlcmVuY2VTdGF0ZVxcclxcbiAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgVGhlIHJlZmVyZW5jZSBzdGF0ZS5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gc2V0UmVmZXJlbmNlU3RhdGUoc3RhdGUpIHtcXHJcXG4gICAgcmVmZXJlbmNlU3RhdGUgPSBzdGF0ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEluaXRpYWxpemUgdGhlIHJlZmVyZW5jZSBzdGF0ZSBhbmQgbW92ZSBlbGVtZW50cy5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGluaXRcXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gaW5pdCgpIHtcXHJcXG4gICAgc2V0UmVmZXJlbmNlU3RhdGUoY3JlYXRlUmVmZXJlbmNlU3RhdGUoKSk7XFxyXFxuICAgIFxcclxcbiAgICBcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFZhbHVlIGdpdmVuIHRvIHJlZ2lzdGVyZWQgZWxlbWVudHMuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IFJFR0lTVEVSRURcXHJcXG4gICogQHR5cGUge051bWJlcn1cXHJcXG4gICogQGRlZmF1bHQgMFxcclxcbiAgKiovXFxyXFxuICB2YXIgUkVHSVNURVJFRCA9IDA7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBWYWx1ZSBnaXZlbiB0byBub3QgcmVnaXN0ZXJlZCBlbGVtZW50cy5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgTk9OUkVHSVNURVJFRFxcclxcbiAgKiBAdHlwZSB7TnVtYmVyfVxcclxcbiAgKiBAZGVmYXVsdCAxXFxyXFxuICAqKi9cXHJcXG4gIHZhciBOT05SRUdJU1RFUkVEID0gMTtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSByZWdpc3RlcmVkIGdyb3VwcyBhbmQgaXRzIHJlZ2lzdGVyZWQgZWxlbWVudCBjaGlsZHJlblxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBncm91cHNcXHJcXG4gICogQHR5cGUge09iamVjdH1cXHJcXG4gICoqL1xcclxcbiAgdmFyIGdyb3VwcyA9IHt9O1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVGhlIHJlZmVyZW5jZSBzdGF0ZS5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgcmVmZXJlbmNlU3RhdGVcXHJcXG4gICogQHR5cGUge09iamVjdH1cXHJcXG4gICoqL1xcclxcbiAgdmFyIHJlZmVyZW5jZVN0YXRlID0gbnVsbDtcXHJcXG4gIFxcclxcbiAgcGFnZWxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcXFwiaW50ZXJhY3RpdmVcXFwiLCBpbml0KTtcXHJcXG4gIFxcclxcbiAgLyogTWFrZSB0aGUgQVBJIHB1YmxpYyAqL1xcclxcbiAgZXhwb3J0cy5zZXRNb3ZlYWJsZSA9IHNldE1vdmVhYmxlO1xcclxcbiAgZXhwb3J0cy5hZGRFbGVtZW50ID0gYWRkRWxlbWVudDtcXHJcXG4gIGV4cG9ydHMuY3JlYXRlR3JvdXAgPSBjcmVhdGVHcm91cDtcXHJcXG4gIGV4cG9ydHMuZ2V0U3RhdGUgPSBnZXRTdGF0ZTtcXHJcXG4gIGV4cG9ydHMuc2V0U3RhdGUgPSBzZXRTdGF0ZTtcXHJcXG4gIGV4cG9ydHMuY3JlYXRlUmVmZXJlbmNlU3RhdGUgPSBjcmVhdGVSZWZlcmVuY2VTdGF0ZTtcXHJcXG4gIGV4cG9ydHMuc2V0UmVmZXJlbmNlU3RhdGUgPSBzZXRSZWZlcmVuY2VTdGF0ZTtcXHJcXG4gIGV4cG9ydHMuY2xlYXJHcm91cHMgPSBjbGVhckdyb3VwcztcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vZWxlbWVudC1wbGFjZW1lbnQuanNcIik7XG5cbiIsCiAgICAiZXZhbChcIi8qKlxcclxcbiogQSBncm91cCBtb2R1bGUgZm9yIHRoZSBlbGVtZW50LXBsYWNtZW50IG1vZHVsZS5cXHJcXG4qXFxyXFxuKiBAY2xhc3MgU2VudGltZW50QWN0aW9uc1xcclxcbioqL1xcclxcbmRlZmluZShcXCdlbGVtZW50LXBsYWNlbWVudC93YXRjaDgteXRjZW50ZXItYnV0dG9uc1xcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwiLi4vZWxlbWVudC1wbGFjZW1lbnRcXFwiLCBcXFwiLi4vdXRpbHNcXFwiLCBcXFwiLi4vcGFnZWxvYWRcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgcGxhY2VtZW50LCB1dGlscywgcGFnZWxvYWQpe1xcclxcbiAgZnVuY3Rpb24gb25JbnRlcmFjdGl2ZSgpIHtcXHJcXG4gICAgLy8gQ3JlYXRlIHRoZSBncm91cCBlbGVtZW50XFxyXFxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxyXFxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIGlkKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcIndhdGNoOC1hY3Rpb24tYnV0dG9uc1xcXCIpO1xcclxcbiAgICBpZiAocGFyZW50RWxlbWVudCkge1xcclxcbiAgICAgIGlmIChwYXJlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xcclxcbiAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgcGFyZW50RWxlbWVudC5jaGlsZHJlblswXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICAvLyBDcmVhdGUgdGhlIGdyb3VwXFxyXFxuICAgIHBsYWNlbWVudC5jcmVhdGVHcm91cChpZCwgZWxlbWVudCk7XFxyXFxuICAgIFxcclxcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50cyBhcmUgbm8gbW9yZSBhZGRlZCB0byB0aGUgYnVmZmVyXFxyXFxuICAgIGdyb3VwQ3JlYXRlZCA9IHRydWU7XFxyXFxuICAgIFxcclxcbiAgICAvLyBBZGQgYnVmZmVyZWQgZWxlbWVudHMgdG8gdGhlIGdyb3VwXFxyXFxuICAgIGlmIChncm91cEJ1ZmZlci5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3VwQnVmZmVyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICBwbGFjZW1lbnQuYWRkRWxlbWVudChpZCwgZ3JvdXBCdWZmZXJbaV1bMF0sIGdyb3VwQnVmZmVyW2ldWzFdKTsgLy8gQWRkaW5nIHRoZSBlbGVtZW50IHRvIHRoZSBncm91cFxcclxcbiAgICAgIH1cXHJcXG4gICAgICBncm91cEJ1ZmZlciA9IFtdOyAvLyBSZW1vdmUgcmVmZXJlbmNlIGZvciBldmVyeSBidWZmZXJlZCBlbGVtZW50LlxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBBZGQgYW4gZWxlbWVudCB0byB0aGUgZ3JvdXAuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBhZGRFbGVtZW50XFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBBbiB1bmlxdWUgaWQgZm9yIHRoZSBlbGVtZW50XFxyXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBncm91cC5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gYWRkRWxlbWVudCh1aWQsIGVsKSB7XFxyXFxuICAgIGlmIChncm91cENyZWF0ZWQpIHtcXHJcXG4gICAgICBwbGFjZW1lbnQuYWRkRWxlbWVudChpZCwgdWlkLCBlbCk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgZ3JvdXBCdWZmZXIucHVzaChbIHVpZCwgZWwgXSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIFRoZSBpZCBvZiB0aGUgZ3JvdXAuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGlkXFxyXFxuICAqIEB0eXBlIFN0cmluZ1xcclxcbiAgKiBAcmVhZE9ubHlcXHJcXG4gICoqL1xcclxcbiAgdmFyIGlkID0gXFxcIndhdGNoOC15dGNlbnRlci1idXR0b25zXFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBncm91cCBoYXMgYmVlbiBjcmVhdGVkIHlldC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgZ3JvdXBDcmVhdGVkXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgdmFyIGdyb3VwQ3JlYXRlZCA9IGZhbHNlO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogVGhlIGJ1ZmZlcmVkIGVsZW1lbnQuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IGdyb3VwQnVmZmVyXFxyXFxuICAqIEB0eXBlIEhUTUxFbGVtZW50W11cXHJcXG4gICoqL1xcclxcbiAgdmFyIGdyb3VwQnVmZmVyID0gW107XFxyXFxuICBcXHJcXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBncm91cCBpcyBjcmVhdGVkIHdoZW4gdGhlIHBhZ2UgaGFzIGxvYWRlZCBldmVyeSBET00gZWxlbWVudC5cXHJcXG4gIHBhZ2Vsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXFxcImludGVyYWN0aXZlXFxcIiwgb25JbnRlcmFjdGl2ZSk7XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuYWRkRWxlbWVudCA9IGFkZEVsZW1lbnQ7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L2VsZW1lbnQtcGxhY2VtZW50L3dhdGNoOC15dGNlbnRlci1idXR0b25zLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnY3NzXFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCIuL2NvbnNvbGVcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgY29uKXtcXHJcXG4gIGZ1bmN0aW9uIGlzQ1NTRWxlbWVudEVuYWJsZWQoaWQpIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVuYWJsZWRDU1NFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChlbmFibGVkQ1NTRWxlbWVudHNbaV0gPT09IGlkKSB7XFxyXFxuICAgICAgICByZXR1cm4gaTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIC0xO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBjcmVhdGVDU1NFbGVtZW50KGlkKSB7XFxyXFxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIik7XFxyXFxuICAgIGVsLnNldEF0dHJpYnV0ZShcXFwiaWRcXFwiLCBwcmVmaXggKyBpZCk7XFxyXFxuICAgIGVsLnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJ0ZXh0XFxcXC9jc3NcXFwiKTtcXHJcXG4gICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzT2JqZWN0W2lkXSkpO1xcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIGVsO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBhcHBlbmRDU1NFbGVtZW50KGlkKSB7XFxyXFxuICAgIHZhciBlbCA9IGNzc0VsZW1lbnRzW2lkXTtcXHJcXG4gICAgcmVtb3ZlQ2hpbGRGcm9tUGFyZW50KGVsKTtcXHJcXG4gICAgXFxyXFxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XFxyXFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XFxyXFxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuaGVhZCkge1xcclxcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xcclxcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcclxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XFxyXFxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQpIHtcXHJcXG4gICAgICBkb2N1bWVudC5hcHBlbmRDaGlsZChlbCk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgY29uLmVycm9yKFxcXCJCcm93c2VyIGRvY3VtZW50IG5vdCBmb3VuZC5cXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVDaGlsZEZyb21QYXJlbnQoZWwpIHtcXHJcXG4gICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcXHJcXG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBzZXRDU1NFbGVtZW50RW5hYmxlZChpZCwgZW5hYmxlZCkge1xcclxcbiAgICBpZiAoIWNzc09iamVjdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcXHJcXG4gICAgICBjb24uZXJyb3IoXFxcIkNTUyBFbGVtZW50IFxcXCIgKyBpZCArIFxcXCIgd2FzIG5vdCByZWdpc3RlcmVkLCBtYWtlIHN1cmUgdGhhdCBpdCB3YXNuXFwndCBtaXNzcGVsbGVkIVxcXCIpO1xcclxcbiAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgdmFyIHBvcyA9IGlzQ1NTRWxlbWVudEVuYWJsZWQoaWQpO1xcclxcbiAgICBpZiAoZW5hYmxlZCkge1xcclxcbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XFxyXFxuICAgICAgICBlbmFibGVkQ1NTRWxlbWVudHMucHVzaChpZCk7XFxyXFxuICAgICAgICBpZiAoIWNzc0VsZW1lbnRzW2lkXSkge1xcclxcbiAgICAgICAgICBjc3NFbGVtZW50c1tpZF0gPSBjcmVhdGVDU1NFbGVtZW50KGlkKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGFwcGVuZENTU0VsZW1lbnQoaWQpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBpZiAocG9zICE9PSAtMSkge1xcclxcbiAgICAgICAgZW5hYmxlZENTU0VsZW1lbnRzLnNwbGljZShwb3MsIDEpO1xcclxcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tUGFyZW50KGNzc0VsZW1lbnRzW2lkXSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBwcmVmaXggPSBcXFwieXRjZW50ZXItXFxcIjtcXHJcXG4gIFxcclxcbiAgdmFyIGNzc09iamVjdCA9IHtcXFwieXQtdWl4XFxcIjpcXFwiLnl0Y2VudGVyLXVpeC1idXR0b24tdG9nZ2xlZHtib3JkZXItY29sb3I6I2M2YzZjNiFpbXBvcnRhbnQ7YmFja2dyb3VuZC1jb2xvcjojZTllOWU5IWltcG9ydGFudDstbW96LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpIWltcG9ydGFudDstbXMtYm94LXNoYWRvdzppbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMikhaW1wb3J0YW50Oy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMikhaW1wb3J0YW50O2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpIWltcG9ydGFudDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkdyYWRpZW50KEdyYWRpZW50VHlwZT0wLCBTdGFydENvbG9yU3RyPSNmZmY4ZjhmOCwgRW5kQ29sb3JTdHI9I2ZmZWVlZWVlKSFpbXBvcnRhbnQ7YmFja2dyb3VuZC1pbWFnZTotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsI2Y4ZjhmOCAwLCNlZWUgMTAwJSkhaW1wb3J0YW50O2JhY2tncm91bmQtaW1hZ2U6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsI2Y4ZjhmOCAwLCNlZWUgMTAwJSkhaW1wb3J0YW50O2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjZjhmOGY4IDAsI2VlZSAxMDAlKSFpbXBvcnRhbnQ7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2Y4ZjhmOCksY29sb3Itc3RvcCgxMDAlLCNlZWUpKSFpbXBvcnRhbnQ7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2Y4ZjhmOCAwLCNlZWUgMTAwJSkhaW1wb3J0YW50O2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZjhmOGY4IDAsI2VlZSAxMDAlKSFpbXBvcnRhbnR9XFxcIn07XFxyXFxuICB2YXIgY3NzRWxlbWVudHMgPSB7fTtcXHJcXG4gIHZhciBlbmFibGVkQ1NTRWxlbWVudHMgPSBbXTtcXHJcXG4gIFxcclxcbiAgZXhwb3J0cy5zZXRFbmFibGVkID0gc2V0Q1NTRWxlbWVudEVuYWJsZWQ7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L2Nzcy5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ2J1dHRvbnMvcmVwZWF0XFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCIuLi91dGlsc1xcXCIsIFxcXCIuLi9wbGF5ZXIvbGlzdGVuZXJzXFxcIiwgXFxcIi4uL3BsYXllci9wbGF5ZXJcXFwiLCBcXFwiLi4vZWxlbWVudC1wbGFjZW1lbnQvd2F0Y2g4LXl0Y2VudGVyLWJ1dHRvbnNcXFwiLCBcXFwiLi4vY3NzXFxcIl0sIGZ1bmN0aW9uKGV4cG9ydHMsIHV0aWxzLCBsaXN0ZW5lciwgcGxheWVyLCBncm91cCwgY3NzKXtcXHJcXG4gIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbigpIHtcXHJcXG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImJ1dHRvblxcXCIpO1xcclxcbiAgICBidG4uc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImJ1dHRvblxcXCIpO1xcclxcbiAgICBidG4uc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcImJ1dHRvblxcXCIpO1xcclxcbiAgICBidG4uc2V0QXR0cmlidXRlKFxcXCJvbmNsaWNrXFxcIiwgXFxcIjtyZXR1cm4gZmFsc2U7XFxcIik7XFxyXFxuICAgIGJ0bi5zZXRBdHRyaWJ1dGUoXFxcInRpdGxlXFxcIiwgXFxcIlRvZ2dsZSByZXBlYXRcXFwiKTtcXHJcXG4gICAgYnRuLnNldEF0dHJpYnV0ZShcXFwiZGF0YS10b29sdGlwLXRleHRcXFwiLCBcXFwiVG9nZ2xlIHJlcGVhdFxcXCIpO1xcclxcbiAgICBidG4uY2xhc3NOYW1lID0gXFxcInl0LXVpeC1idXR0b24geXQtdWl4LXRvb2x0aXAgeXQtdWl4LWJ1dHRvbi1vcGFjaXR5XFxcIjtcXHJcXG4gICAgXFxyXFxuICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3BhblxcXCIpO1xcclxcbiAgICB0ZXh0LmNsYXNzTmFtZSA9IFxcXCJ5dC11aXgtYnV0dG9uLWNvbnRlbnRcXFwiO1xcclxcbiAgICB0ZXh0LnRleHRDb250ZW50ID0gXFxcIlJlcGVhdFxcXCI7XFxyXFxuICAgIFxcclxcbiAgICBidG4uYXBwZW5kQ2hpbGQodGV4dCk7XFxyXFxuICAgIFxcclxcbiAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcXFwiY2xpY2tcXFwiLCB0b2dnbGVSZXBlYXQsIGZhbHNlKTtcXHJcXG4gICAgcmV0dXJuIGJ0bjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdG9nZ2xlUmVwZWF0KGUpIHtcXHJcXG4gICAgcmVwZWF0ID0gIXJlcGVhdDtcXHJcXG4gICAgXFxyXFxuICAgIGlmIChyZXBlYXQpIHtcXHJcXG4gICAgICB1dGlscy5yZW1vdmVDbGFzcyhyZXBlYXRCdXR0b24sIFxcXCJ5dC11aXgtYnV0dG9uLW9wYWNpdHlcXFwiKTtcXHJcXG4gICAgICB1dGlscy5hZGRDbGFzcyhyZXBlYXRCdXR0b24sIFxcXCJ5dGNlbnRlci11aXgtYnV0dG9uLXRvZ2dsZWRcXFwiKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB1dGlscy5hZGRDbGFzcyhyZXBlYXRCdXR0b24sIFxcXCJ5dC11aXgtYnV0dG9uLW9wYWNpdHlcXFwiKTtcXHJcXG4gICAgICB1dGlscy5yZW1vdmVDbGFzcyhyZXBlYXRCdXR0b24sIFxcXCJ5dGNlbnRlci11aXgtYnV0dG9uLXRvZ2dsZWRcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlKHN0YXRlKSB7XFxyXFxuICAgIGlmIChzdGF0ZSA9PT0gMCAmJiByZXBlYXQpIHtcXHJcXG4gICAgICBwbGF5ZXIuYXBpLnBsYXlWaWRlbygpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldEJ1dHRvbigpIHtcXHJcXG4gICAgcmV0dXJuIHJlcGVhdEJ1dHRvbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIHJlcGVhdCA9IGZhbHNlO1xcclxcbiAgdmFyIHJlcGVhdEJ1dHRvbiA9IGNyZWF0ZUJ1dHRvbigpO1xcclxcbiAgXFxyXFxuICBncm91cC5hZGRFbGVtZW50KFxcXCIvKnNob3VsZCBwcm9iYWJseSBoYXZlIGEgZ3VpZCBoZXJlKi9cXFwiLCByZXBlYXRCdXR0b24pO1xcclxcbiAgXFxyXFxuICBsaXN0ZW5lci5hZGRFdmVudExpc3RlbmVyKFxcXCJvblN0YXRlQ2hhbmdlXFxcIiwgb25TdGF0ZUNoYW5nZSk7XFxyXFxuICBcXHJcXG4gIGNzcy5zZXRFbmFibGVkKFxcXCJ5dC11aXhcXFwiLCB0cnVlKTtcXHJcXG4gIFxcclxcbiAgZXhwb3J0cy5nZXRCdXR0b24gPSBnZXRCdXR0b247XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L2J1dHRvbnMvcmVwZWF0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnbWFpblxcJyxbXFxcImJ1dHRvbnMvcmVwZWF0XFxcIl0sIGZ1bmN0aW9uKHJlcGVhdEJ1dHRvbil7XFxyXFxuICBcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9tYWluLmpzXCIpO1xuXG4iCiAgXQp9
}
(function () {eval("/**\r\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/jrburke/almond for details\r\n */\r\n//Going sloppy to avoid \'use strict\' string cost, but strict practices should\r\n//be followed.\r\n/*jslint sloppy: true */\r\n/*global setTimeout: false */\r\n\r\nvar requirejs, require, define;\r\n(function (undef) {\r\n    var main, req, makeMap, handlers,\r\n        defined = {},\r\n        waiting = {},\r\n        config = {},\r\n        defining = {},\r\n        hasOwn = Object.prototype.hasOwnProperty,\r\n        aps = [].slice,\r\n        jsSuffixRegExp = /\\.js$/;\r\n\r\n    function hasProp(obj, prop) {\r\n        return hasOwn.call(obj, prop);\r\n    }\r\n\r\n    /**\r\n     * Given a relative module name, like ./something, normalize it to\r\n     * a real name that can be mapped to a path.\r\n     * @param {String} name the relative name\r\n     * @param {String} baseName a real name that the name arg is relative\r\n     * to.\r\n     * @returns {String} normalized name\r\n     */\r\n    function normalize(name, baseName) {\r\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\r\n            foundI, foundStarMap, starI, i, j, part,\r\n            baseParts = baseName && baseName.split(\"/\"),\r\n            map = config.map,\r\n            starMap = (map && map[\'*\']) || {};\r\n\r\n        //Adjust any relative paths.\r\n        if (name && name.charAt(0) === \".\") {\r\n            //If have a base name, try to normalize against it,\r\n            //otherwise, assume it is a top-level require that will\r\n            //be relative to baseUrl in the end.\r\n            if (baseName) {\r\n                //Convert baseName to array, and lop off the last part,\r\n                //so that . matches that \"directory\" and not name of the baseName\'s\r\n                //module. For instance, baseName of \"one/two/three\", maps to\r\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\r\n                //this normalization.\r\n                baseParts = baseParts.slice(0, baseParts.length - 1);\r\n                name = name.split(\'/\');\r\n                lastIndex = name.length - 1;\r\n\r\n                // Node .js allowance:\r\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\r\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, \'\');\r\n                }\r\n\r\n                name = baseParts.concat(name);\r\n\r\n                //start trimDots\r\n                for (i = 0; i < name.length; i += 1) {\r\n                    part = name[i];\r\n                    if (part === \".\") {\r\n                        name.splice(i, 1);\r\n                        i -= 1;\r\n                    } else if (part === \"..\") {\r\n                        if (i === 1 && (name[2] === \'..\' || name[0] === \'..\')) {\r\n                            //End of the line. Keep at least one non-dot\r\n                            //path segment at the front so it can be mapped\r\n                            //correctly to disk. Otherwise, there is likely\r\n                            //no path mapping for a path starting with \'..\'.\r\n                            //This can still fail, but catches the most reasonable\r\n                            //uses of ..\r\n                            break;\r\n                        } else if (i > 0) {\r\n                            name.splice(i - 1, 2);\r\n                            i -= 2;\r\n                        }\r\n                    }\r\n                }\r\n                //end trimDots\r\n\r\n                name = name.join(\"/\");\r\n            } else if (name.indexOf(\'./\') === 0) {\r\n                // No baseName, so this is ID is resolved relative\r\n                // to baseUrl, pull off the leading dot.\r\n                name = name.substring(2);\r\n            }\r\n        }\r\n\r\n        //Apply map config if available.\r\n        if ((baseParts || starMap) && map) {\r\n            nameParts = name.split(\'/\');\r\n\r\n            for (i = nameParts.length; i > 0; i -= 1) {\r\n                nameSegment = nameParts.slice(0, i).join(\"/\");\r\n\r\n                if (baseParts) {\r\n                    //Find the longest baseName segment match in the config.\r\n                    //So, do joins on the biggest to smallest lengths of baseParts.\r\n                    for (j = baseParts.length; j > 0; j -= 1) {\r\n                        mapValue = map[baseParts.slice(0, j).join(\'/\')];\r\n\r\n                        //baseName segment has  config, find if it has one for\r\n                        //this name.\r\n                        if (mapValue) {\r\n                            mapValue = mapValue[nameSegment];\r\n                            if (mapValue) {\r\n                                //Match, update name to the new value.\r\n                                foundMap = mapValue;\r\n                                foundI = i;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (foundMap) {\r\n                    break;\r\n                }\r\n\r\n                //Check for a star map match, but just hold on to it,\r\n                //if there is a shorter segment match later in a matching\r\n                //config, then favor over this star map.\r\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\r\n                    foundStarMap = starMap[nameSegment];\r\n                    starI = i;\r\n                }\r\n            }\r\n\r\n            if (!foundMap && foundStarMap) {\r\n                foundMap = foundStarMap;\r\n                foundI = starI;\r\n            }\r\n\r\n            if (foundMap) {\r\n                nameParts.splice(0, foundI, foundMap);\r\n                name = nameParts.join(\'/\');\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    function makeRequire(relName, forceSync) {\r\n        return function () {\r\n            //A version of a require function that passes a moduleName\r\n            //value for items that may need to\r\n            //look up paths relative to the moduleName\r\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\r\n        };\r\n    }\r\n\r\n    function makeNormalize(relName) {\r\n        return function (name) {\r\n            return normalize(name, relName);\r\n        };\r\n    }\r\n\r\n    function makeLoad(depName) {\r\n        return function (value) {\r\n            defined[depName] = value;\r\n        };\r\n    }\r\n\r\n    function callDep(name) {\r\n        if (hasProp(waiting, name)) {\r\n            var args = waiting[name];\r\n            delete waiting[name];\r\n            defining[name] = true;\r\n            main.apply(undef, args);\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\r\n            throw new Error(\'No \' + name);\r\n        }\r\n        return defined[name];\r\n    }\r\n\r\n    //Turns a plugin!resource to [plugin, resource]\r\n    //with the plugin being undefined if the name\r\n    //did not have a plugin prefix.\r\n    function splitPrefix(name) {\r\n        var prefix,\r\n            index = name ? name.indexOf(\'!\') : -1;\r\n        if (index > -1) {\r\n            prefix = name.substring(0, index);\r\n            name = name.substring(index + 1, name.length);\r\n        }\r\n        return [prefix, name];\r\n    }\r\n\r\n    /**\r\n     * Makes a name map, normalizing the name, and using a plugin\r\n     * for normalization if necessary. Grabs a ref to plugin\r\n     * too, as an optimization.\r\n     */\r\n    makeMap = function (name, relName) {\r\n        var plugin,\r\n            parts = splitPrefix(name),\r\n            prefix = parts[0];\r\n\r\n        name = parts[1];\r\n\r\n        if (prefix) {\r\n            prefix = normalize(prefix, relName);\r\n            plugin = callDep(prefix);\r\n        }\r\n\r\n        //Normalize according\r\n        if (prefix) {\r\n            if (plugin && plugin.normalize) {\r\n                name = plugin.normalize(name, makeNormalize(relName));\r\n            } else {\r\n                name = normalize(name, relName);\r\n            }\r\n        } else {\r\n            name = normalize(name, relName);\r\n            parts = splitPrefix(name);\r\n            prefix = parts[0];\r\n            name = parts[1];\r\n            if (prefix) {\r\n                plugin = callDep(prefix);\r\n            }\r\n        }\r\n\r\n        //Using ridiculous property names for space reasons\r\n        return {\r\n            f: prefix ? prefix + \'!\' + name : name, //fullName\r\n            n: name,\r\n            pr: prefix,\r\n            p: plugin\r\n        };\r\n    };\r\n\r\n    function makeConfig(name) {\r\n        return function () {\r\n            return (config && config.config && config.config[name]) || {};\r\n        };\r\n    }\r\n\r\n    handlers = {\r\n        require: function (name) {\r\n            return makeRequire(name);\r\n        },\r\n        exports: function (name) {\r\n            var e = defined[name];\r\n            if (typeof e !== \'undefined\') {\r\n                return e;\r\n            } else {\r\n                return (defined[name] = {});\r\n            }\r\n        },\r\n        module: function (name) {\r\n            return {\r\n                id: name,\r\n                uri: \'\',\r\n                exports: defined[name],\r\n                config: makeConfig(name)\r\n            };\r\n        }\r\n    };\r\n\r\n    main = function (name, deps, callback, relName) {\r\n        var cjsModule, depName, ret, map, i,\r\n            args = [],\r\n            callbackType = typeof callback,\r\n            usingExports;\r\n\r\n        //Use name if no relName\r\n        relName = relName || name;\r\n\r\n        //Call the callback to define the module, if necessary.\r\n        if (callbackType === \'undefined\' || callbackType === \'function\') {\r\n            //Pull out the defined dependencies and pass the ordered\r\n            //values to the callback.\r\n            //Default to [require, exports, module] if no deps\r\n            deps = !deps.length && callback.length ? [\'require\', \'exports\', \'module\'] : deps;\r\n            for (i = 0; i < deps.length; i += 1) {\r\n                map = makeMap(deps[i], relName);\r\n                depName = map.f;\r\n\r\n                //Fast path CommonJS standard dependencies.\r\n                if (depName === \"require\") {\r\n                    args[i] = handlers.require(name);\r\n                } else if (depName === \"exports\") {\r\n                    //CommonJS module spec 1.1\r\n                    args[i] = handlers.exports(name);\r\n                    usingExports = true;\r\n                } else if (depName === \"module\") {\r\n                    //CommonJS module spec 1.1\r\n                    cjsModule = args[i] = handlers.module(name);\r\n                } else if (hasProp(defined, depName) ||\r\n                           hasProp(waiting, depName) ||\r\n                           hasProp(defining, depName)) {\r\n                    args[i] = callDep(depName);\r\n                } else if (map.p) {\r\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\r\n                    args[i] = defined[depName];\r\n                } else {\r\n                    throw new Error(name + \' missing \' + depName);\r\n                }\r\n            }\r\n\r\n            ret = callback ? callback.apply(defined[name], args) : undefined;\r\n\r\n            if (name) {\r\n                //If setting exports via \"module\" is in play,\r\n                //favor that over return value and exports. After that,\r\n                //favor a non-undefined return value over exports use.\r\n                if (cjsModule && cjsModule.exports !== undef &&\r\n                        cjsModule.exports !== defined[name]) {\r\n                    defined[name] = cjsModule.exports;\r\n                } else if (ret !== undef || !usingExports) {\r\n                    //Use the return value from the function.\r\n                    defined[name] = ret;\r\n                }\r\n            }\r\n        } else if (name) {\r\n            //May just be an object definition for the module. Only\r\n            //worry about defining if have a module name.\r\n            defined[name] = callback;\r\n        }\r\n    };\r\n\r\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\r\n        if (typeof deps === \"string\") {\r\n            if (handlers[deps]) {\r\n                //callback in this case is really relName\r\n                return handlers[deps](callback);\r\n            }\r\n            //Just return the module wanted. In this scenario, the\r\n            //deps arg is the module name, and second arg (if passed)\r\n            //is just the relName.\r\n            //Normalize module name, if it contains . or ..\r\n            return callDep(makeMap(deps, callback).f);\r\n        } else if (!deps.splice) {\r\n            //deps is a config object, not an array.\r\n            config = deps;\r\n            if (config.deps) {\r\n                req(config.deps, config.callback);\r\n            }\r\n            if (!callback) {\r\n                return;\r\n            }\r\n\r\n            if (callback.splice) {\r\n                //callback is an array, which means it is a dependency list.\r\n                //Adjust args if there are dependencies\r\n                deps = callback;\r\n                callback = relName;\r\n                relName = null;\r\n            } else {\r\n                deps = undef;\r\n            }\r\n        }\r\n\r\n        //Support require([\'a\'])\r\n        callback = callback || function () {};\r\n\r\n        //If relName is a function, it is an errback handler,\r\n        //so remove it.\r\n        if (typeof relName === \'function\') {\r\n            relName = forceSync;\r\n            forceSync = alt;\r\n        }\r\n\r\n        //Simulate async callback;\r\n        if (forceSync) {\r\n            main(undef, deps, callback, relName);\r\n        } else {\r\n            //Using a non-zero value because of concern for what old browsers\r\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\r\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\r\n            //If want a value immediately, use require(\'id\') instead -- something\r\n            //that works in almond on the global level, but not guaranteed and\r\n            //unlikely to work in other AMD implementations.\r\n            setTimeout(function () {\r\n                main(undef, deps, callback, relName);\r\n            }, 4);\r\n        }\r\n\r\n        return req;\r\n    };\r\n\r\n    /**\r\n     * Just drops the config on the floor, but returns req in case\r\n     * the config return value is used.\r\n     */\r\n    req.config = function (cfg) {\r\n        return req(cfg);\r\n    };\r\n\r\n    /**\r\n     * Expose module registry for debugging and tooling\r\n     */\r\n    requirejs._defined = defined;\r\n\r\n    define = function (name, deps, callback) {\r\n\r\n        //This module may not have dependencies\r\n        if (!deps.splice) {\r\n            //deps is not an array, so probably means\r\n            //an object literal or factory function for\r\n            //the value. Adjust args.\r\n            callback = deps;\r\n            deps = [];\r\n        }\r\n\r\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\r\n            waiting[name] = [name, deps, callback];\r\n        }\r\n    };\r\n\r\n    define.amd = {\r\n        jQuery: true\r\n    };\r\n}());\r\n\n//# sourceURL=/../vendor/almond.js");

define("../vendor/almond", function(){});

eval("define(\'unsafeWindow\',[], function(){\r\n  return window;\r\n});\n//# sourceURL=/unsafeWindow.js");

eval("/**\r\n* A helper class to help checking for features that are supported by the browser.\r\n* @namespace helper\r\n* @class Support\r\n**/\r\ndefine(\'helper/support\',[\"exports\", \"unsafeWindow\"], function(exports, uw){\r\n  /**\r\n  * Performing a simple LocalStorage set, get test.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @method localStorageTest\r\n  * @return {Boolean} Returns true if LocalStorage is supported otherwise returns false.\r\n  **/\r\n  function localStorageTest() {\r\n    var mod = \"support.test\";\r\n    try {\r\n      localStorage.setItem(mod, mod);\r\n      localStorage.removeItem(mod);\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Checking if `webkitURL` is an object.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isWebkitURL\r\n  * @type Boolean\r\n  **/\r\n  var isWebkitURL = typeof uw.webkitURL === \"object\";\r\n  \r\n  /**\r\n  * Checking if `URL` is an object.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isURL\r\n  * @type Boolean\r\n  **/\r\n  var isURL = typeof uw.URL === \"object\";\r\n  \r\n  /**\r\n  * Checking if Maxthon runtime is accessible.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property maxthonRuntime\r\n  * @type Boolean\r\n  **/\r\n  var maxthonRuntime = window && window.external && window.external.mxGetRuntime && typeof window.external.mxGetRuntime === \"function\";\r\n  \r\n  /**\r\n  * Checking if `createObjectURL` is supported.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isCreateObjectURL\r\n  * @type Boolean\r\n  **/\r\n  var isCreateObjectURL = false;\r\n  \r\n  /**\r\n  * Checking if `revokeObjectURL` is supported.\r\n  *\r\n  * @private\r\n  * @static\r\n  * @property isRevokeObjectURL\r\n  * @type Boolean\r\n  **/\r\n  var isRevokeObjectURL = false;\r\n  if (isWebkitURL) {\r\n    isCreateObjectURL = typeof uw.webkitURL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.webkitURL.revokeObjectURL === \"function\";\r\n  } else if (isURL) {\r\n    isCreateObjectURL = typeof uw.URL.createObjectURL === \"function\";\r\n    isRevokeObjectURL = typeof uw.URL.revokeObjectURL === \"function\";\r\n  }\r\n  \r\n  /**\r\n  * Checking if LocalStorage is supported.\r\n  *\r\n  * @static\r\n  * @property localStorage\r\n  * @type Boolean\r\n  **/\r\n  exports.localStorage = localStorageTest();\r\n  \r\n  /**\r\n  * Checking if the Greasemonkey API is supported.\r\n  *\r\n  * @static\r\n  * @property Greasemonkey\r\n  * @type Boolean\r\n  **/\r\n  exports.Greasemonkey = (typeof GM_setValue !== \"undefined\" && (typeof GM_setValue.toString === \"undefined\" || GM_setValue.toString().indexOf(\"not supported\") === -1));\r\n  \r\n  /**\r\n  * Checking if `createObjectUR` is supported.\r\n  *\r\n  * @static\r\n  * @property createObjectURL\r\n  * @type Boolean\r\n  **/\r\n  exports.createObjectURL = isCreateObjectURL;\r\n  \r\n  /**\r\n  * Checking if `revokeObjectURL` is supported.\r\n  *\r\n  * @static\r\n  * @property revokeObjectURL\r\n  * @type Boolean\r\n  **/\r\n  exports.revokeObjectURL = isRevokeObjectURL;\r\n  \r\n  /**\r\n  * Checking if the `webkitURL` object is supported.\r\n  *\r\n  * @static\r\n  * @property webkitURL\r\n  * @type Boolean\r\n  **/\r\n  exports.webkitURL = isWebkitURL;\r\n  \r\n  /**\r\n  * Checking if the `URL` object is supported.\r\n  *\r\n  * @static\r\n  * @property URL\r\n  * @type Boolean\r\n  **/\r\n  exports.URL = isURL;\r\n  \r\n  /**\r\n  * Checking if Maxthon runtime is supported.\r\n  *\r\n  * @static\r\n  * @property maxthonRuntime\r\n  * @type Boolean\r\n  **/\r\n  exports.maxthonRuntime = maxthonRuntime;\r\n  \r\n  /**\r\n  * Checking if Maxthon runtime Storage object is supported.\r\n  *\r\n  * @static\r\n  * @property maxthonRuntimeStorage\r\n  * @type Boolean\r\n  **/\r\n  exports.maxthonRuntimeStorage = maxthonRuntime && window.external.mxGetRuntime() && window.external.mxGetRuntime().storage;\r\n  \r\n  /**\r\n  * Checking if Firefox extension port is accessible.\r\n  *\r\n  * @static\r\n  * @property firefoxPort\r\n  * @type Boolean\r\n  **/\r\n  exports.firefoxPort = this.port && typeof this.port.request === \"function\" && this.port.storage && typeof this.port.on === \"function\";\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/helper/support.js");

eval("/**\r\n* @class Utils\r\n**/\r\ndefine(\'utils\',[\"exports\", \"./helper/support\", \"unsafeWindow\"], function(exports, support, uw){\r\n  function each(obj, callback) {\r\n    if (isArray(obj)) {\r\n      for (var i = 0; i < obj.length; i++) {\r\n        if (callback(i, obj[i]) === true) break;\r\n      }\r\n    } else {\r\n      for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          if (callback(key, obj[key]) === true) break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n  }\r\n  \r\n  function asyncCall(scope, callback) {\r\n    return setTimeout(bind.apply(null, [scope, callback].concat(Array.prototype.slice.call(arguments, 2))), 0);\r\n  }\r\n  \r\n  function bind(scope, func) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    return function(){\r\n      return func.apply(scope, args.concat(Array.prototype.slice.call(arguments)))\r\n    };\r\n  }\r\n  \r\n  function trimLeft(obj){\r\n    return obj.replace(/^\\s+/, \"\");\r\n  }\r\n  \r\n  function trimRight(obj){\r\n    return obj.replace(/\\s+$/, \"\");\r\n  }\r\n  \r\n  function map(obj, callback, thisArg) {\r\n    for (var i = 0, n = obj.length, a = []; i < n; i++) {\r\n      if (i in obj) a[i] = callback.call(thisArg, obj[i]);\r\n    }\r\n    return a;\r\n  }\r\n  \r\n  /**\r\n  * Define a property with a getter and a setter.\r\n  *\r\n  * @method defineProperty\r\n  * @param {Object} obj The object where the property resides in.\r\n  * @param {String} key The name of the property.\r\n  * @param {Function} get The getter function.\r\n  * @param {Function} set The setter function.\r\n  **/\r\n  function defineProperty(obj, key, get, set) {\r\n    if (Object && typeof Object.defineProperty === \"function\") {\r\n      Object.defineProperty(obj, key, {\r\n        \"get\": get,\r\n        \"set\": set\r\n      });\r\n    } else {\r\n      obj.__defineGetter__(key, get);\r\n      obj.__defineSetter__(key, set);\r\n    }\r\n  }\r\n  \r\n  function defineLockedProperty(obj, key, setter, getter) {\r\n    if (typeof obj !== \"object\") obj = {};\r\n    if (support.ie || typeof Object.defineProperty === \"function\") {\r\n      Object.defineProperty(obj, key, {\r\n        get: getter,\r\n        set: setter\r\n      });\r\n      return obj;\r\n    } else {\r\n      obj.__defineGetter__(key, getter);\r\n      obj.__defineSetter__(key, setter);\r\n      return obj;\r\n    }\r\n  }\r\n  \r\n  function addEventListener(elm, event, callback, useCapture) {\r\n    if (elm.addEventListener) {\r\n      elm.addEventListener(event, callback, useCapture || false);\r\n    } else if (elm.attachEvent) {\r\n      elm.attachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  function removeEventListener(elm, event, callback, useCapture) {\r\n    if (elm.removeEventListener) {\r\n      elm.removeEventListener(event, callback, useCapture || false);\r\n    } else if (elm.detachEvent) {\r\n      elm.detachEvent(\"on\" + event, callback);\r\n    }\r\n  }\r\n  \r\n  var now = Date.now || function () {\r\n    return +new Date;\r\n  };\r\n  \r\n  /* Cookies */\r\n  function setCookie(name, value, domain, path, expires) {\r\n    domain = domain ? \";domain=\" + encodeURIComponent(domain) : \"\";\r\n    path = path ? \";path=\" + encodeURIComponent(path) : \"\";\r\n    expires = 0 > expires ? \"\" : 0 == expires ? \";expires=\" + (new Date(1970, 1, 1)).toUTCString() : \";expires=\" + (new Date(now() + 1E3 * expires)).toUTCString();\r\n    \r\n    document.cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value) + domain + path + expires;\r\n  }\r\n  \r\n  function getCookie(key) {\r\n    return getCookies()[key];\r\n  }\r\n  \r\n  function getCookies() {\r\n    var c = document.cookie, v = 0, cookies = {};\r\n    if (document.cookie.match(/^\\s*\\$Version=(?:\"1\"|1);\\s*(.*)/)) {\r\n      c = RegExp.$1;\r\n      v = 1;\r\n    }\r\n    if (v === 0) {\r\n      map(c.split(/[,;]/), function(cookie) {\r\n        var parts = cookie.split(/=/, 2),\r\n            name = decodeURIComponent(trimLeft(parts[0])),\r\n            value = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;\r\n        cookies[name] = value;\r\n      });\r\n    } else {\r\n      map(c.match(/(?:^|\\s+)([!#$%&\'*+\\-.0-9A-Z^`a-z|~]+)=([!#$%&\'*+\\-.0-9A-Z^`a-z|~]*|\"(?:[\\x20-\\x7E\\x80\\xFF]|\\\\[\\x00-\\x7F])*\")(?=\\s*[,;]|$)/g), function($0, $1) {\r\n        var name = $0, value = $1.charAt(0) === \'\"\' ? $1.substr(1, -1).replace(/\\\\(.)/g, \"$1\") : $1;\r\n        cookies[name] = value;\r\n      });\r\n    }\r\n    return cookies;\r\n  }\r\n  \r\n  function endsWith(str, suffix) {\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n  }\r\n  \r\n  function inject(func) {\r\n    var script = document.createElement(\"script\"),\r\n        p = (document.body || document.head || document.documentElement);\r\n    if (!p) {\r\n      throw \"Could not inject!!!\";\r\n    }\r\n    script.setAttribute(\"type\", \"text/javascript\");\r\n    script.appendChild(document.createTextNode(\"(\" + func + \")(\" + buildArgumentList.apply(null, [false].concat(Array.prototype.slice.call(arguments, 1))) + \");\"));\r\n    p.appendChild(script);\r\n    p.removeChild(script);\r\n  }\r\n  \r\n  function buildArgumentList(wrap) {\r\n    var list = [];\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    \r\n    for (var i = 0, len = args.length; i < len; i++) {\r\n      if (typeof args[i] === \"string\") {\r\n        list.push(\"\\\"\" + args[i].replace(/\\\\/, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\");\r\n      } else if (typeof args[i] === \"object\") {\r\n        list.push(JSON.stringify(args[i]));\r\n      } else if (typeof args[i] === \"undefined\") {\r\n        list.push(\"null\");\r\n      } else {\r\n        list.push(args[i]);\r\n      }\r\n    }\r\n    if (wrap) {\r\n      return \"(\" + list.join(\",\") + \")\";\r\n    } else {\r\n      return list.join(\",\");\r\n    }\r\n  }\r\n  \r\n  function isJSONString(json) {\r\n    try {\r\n      JSON.parse(json);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function xhr(details) {\r\n    var xmlhttp;\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new XMLHttpRequest();\r\n    } else if (typeof opera !== \"undefined\" && typeof opera.XMLHttpRequest !== \"undefined\") {\r\n      xmlhttp = new opera.XMLHttpRequest();\r\n    } else {\r\n      if (details[\"onerror\"]) {\r\n        details[\"onerror\"]();\r\n      }\r\n      \r\n      return;\r\n    }\r\n    xmlhttp.onreadystatechange = function(){\r\n      var responseState = {\r\n        responseXML:(xmlhttp.readyState == 4 ? xmlhttp.responseXML : \'\'),\r\n        responseText:(xmlhttp.readyState == 4 ? xmlhttp.responseText : \'\'),\r\n        readyState:xmlhttp.readyState,\r\n        responseHeaders:(xmlhttp.readyState == 4 ? xmlhttp.getAllResponseHeaders() : \'\'),\r\n        status:(xmlhttp.readyState == 4 ? xmlhttp.status : 0),\r\n        statusText:(xmlhttp.readyState == 4 ? xmlhttp.statusText : \'\'),\r\n        finalUrl:(xmlhttp.readyState == 4 ? xmlhttp.finalUrl : \'\')\r\n      };\r\n      if (details[\"onreadystatechange\"]) {\r\n        details[\"onreadystatechange\"](responseState);\r\n      }\r\n      if (xmlhttp.readyState == 4) {\r\n        if (details[\"onload\"] && xmlhttp.status >= 200 && xmlhttp.status < 300) {\r\n          details[\"onload\"](responseState);\r\n        }\r\n        if (details[\"onerror\"] && (xmlhttp.status < 200 || xmlhttp.status >= 300)) {\r\n          details[\"onerror\"](responseState);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      xmlhttp.open(details.method, details.url);\r\n    } catch(e) {\r\n      if(details[\"onerror\"]) {\r\n        details[\"onerror\"]({responseXML:\'\',responseText:\'\',readyState:4,responseHeaders:\'\',status:403,statusText:\'Forbidden\'});\r\n      }\r\n      return;\r\n    }\r\n    if (details.headers) {\r\n      for (var prop in details.headers) {\r\n        xmlhttp.setRequestHeader(prop, details.headers[prop]);\r\n      }\r\n    }\r\n    xmlhttp.send((typeof(details.data) != \'undefined\') ? details.data : null);\r\n  }\r\n  \r\n  // Used for the message module (should probably move to another place)\r\n  // It replaces a property in the obj to a predefined function, where the arguments will be callbackId, target, referer\r\n  function bindFunctionCallbacks(obj, func, target, referer) {\r\n    for (key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"obj\") {\r\n          bindFunctionCallbacks(obj[key]);\r\n        } else if (typeof obj[key] === \"string\") {\r\n          if (obj[key].indexOf(\"@/(message.callback)/\") === 0) {\r\n            var callbackId = obj[key].split(\"@/(message.callback)/\")[1];\r\n            obj[key] = bind(null, func, callbackId, target, referer);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function extend(obj, defaults, deep) {\r\n    if (typeof obj !== \"object\") throw new TypeError(\"Unsupported type for obj.\");\r\n    if (typeof defaults !== \"object\") throw new TypeError(\"Unsupported type for defaults.\");\r\n    \r\n    for (var key in defaults) {\r\n      if (defaults.hasOwnProperty(key)) {\r\n        if (typeof obj[key] === \"object\" && typeof defaults[key] === \"object\" && deep) {\r\n          extend(obj[key], defaults[key], deep);\r\n        } else if (!obj.hasOwnProperty(key)) {\r\n          obj[key] = defaults[key];\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function inArray(key, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === key) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function listClasses(el) {\r\n    if (!el || !el.className) return [];\r\n    return el.className.split(\" \");\r\n  }\r\n  \r\n  function addClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var addList = className.split(\" \");\r\n    \r\n    for (var i = 0, len = addList.length; i < len; i++) {\r\n      if (!inArray(addList[i], classes)) {\r\n        el.className += \" \" + addList[i];\r\n      }\r\n    }\r\n    return el.className;\r\n  }\r\n  \r\n  function removeClass(el, className) {\r\n    var classes = listClasses(el);\r\n    var removeList = className.split(\" \");\r\n    \r\n    var buffer = [];\r\n    for (var i = 0, len = classes.length; i < len; i++) {\r\n      if (!inArray(classes[i], removeList)) {\r\n        buffer.push(classes[i]);\r\n      }\r\n    }\r\n    return el.className = buffer.join(\" \");\r\n  }\r\n  \r\n  function hasClass(el, className) {\r\n    return inArray(className, listClasses(el));\r\n  }\r\n  \r\n  function throttle(func, delay, options){\r\n    function timeout() {\r\n      previous = options.leading === false ? 0 : new Date;\r\n      timer = null;\r\n      result = func.apply(context, args);\r\n    }\r\n    var context, args, result, timer = null, previous = 0;\r\n    options = options || {};\r\n    return function(){\r\n      var now = new Date, dt;\r\n      \r\n      context = this;\r\n      args = arguments;\r\n      \r\n      if (!previous && options.leading === false) previous = now;\r\n      dt = delay - (now - previous);\r\n      \r\n      if (dt <= 0) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n        previous = now;\r\n        result = func.apply(context, args);\r\n      } else if (!timer && options.trailing !== false) {\r\n        timer = setTimeout(timeout, dt);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n  \r\n  function clone(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n  \r\n  function removeDuplicates(arr) {\r\n    var uniqueArr = [];\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (!inArray(uniqueArr, arr[i])) {\r\n        uniqueArr.push(arr[i]);\r\n      }\r\n    }\r\n    \r\n    return uniqueArr;\r\n  }\r\n  \r\n  function escapeRegExp(str) {\r\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n  }\r\n  \r\n  function toBlob(bytes, contentType) {\r\n    contentType = contentType || \"text/plain\";\r\n    var sliceSize = 512;\r\n    \r\n    var bytesLength = bytes.length;\r\n    var slicesCount = Math.ceil(bytesLength / sliceSize);\r\n    \r\n    var byteArrays = new Array(slicesCount);\r\n    \r\n    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\r\n      var begin = sliceIndex * sliceSize;\r\n      var end = Math.min(begin + sliceSize, bytesLength);\r\n      \r\n      var sliceBytes = new Array(end - begin);\r\n      for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {\r\n        sliceBytes[i] = bytes[offset].charCodeAt(0);\r\n      }\r\n      byteArrays[sliceIndex] = new Uint8Array(sliceBytes);\r\n    }\r\n    \r\n    return new Blob(byteArrays, { type: contentType });\r\n  }\r\n  \r\n  function createObjectURL(blob) {\r\n    if (support.createObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.createObjectURL(blob);\r\n      } else {\r\n        return uw.URL.createObjectURL(blob);\r\n      }\r\n    } else {\r\n      throw \"createObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  function revokeObjectURL(url) {\r\n    if (support.revokeObjectURL) {\r\n      if (support.webkitURL) {\r\n        return uw.webkitURL.revokeObjectURL(url);\r\n      } else {\r\n        return uw.URL.revokeObjectURL(url);\r\n      }\r\n    } else {\r\n      throw \"revokeObjectURL is not supported by the browser!\";\r\n    }\r\n  }\r\n  \r\n  // Returns a random number between min and max\r\n  function getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n  \r\n  // Returns a random integer between min (included) and max (excluded)\r\n  function getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n  \r\n  // Returns a random string of characters of chars with the length of length\r\n  function generateToken(chars, length) {\r\n    if (typeof chars !== \"string\") chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\";\r\n    if (typeof length !== \"number\") length = 64;\r\n    \r\n    var charsLength = chars.length;\r\n    \r\n    var token = \"\";\r\n    for (var i = 0; i < length; i++) {\r\n      token += chars[getRandomInt(0, charsLength)];\r\n    }\r\n    \r\n    return token;\r\n  }\r\n  \r\n  function escapeECMAVariable(key, defaultKey) {\r\n    key = key.replace(/[^0-9a-zA-Z_\\$]/g, \"\");\r\n    while (/$[0-9]/g.test(key) && key.length > 0) {\r\n      if (key === \"\") return defaultKey;\r\n      key = key.substring(1);\r\n    }\r\n    return key;\r\n  }\r\n  \r\n  function indexOfArray(value, arr) {\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n      if (arr[i] === value) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n  \r\n  function getKeys(obj) {\r\n    var keys = [];\r\n    each(obj, function(key){\r\n      keys.push(key);\r\n    });\r\n    return keys;\r\n  }\r\n  \r\n  function setProperty(target, path, value, createPath) {\r\n    var tokens = path.split(\".\");\r\n    for (var i = 0, len = tokens.length - 1; i < len; i++) {\r\n      if (target[tokens[i]]) {\r\n        target = target[tokens[i]];\r\n      } else {\r\n        if (createPath) {\r\n          target[tokens[i]] = {};\r\n          target = target[tokens[i]];\r\n        } else {\r\n          throw \"Path \" + path + \" does not exist for\", target;\r\n        }\r\n      }\r\n    }\r\n    target[tokens[tokens.length - 1]] = value;\r\n  }\r\n  \r\n  /**\r\n  * Replaces each format item in a specified string with the text equivalent of a corresponding object\'s value.\r\n  *\r\n  * @static\r\n  * @method format\r\n  * @param {String} format A composite format string that includes one or more format items.\r\n  * @param {any} [args]* The object to format.\r\n  * @return {String} The string with each format item inserted.\r\n  **/\r\n  /**\r\n  * Replaces each token in a specified string with the text equivalent of a corresponding key\'s value.\r\n  *\r\n  * @static\r\n  * @method format\r\n  * @param {String} format A composite format string that includes one or more token items.\r\n  * @param {Object} map The key, value pairs that will be replacing the tokens.\r\n  * @return {String} The formatted string.\r\n  **/\r\n  function format(format) {\r\n    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\r\n      var map = arguments[1];\r\n      return format.replace(/\\${([\\w\\-\\_]+)}/g, function(match, key) { \r\n        return typeof map[key] !== \"undefined\" ? map[key] : match;\r\n      });\r\n    } else {\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      return format.replace(/{(\\d+)}/g, function(match, index) { \r\n        return typeof args[index] !== \"undefined\" ? args[index] : match;\r\n      });\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Calculate the absolute position of an element.\r\n  *\r\n  * @static\r\n  * @method getAbsolutePosition\r\n  * @param {HTMLElement} el The element.\r\n  * @return {Object} An object with the properties left and top\r\n  *                  where top and left tell the position of the\r\n  *                  element from the top-left corner in pixels.\r\n  **/\r\n  function getAbsolutePosition(el) {\r\n    var left = el.offsetLeft || 0;\r\n    var top = el.offsetTop || 0;\r\n    \r\n    if (el.offsetParent) {\r\n      var parentAbsolutePosition = getAbsolutePosition(el.offsetParent);\r\n      left += parentAbsolutePosition.left;\r\n      top += parentAbsolutePosition.top;\r\n    }\r\n    \r\n    return { left: left, top: top }; \r\n  }\r\n  \r\n  // Expose functions\r\n  exports.getAbsolutePosition = getAbsolutePosition;\r\n  exports.format = format;\r\n  exports.hasClass = hasClass;\r\n  exports.removeClass = removeClass;\r\n  exports.addClass = addClass;\r\n  exports.each = each;\r\n  exports.isArray = isArray;\r\n  exports.inArray = inArray;\r\n  exports.bind = bind;\r\n  exports.asyncCall = asyncCall;\r\n  exports.defineLockedProperty = defineLockedProperty;\r\n  exports.addEventListener = addEventListener;\r\n  exports.removeEventListener = removeEventListener;\r\n  exports.now = now;\r\n  exports.trimLeft = trimLeft;\r\n  exports.trimRight = trimRight;\r\n  exports.map = map;\r\n  exports.setCookie = setCookie;\r\n  exports.getCookie = getCookie;\r\n  exports.getCookies = getCookies;\r\n  exports.endsWith = endsWith;\r\n  exports.inject = inject;\r\n  exports.isJSONString = isJSONString;\r\n  exports.xhr = xhr;\r\n  exports.buildArgumentList = buildArgumentList;\r\n  exports.bindFunctionCallbacks = bindFunctionCallbacks;\r\n  exports.extend = extend;\r\n  exports.throttle = throttle;\r\n  exports.clone = clone;\r\n  exports.removeDuplicates = removeDuplicates;\r\n  exports.escapeRegExp = escapeRegExp;\r\n  exports.toBlob = toBlob;\r\n  exports.createObjectURL = createObjectURL;\r\n  exports.revokeObjectURL = revokeObjectURL;\r\n  exports.getRandomArbitrary = getRandomArbitrary;\r\n  exports.getRandomInt = getRandomInt;\r\n  exports.generateToken = generateToken;\r\n  exports.escapeECMAVariable = escapeECMAVariable;\r\n  exports.indexOfArray = indexOfArray;\r\n  exports.getKeys = getKeys;\r\n  exports.setProperty = setProperty;\r\n  exports.defineProperty = defineProperty;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/utils.js");

eval("define(\'storage/localStorage\',[\"utils\"], function(utils){\r\n  function getItem(key, callback, preferSync) {\r\n    var item = localStorage.getItem(key);\r\n    if (preferSync) {\r\n      callback(item);\r\n    } else {\r\n      utils.asyncCall(null, callback, item);\r\n    }\r\n  }\r\n  \r\n  return {\r\n    setItem: utils.bind(localStorage, localStorage.setItem),\r\n    getItem: getItem,\r\n    removeItem: utils.bind(localStorage, localStorage.removeItem)\r\n  };\r\n});\n//# sourceURL=/storage/localStorage.js");

eval("define(\'storage/cookies\',[\"utils\"], function(utils){\r\n  function setItem(key, value) {\r\n    utils.setCookie(prefix + key, value, null, \"/\", 1000*24*60*60*1000);\r\n  }\r\n  \r\n  function getItem(key, callback, preferSync) {\r\n    var item = utils.getCookie(prefix + key);\r\n    if (preferSync) {\r\n      callback(item);\r\n    } else {\r\n      utils.asyncCall(null, callback, item);\r\n    }\r\n  }\r\n  \r\n  function removeItem(key) {\r\n    utils.setCookie(prefix + key, \"\", null, \"/\", 0);\r\n  }\r\n  \r\n  var prefix = \"ytcenter.\";\r\n  \r\n  return {\r\n    setItem: setItem,\r\n    getItem: getItem,\r\n    removeItem: removeItem\r\n  };\r\n});\n//# sourceURL=/storage/cookies.js");

eval("define(\'console\',[\"exports\", \"utils\"], function(exports, utils){\r\n  function setEnabled(b) {\r\n    enabled = b;\r\n  }\r\n  \r\n  function log() {\r\n    if (!enabled) return function(){};\r\n    return console.log.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function error() {\r\n    if (!enabled) return function(){};\r\n    return console.error.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function warn() {\r\n    if (!enabled) return function(){};\r\n    return console.warn.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  function debug() {\r\n    if (!enabled) return function(){};\r\n    return console.debug.bind(console, \"userscript[\" + sessionToken + \"]\");\r\n  }\r\n  \r\n  var sessionToken = (typeof consoleSessionToken === \"string\" ? consoleSessionToken : utils.generateToken(null, 8));\r\n  \r\n  var enabled = true;\r\n  \r\n  exports.sessionToken = sessionToken;\r\n  \r\n  utils.defineLockedProperty(exports, \"log\", function(){}, log);\r\n  utils.defineLockedProperty(exports, \"error\", function(){}, error);\r\n  utils.defineLockedProperty(exports, \"warn\", function(){}, warn);\r\n  utils.defineLockedProperty(exports, \"debug\", function(){}, debug);\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/console.js");

eval("define(\'storage/browser\',[\"../helper/support\", \"./localStorage\", \"./cookies\", \"console\"], function(support, localStorage, cookies){\r\n  if (support.localStorage) {\r\n    return localStorage;\r\n  } else {\r\n    return cookies;\r\n  }\r\n});\n//# sourceURL=/storage/browser.js");

eval("define(\'storage/userscript\',[\"../helper/support\", \"./browser\", \"../utils\"], function(support, browser, utils){\r\n  function setItem(key, value) {\r\n    GM_setValue(key, value);\r\n  }\r\n  \r\n  function getItem(key, callback, preferSync) {\r\n    var item = GM_getValue(key);\r\n    if (preferSync) {\r\n      callback(item);\r\n    } else {\r\n      utils.asyncCall(null, callback, item);\r\n    }\r\n  }\r\n  \r\n  function removeItem(key) {\r\n    GM_deleteValue(key);\r\n  }\r\n  \r\n  if (support.Greasemonkey) {\r\n    return {\r\n      setItem: setItem,\r\n      removeItem: removeItem,\r\n      getItem: getItem\r\n    };\r\n  } else {\r\n    return browser;\r\n  }\r\n});\n//# sourceURL=/storage/userscript.js");

eval("define(\'storage\',[\"exports\", \"storage/userscript\", \"utils\"], function(exports, storageHandler, utils){\r\n  function setItem(key, value) {\r\n    cache[key] = value;\r\n    storageHandler.setItem(key, value);\r\n  }\r\n  \r\n  function removeItem(key) {\r\n    delete cache[key];\r\n    storageHandler.removeItem(key);\r\n  }\r\n  \r\n  function getItemCallback(callback, key, value) {\r\n    cache[key] = value;\r\n    callback(cache[key]);\r\n  }\r\n  \r\n  function getItem(key, callback, sync) {\r\n    if (!(key in cache)) {\r\n      storageHandler.getItem(key, utils.bind(null, getItemCallback, callback, key));\r\n    } else {\r\n      if (sync) {\r\n        callback(cache[key]);\r\n        return cache[key];\r\n      } else {\r\n        utils.asyncCall(null, callback, cache[key]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  var cache = {};\r\n  \r\n  /* Exports */\r\n  exports.setItem = setItem;\r\n  exports.removeItem = removeItem;\r\n  exports.getItem = getItem;\r\n  \r\n  return exports;\r\n});\n//# sourceURL=/storage.js");

eval("define(\'UserProxy/CustomEvent\',[\"utils\"], function(utils){\r\n  function addEventListener(event, listener) {\r\n    if (!events[event]) {\r\n      // Creating the array of listeners for event\r\n      events[event] = [];\r\n      \r\n      docListeners[event] = utils.bind(null, eventListener, event, events[event]);\r\n      \r\n      // Adding the event listener.\r\n      window.addEventListener(event, docListeners[event], false);\r\n    }\r\n    \r\n    // Adding listener to array.\r\n    events[event].push(listener);\r\n  }\r\n  \r\n  function removeEventListener(event, listener) {\r\n    if (event in events) {\r\n      for (var i = 0, len = events[event].length; i < len; i++) {\r\n        if (events[event][i] === listener) {\r\n          events[event].splice(i, 1);\r\n          i--; len--;\r\n        }\r\n      }\r\n      if (events[event].length === 0) {\r\n        window.removeEventListener(event, docListeners[event], false);\r\n        \r\n        events[event] = null;\r\n        docListeners[event] = null;\r\n      }\r\n    }\r\n  }\r\n  \r\n  function eventListener(event, listeners, e) {\r\n    e = e || window.event;\r\n    \r\n    // Parse the detail to the original object.\r\n    var data = JSON.parse(e.detail);\r\n    \r\n    if (typeof data.detail === \"object\" && data.token !== token) {\r\n      var detail = data.detail;\r\n      for (var i = 0, len = listeners.length; i < len; i++) {\r\n        // Call the listener with the event name and the parsed detail.\r\n        listeners[i](detail);\r\n      }\r\n      \r\n      // Prevent propagation\r\n      if (e && typeof e.stopPropagation === \"function\") {\r\n        e.stopPropagation();\r\n      }\r\n    }\r\n  }\r\n  \r\n  function fireEvent(event, detail) {\r\n    // Creating the event\r\n    var e = document.createEvent(\"CustomEvent\");\r\n    e.initCustomEvent(event, true, true, JSON.stringify({ detail: detail, token: token }));\r\n    \r\n    // Firing the event\r\n    document.documentElement.dispatchEvent(e);\r\n  }\r\n  \r\n  var token = utils.generateToken(); // The token is used to identify itself and prevent calling its own listeners.\r\n  var events = {};\r\n  var docListeners = {};\r\n  \r\n  return {\r\n    addEventListener: addEventListener,\r\n    removeEventListener: removeEventListener,\r\n    fireEvent: fireEvent\r\n  };\r\n});\n//# sourceURL=/UserProxy/CustomEvent.js");

eval("define(\'UserProxy/Message\',[\"utils\"], function(utils){\r\n  function addEventListener(event, listener) {\r\n    initMessage(); // Init the message event listener if not already initialized.\r\n    \r\n    if (!events[event]) events[event] = [];\r\n    \r\n    // Bind the event name to the listener as an argument.\r\n    var boundListener = utils.bind(null, listener, event);\r\n    \r\n    // Add the boundListener to the event\r\n    events[event].push(boundListener);\r\n  }\r\n  \r\n  function fireEvent(event, detail) {\r\n    window.postMessage(JSON.stringify({ token: token, event: event, detail: detail }), \"*\");\r\n  }\r\n  \r\n  function messageListener(e) {\r\n    e = e || window.event;\r\n    \r\n    // Parse the detail to the original object.\r\n    var data = JSON.parse(e.data);\r\n    \r\n    // Verify that the retrieved information is correct and that it didn\'t call itself.\r\n    if (typeof data.event === \"string\" && typeof data.detail === \"object\" && data.token !== token) {\r\n      \r\n      // Iterate through every listener for data.event.\r\n      if (utils.isArray(events[data.event])) {\r\n        var listeners = events[data.event];\r\n        \r\n        var detail = data.detail;\r\n        for (var i = 0, len = listeners.length; i < len; i++) {\r\n          listeners(detail);\r\n        }\r\n    \r\n        // Prevent propagation only if everything went well.\r\n        if (e && typeof e.stopPropagation === \"function\") {\r\n          e.stopPropagation();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function initMessage() {\r\n    if (!messageEventAdded) {\r\n      // Adding the message event listener.\r\n      window.addEventListener(\"message\", messageListener, false);\r\n    }\r\n  }\r\n  \r\n  var messageEventAdded = false;\r\n  var token = utils.generateToken(); // The token is used to identify itself and prevent calling its own listeners.\r\n  \r\n  var events = {};\r\n  \r\n  return {\r\n    addEventListener: addEventListener,\r\n    fireEvent: fireEvent\r\n  };\r\n});\n//# sourceURL=/UserProxy/Message.js");

eval("define(\'UserProxy/support\',[], function(){\r\n  function customEvent() {\r\n    try {\r\n      var e = document.createEvent(\'CustomEvent\');\r\n      if (e && typeof e.initCustomEvent === \"function\") {\r\n        e.initCustomEvent(mod, true, true, { mod: mod });\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  var mod = \"support.test\";\r\n  \r\n  return {\r\n    CustomEvent: customEvent\r\n  };\r\n});\n//# sourceURL=/UserProxy/support.js");

eval("define(\'UserProxy/memFunction\',[\"utils\", \"./CustomEvent\", \"./Message\", \"./support\"], function(utils, customEvent, message, support){\r\n  function parseObject(obj, token, type) {\r\n    if (typeof obj === \"object\") {\r\n      utils.each(obj, function(key, value){\r\n        if (typeof value === \"object\") {\r\n          obj[key] = parseObject(value, token, type);\r\n        } else if (typeof value === \"string\") {\r\n          obj[key] = parseString(value);\r\n        } else if (typeof value === \"function\") {\r\n          var id = cache.push(value) - 1;\r\n          obj[key] = \"${\" + token + \"/\" + type + \"/\" + id + \"}\";\r\n        }\r\n      });\r\n    } else if (typeof value === \"string\") {\r\n      obj = parseString(obj);\r\n    } else if (typeof obj === \"function\") {\r\n      var id = cache.push(obj) - 1;\r\n      obj = \"${\" + token + \"/\" + type + \"/\" + id + \"}\";\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function parseString(str) {\r\n    if (/^\\$[\\\\]*\\{([0-9a-zA-Z\\.\\-_\\/\\\\]+)\\}$/g.test(str)) {\r\n      return \"$\\\\\" + str.substring(1);\r\n    }\r\n    return str;\r\n  }\r\n  \r\n  function restoreString(str, token, type) {\r\n    if (/^\\$\\{([0-9a-zA-Z\\.\\-_]+)\\/([0-9a-zA-Z\\.\\-_]+)\\/([0-9]+)\\}$/g.test(str)) {\r\n      var parsed = str.substring(2, str.length - 1).split(\"/\"); // \" + token + \"/\" + type + \"/\" + id + \"\r\n      var id = parseInt(parsed[2], 10);\r\n      if (parsed[0] === token && parsed[1] === type) {\r\n        return cache[id];\r\n      } else {\r\n        return utils.bind(null, functionPlaceholder, parsed[0] + \"-\" + parsed[1], id);\r\n      }\r\n    } else if (/^\\$[\\\\]+\\{([0-9a-zA-Z\\.\\-_\\/\\\\]+)\\}$/g.test(str)) {\r\n      return \"$\" + str.substring(2);\r\n    }\r\n    return str;\r\n  }\r\n  \r\n  function restoreObject(obj, token, type) {\r\n    if (typeof obj === \"object\") {\r\n      utils.each(obj, function(key, value){\r\n        if (typeof value === \"object\") {\r\n          obj[key] = restoreObject(value, token, type);\r\n        } else if (typeof value === \"string\") {\r\n          obj[key] = restoreString(value, token, type);\r\n        } else if (typeof value === \"function\") {\r\n          throw Error(\"Function was found!\");\r\n        }\r\n      });\r\n    } else if (typeof value === \"string\") {\r\n      return restoreString(value, token, type);\r\n    } else if (typeof value === \"function\") {\r\n      throw Error(\"Function was found!\");\r\n    }\r\n    return obj;\r\n  }\r\n  \r\n  function functionPlaceholder(event, id) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    if (support.CustomEvent) {\r\n      return customEvent.fireEvent(event, { callbackId: id, args: args, mem: true });\r\n    } else {\r\n      return message.fireEvent(event, { callbackId: id, args: args, mem: true });\r\n    }\r\n  }\r\n  \r\n  function getCacheFunction(id) {\r\n    return cache[id];\r\n  }\r\n  \r\n  var cache = [];\r\n  \r\n  return {\r\n    parseObject: parseObject,\r\n    restoreObject: restoreObject,\r\n    getCacheFunction: getCacheFunction\r\n  };\r\n});\n//# sourceURL=/UserProxy/memFunction.js");

eval("define(\'UserProxy/Connection\',[\"./CustomEvent\", \"./Message\", \"utils\", \"./support\", \"./memFunction\"], function(customEvent, message, utils, support, mem){\r\n  function listenerProxy(functions, token, type, detail) {\r\n    setTimeout(utils.bind(null, listener, functions, token, type, detail), 4);\r\n  }\r\n  \r\n  function listener(functions, token, type, detail) {\r\n    var keys = utils.getKeys(functions);\r\n    var index = utils.indexOfArray(detail.method, keys);\r\n    if (index > -1) {\r\n      var result = functions[keys[index]].apply(null, mem.restoreObject(detail.args, token, type));\r\n      if (typeof detail.id === \"number\") {\r\n        var memResult = mem.parseObject(result, token, type);\r\n        var detail = { callbackId: detail.id, args: [ memResult ] };\r\n        if (support.CustomEvent) {\r\n          customEvent.fireEvent(token + \"-page\", detail);\r\n        } else {\r\n          message.addEventListener(token + \"-page\", detail);\r\n        }\r\n      }\r\n    } else {\r\n      throw \"Method \" + detail.method + \" has not been set!\";\r\n    }\r\n  }\r\n  \r\n  function Connection(pageProxy) {\r\n    this.token = utils.generateToken();\r\n    this.functions = {};\r\n    this.namespace = \"UserProxy\";\r\n    this.pageProxy = pageProxy;\r\n  }\r\n  \r\n  Connection.prototype.setFunctions = function setFunctions(functions) {\r\n    this.functions = functions;\r\n  }\r\n  \r\n  Connection.prototype.setNamespace = function setFunctions(namespace) {\r\n    this.namespace = namespace;\r\n  }\r\n  \r\n  Connection.prototype.inject = function inject(code) {\r\n    var parent = (document.body || document.head || document.documentElement);\r\n    if (!parent) throw \"Parent was not found!\";\r\n    \r\n    var script = document.createElement(\"script\")\r\n    script.setAttribute(\"type\", \"text/javascript\");\r\n\r\n    this.connect();\r\n    \r\n    var args = [ false, this.token, utils.getKeys(this.functions) ];\r\n    args = args.concat(Array.prototype.slice.call(arguments, 1));\r\n    \r\n    var content = \"(\" + code + \")(\" + utils.buildArgumentList.apply(null, args) + \");\";\r\n    \r\n    script.appendChild(document.createTextNode(content));\r\n    \r\n    parent.appendChild(script);\r\n    parent.removeChild(script);\r\n  }\r\n  \r\n  Connection.prototype.connect = function connect() {\r\n    if (this.establishedConnectionListener) this.disconnect();\r\n    \r\n    this.establishedConnectionListener = utils.bind(null, listenerProxy, this.functions, this.token, \"content\");\r\n    if (support.CustomEvent) {\r\n      customEvent.addEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    } else {\r\n      message.addEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    }\r\n  }\r\n  \r\n  Connection.prototype.disconnect = function connect() {\r\n    if (!this.establishedConnectionListener) return;\r\n    if (support.CustomEvent) {\r\n      customEvent.removeEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    } else {\r\n      message.removeEventListener(this.token + \"-content\", this.establishedConnectionListener);\r\n    }\r\n    this.establishedConnectionListener = null;\r\n  }\r\n  \r\n  return Connection;\r\n});\n//# sourceURL=/UserProxy/Connection.js");

eval("define(\'extensions-connection/userscript\',[], function(){\r\n  function empty() { }\r\n  return {\r\n    setPageConnection: empty\r\n  };\r\n});\n//# sourceURL=/extensions-connection/userscript.js");

eval("define(\'xhr/browser\',[], function(){\r\n  function xhr(details) {\r\n    var xmlhttp;\r\n    if (typeof XMLHttpRequest != \"undefined\") {\r\n      xmlhttp = new XMLHttpRequest();\r\n    } else {\r\n      details[\"onerror\"](responseState);\r\n    }\r\n    xmlhttp.onreadystatechange = function(){\r\n      var responseState = {\r\n        responseXML: \'\',\r\n        responseText: (xmlhttp.readyState == 4 ? xmlhttp.responseText : \'\'),\r\n        readyState: xmlhttp.readyState,\r\n        responseHeaders: (xmlhttp.readyState == 4 ? xmlhttp.getAllResponseHeaders() : \'\'),\r\n        status: (xmlhttp.readyState == 4 ? xmlhttp.status : 0),\r\n        statusText: (xmlhttp.readyState == 4 ? xmlhttp.statusText : \'\'),\r\n        finalUrl: (xmlhttp.readyState == 4 ? xmlhttp.finalUrl : \'\')\r\n      };\r\n      if (details[\"onreadystatechange\"]) {\r\n        details[\"onreadystatechange\"](responseState);\r\n      }\r\n      if (xmlhttp.readyState == 4) {\r\n        if (details[\"onload\"] && xmlhttp.status >= 200 && xmlhttp.status < 300) {\r\n          details[\"onload\"](responseState);\r\n        }\r\n        if (details[\"onerror\"] && (xmlhttp.status < 200 || xmlhttp.status >= 300)) {\r\n          details[\"onerror\"](responseState);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      xmlhttp.open(details.method, details.url);\r\n    } catch(e) {\r\n      details[\"onerror\"]();\r\n    }\r\n    if (details.headers) {\r\n      for (var prop in details.headers) {\r\n        xmlhttp.setRequestHeader(prop, details.headers[prop]);\r\n      }\r\n    }\r\n    xmlhttp.send((typeof(details.data) !== \'undefined\') ? details.data : null);\r\n  }\r\n  \r\n  return xhr;\r\n});\n//# sourceURL=/xhr/browser.js");

eval("define(\'xhr/userscript\',[\"../helper/support\", \"./browser\"], function(support, browser){\r\n  if (support.Greasemonkey) {\r\n    return GM_xmlhttpRequest;\r\n  } else {\r\n    return browser;\r\n  }\r\n});\n//# sourceURL=/xhr/userscript.js");

eval("define(\'xhr\',[\"xhr/userscript\"], function(xhr){\r\n  return xhr;\r\n});\n//# sourceURL=/xhr.js");

eval("define(\'main-wrapper\',[\"storage\", \"UserProxy/Connection\", \"extensions-connection/userscript\", \"xhr\", \"console\"], function(storage, Connection, extension, xhr, con){\r\n  var functionMap = {\r\n    \"setItem\": storage.setItem,\r\n    \"getItem\": storage.getItem,\r\n    \"removeItem\": storage.removeItem,\r\n    \"xhr\": xhr,\r\n    \"log\": con.log\r\n  };\r\n  \r\n  var connection = null;\r\n  \r\n  storage.getItem(\"YouTubeCenterSettings\", function(settings){\r\n    if (typeof settings !== \"object\") settings = JSON.parse(settings || \"{}\");\r\n    \r\n    connection = new Connection();\r\n    connection.setFunctions(functionMap);\r\n    \r\n    extension.setPageConnection(connection);\r\n    \r\n    connection.inject(mainPage, settings, con.sessionToken);\r\n  }, true);\r\n});\n//# sourceURL=/main-wrapper.js");


require(["main-wrapper"]);
}());
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJtYWluLXdyYXBwZXItYWxsLmpzIiwKICAic291cmNlcyI6IFsKICAgICIuLi92ZW5kb3IvYWxtb25kLmpzIiwKICAgICJ1bnNhZmVXaW5kb3cuanMiLAogICAgImhlbHBlci9zdXBwb3J0LmpzIiwKICAgICJ1dGlscy5qcyIsCiAgICAic3RvcmFnZS9sb2NhbFN0b3JhZ2UuanMiLAogICAgInN0b3JhZ2UvY29va2llcy5qcyIsCiAgICAiY29uc29sZS5qcyIsCiAgICAic3RvcmFnZS9icm93c2VyLmpzIiwKICAgICJzdG9yYWdlL3VzZXJzY3JpcHQuanMiLAogICAgInN0b3JhZ2UuanMiLAogICAgIlVzZXJQcm94eS9DdXN0b21FdmVudC5qcyIsCiAgICAiVXNlclByb3h5L01lc3NhZ2UuanMiLAogICAgIlVzZXJQcm94eS9zdXBwb3J0LmpzIiwKICAgICJVc2VyUHJveHkvbWVtRnVuY3Rpb24uanMiLAogICAgIlVzZXJQcm94eS9Db25uZWN0aW9uLmpzIiwKICAgICJleHRlbnNpb25zLWNvbm5lY3Rpb24vdXNlcnNjcmlwdC5qcyIsCiAgICAieGhyL2Jyb3dzZXIuanMiLAogICAgInhoci91c2Vyc2NyaXB0LmpzIiwKICAgICJ4aHIuanMiLAogICAgIm1haW4td3JhcHBlci5qcyIKICBdLAogICJuYW1lcyI6IFtdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQUNKQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EsQUNGQTtBQUNBO0FBQ0EsQUNGQTtBQUNBO0FBQ0EsQUNGQTtBQUNBO0FDREEsQURFQTtBQ0RBO0FDREEsQURFQTtBQ0RBO0FBQ0EiLAogICJzb3VyY2VzQ29udGVudCI6IFsKICAgICJldmFsKFwiLyoqXFxyXFxuICogQGxpY2Vuc2UgYWxtb25kIDAuMi45IENvcHlyaWdodCAoYykgMjAxMS0yMDE0LCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxyXFxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cXHJcXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYWxtb25kIGZvciBkZXRhaWxzXFxyXFxuICovXFxyXFxuLy9Hb2luZyBzbG9wcHkgdG8gYXZvaWQgXFwndXNlIHN0cmljdFxcJyBzdHJpbmcgY29zdCwgYnV0IHN0cmljdCBwcmFjdGljZXMgc2hvdWxkXFxyXFxuLy9iZSBmb2xsb3dlZC5cXHJcXG4vKmpzbGludCBzbG9wcHk6IHRydWUgKi9cXHJcXG4vKmdsb2JhbCBzZXRUaW1lb3V0OiBmYWxzZSAqL1xcclxcblxcclxcbnZhciByZXF1aXJlanMsIHJlcXVpcmUsIGRlZmluZTtcXHJcXG4oZnVuY3Rpb24gKHVuZGVmKSB7XFxyXFxuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxcclxcbiAgICAgICAgZGVmaW5lZCA9IHt9LFxcclxcbiAgICAgICAgd2FpdGluZyA9IHt9LFxcclxcbiAgICAgICAgY29uZmlnID0ge30sXFxyXFxuICAgICAgICBkZWZpbmluZyA9IHt9LFxcclxcbiAgICAgICAgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcXHJcXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxcclxcbiAgICAgICAganNTdWZmaXhSZWdFeHAgPSAvXFxcXC5qcyQvO1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgcHJvcCkge1xcclxcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEdpdmVuIGEgcmVsYXRpdmUgbW9kdWxlIG5hbWUsIGxpa2UgLi9zb21ldGhpbmcsIG5vcm1hbGl6ZSBpdCB0b1xcclxcbiAgICAgKiBhIHJlYWwgbmFtZSB0aGF0IGNhbiBiZSBtYXBwZWQgdG8gYSBwYXRoLlxcclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxcclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZU5hbWUgYSByZWFsIG5hbWUgdGhhdCB0aGUgbmFtZSBhcmcgaXMgcmVsYXRpdmVcXHJcXG4gICAgICogdG8uXFxyXFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxcclxcbiAgICAgKi9cXHJcXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XFxyXFxuICAgICAgICB2YXIgbmFtZVBhcnRzLCBuYW1lU2VnbWVudCwgbWFwVmFsdWUsIGZvdW5kTWFwLCBsYXN0SW5kZXgsXFxyXFxuICAgICAgICAgICAgZm91bmRJLCBmb3VuZFN0YXJNYXAsIHN0YXJJLCBpLCBqLCBwYXJ0LFxcclxcbiAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lICYmIGJhc2VOYW1lLnNwbGl0KFxcXCIvXFxcIiksXFxyXFxuICAgICAgICAgICAgbWFwID0gY29uZmlnLm1hcCxcXHJcXG4gICAgICAgICAgICBzdGFyTWFwID0gKG1hcCAmJiBtYXBbXFwnKlxcJ10pIHx8IHt9O1xcclxcblxcclxcbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxcclxcbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09IFxcXCIuXFxcIikge1xcclxcbiAgICAgICAgICAgIC8vSWYgaGF2ZSBhIGJhc2UgbmFtZSwgdHJ5IHRvIG5vcm1hbGl6ZSBhZ2FpbnN0IGl0LFxcclxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcXHJcXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cXHJcXG4gICAgICAgICAgICBpZiAoYmFzZU5hbWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IGJhc2VOYW1lIHRvIGFycmF5LCBhbmQgbG9wIG9mZiB0aGUgbGFzdCBwYXJ0LFxcclxcbiAgICAgICAgICAgICAgICAvL3NvIHRoYXQgLiBtYXRjaGVzIHRoYXQgXFxcImRpcmVjdG9yeVxcXCIgYW5kIG5vdCBuYW1lIG9mIHRoZSBiYXNlTmFtZVxcJ3NcXHJcXG4gICAgICAgICAgICAgICAgLy9tb2R1bGUuIEZvciBpbnN0YW5jZSwgYmFzZU5hbWUgb2YgXFxcIm9uZS90d28vdGhyZWVcXFwiLCBtYXBzIHRvXFxyXFxuICAgICAgICAgICAgICAgIC8vXFxcIm9uZS90d28vdGhyZWUuanNcXFwiLCBidXQgd2Ugd2FudCB0aGUgZGlyZWN0b3J5LCBcXFwib25lL3R3b1xcXCIgZm9yXFxyXFxuICAgICAgICAgICAgICAgIC8vdGhpcyBub3JtYWxpemF0aW9uLlxcclxcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdChcXCcvXFwnKTtcXHJcXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBOb2RlIC5qcyBhbGxvd2FuY2U6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubm9kZUlkQ29tcGF0ICYmIGpzU3VmZml4UmVnRXhwLnRlc3QobmFtZVtsYXN0SW5kZXhdKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVtsYXN0SW5kZXhdID0gbmFtZVtsYXN0SW5kZXhdLnJlcGxhY2UoanNTdWZmaXhSZWdFeHAsIFxcJ1xcJyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IGJhc2VQYXJ0cy5jb25jYXQobmFtZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vc3RhcnQgdHJpbURvdHNcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpICs9IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBuYW1lW2ldO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09IFxcXCIuXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGksIDEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXFxcIi4uXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChuYW1lWzJdID09PSBcXCcuLlxcJyB8fCBuYW1lWzBdID09PSBcXCcuLlxcJykpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoIFxcJy4uXFwnLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2FuIHN0aWxsIGZhaWwsIGJ1dCBjYXRjaGVzIHRoZSBtb3N0IHJlYXNvbmFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91c2VzIG9mIC4uXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSAtIDEsIDIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC8vZW5kIHRyaW1Eb3RzXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmpvaW4oXFxcIi9cXFwiKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcXCcuL1xcJykgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gTm8gYmFzZU5hbWUsIHNvIHRoaXMgaXMgSUQgaXMgcmVzb2x2ZWQgcmVsYXRpdmVcXHJcXG4gICAgICAgICAgICAgICAgLy8gdG8gYmFzZVVybCwgcHVsbCBvZmYgdGhlIGxlYWRpbmcgZG90LlxcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMik7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy9BcHBseSBtYXAgY29uZmlnIGlmIGF2YWlsYWJsZS5cXHJcXG4gICAgICAgIGlmICgoYmFzZVBhcnRzIHx8IHN0YXJNYXApICYmIG1hcCkge1xcclxcbiAgICAgICAgICAgIG5hbWVQYXJ0cyA9IG5hbWUuc3BsaXQoXFwnL1xcJyk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChpID0gbmFtZVBhcnRzLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lU2VnbWVudCA9IG5hbWVQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFxcXCIvXFxcIik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUGFydHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbG9uZ2VzdCBiYXNlTmFtZSBzZWdtZW50IG1hdGNoIGluIHRoZSBjb25maWcuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvL1NvLCBkbyBqb2lucyBvbiB0aGUgYmlnZ2VzdCB0byBzbWFsbGVzdCBsZW5ndGhzIG9mIGJhc2VQYXJ0cy5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGJhc2VQYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFtiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbihcXCcvXFwnKV07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlTmFtZSBzZWdtZW50IGhhcyAgY29uZmlnLCBmaW5kIGlmIGl0IGhhcyBvbmUgZm9yXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIG5hbWUuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwVmFsdWVbbmFtZVNlZ21lbnRdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0Y2gsIHVwZGF0ZSBuYW1lIHRvIHRoZSBuZXcgdmFsdWUuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IG1hcFZhbHVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJID0gaTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy9DaGVjayBmb3IgYSBzdGFyIG1hcCBtYXRjaCwgYnV0IGp1c3QgaG9sZCBvbiB0byBpdCxcXHJcXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBhIHNob3J0ZXIgc2VnbWVudCBtYXRjaCBsYXRlciBpbiBhIG1hdGNoaW5nXFxyXFxuICAgICAgICAgICAgICAgIC8vY29uZmlnLCB0aGVuIGZhdm9yIG92ZXIgdGhpcyBzdGFyIG1hcC5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJNYXAgJiYgc3Rhck1hcCAmJiBzdGFyTWFwW25hbWVTZWdtZW50XSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFyTWFwID0gc3Rhck1hcFtuYW1lU2VnbWVudF07XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdGFySSA9IGk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKCFmb3VuZE1hcCAmJiBmb3VuZFN0YXJNYXApIHtcXHJcXG4gICAgICAgICAgICAgICAgZm91bmRNYXAgPSBmb3VuZFN0YXJNYXA7XFxyXFxuICAgICAgICAgICAgICAgIGZvdW5kSSA9IHN0YXJJO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZVBhcnRzLnNwbGljZSgwLCBmb3VuZEksIGZvdW5kTWFwKTtcXHJcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVQYXJ0cy5qb2luKFxcJy9cXCcpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHJldHVybiBuYW1lO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIG1ha2VSZXF1aXJlKHJlbE5hbWUsIGZvcmNlU3luYykge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICAvL0EgdmVyc2lvbiBvZiBhIHJlcXVpcmUgZnVuY3Rpb24gdGhhdCBwYXNzZXMgYSBtb2R1bGVOYW1lXFxyXFxuICAgICAgICAgICAgLy92YWx1ZSBmb3IgaXRlbXMgdGhhdCBtYXkgbmVlZCB0b1xcclxcbiAgICAgICAgICAgIC8vbG9vayB1cCBwYXRocyByZWxhdGl2ZSB0byB0aGUgbW9kdWxlTmFtZVxcclxcbiAgICAgICAgICAgIHJldHVybiByZXEuYXBwbHkodW5kZWYsIGFwcy5jYWxsKGFyZ3VtZW50cywgMCkuY29uY2F0KFtyZWxOYW1lLCBmb3JjZVN5bmNdKSk7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoZGVwTmFtZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xcclxcbiAgICAgICAgICAgIGRlZmluZWRbZGVwTmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gY2FsbERlcChuYW1lKSB7XFxyXFxuICAgICAgICBpZiAoaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xcclxcbiAgICAgICAgICAgIHZhciBhcmdzID0gd2FpdGluZ1tuYW1lXTtcXHJcXG4gICAgICAgICAgICBkZWxldGUgd2FpdGluZ1tuYW1lXTtcXHJcXG4gICAgICAgICAgICBkZWZpbmluZ1tuYW1lXSA9IHRydWU7XFxyXFxuICAgICAgICAgICAgbWFpbi5hcHBseSh1bmRlZiwgYXJncyk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3AoZGVmaW5pbmcsIG5hbWUpKSB7XFxyXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcJ05vIFxcJyArIG5hbWUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGRlZmluZWRbbmFtZV07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy9UdXJucyBhIHBsdWdpbiFyZXNvdXJjZSB0byBbcGx1Z2luLCByZXNvdXJjZV1cXHJcXG4gICAgLy93aXRoIHRoZSBwbHVnaW4gYmVpbmcgdW5kZWZpbmVkIGlmIHRoZSBuYW1lXFxyXFxuICAgIC8vZGlkIG5vdCBoYXZlIGEgcGx1Z2luIHByZWZpeC5cXHJcXG4gICAgZnVuY3Rpb24gc3BsaXRQcmVmaXgobmFtZSkge1xcclxcbiAgICAgICAgdmFyIHByZWZpeCxcXHJcXG4gICAgICAgICAgICBpbmRleCA9IG5hbWUgPyBuYW1lLmluZGV4T2YoXFwnIVxcJykgOiAtMTtcXHJcXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XFxyXFxuICAgICAgICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xcclxcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhpbmRleCArIDEsIG5hbWUubGVuZ3RoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogTWFrZXMgYSBuYW1lIG1hcCwgbm9ybWFsaXppbmcgdGhlIG5hbWUsIGFuZCB1c2luZyBhIHBsdWdpblxcclxcbiAgICAgKiBmb3Igbm9ybWFsaXphdGlvbiBpZiBuZWNlc3NhcnkuIEdyYWJzIGEgcmVmIHRvIHBsdWdpblxcclxcbiAgICAgKiB0b28sIGFzIGFuIG9wdGltaXphdGlvbi5cXHJcXG4gICAgICovXFxyXFxuICAgIG1ha2VNYXAgPSBmdW5jdGlvbiAobmFtZSwgcmVsTmFtZSkge1xcclxcbiAgICAgICAgdmFyIHBsdWdpbixcXHJcXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpLFxcclxcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xcclxcblxcclxcbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xcclxcblxcclxcbiAgICAgICAgaWYgKHByZWZpeCkge1xcclxcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vTm9ybWFsaXplIGFjY29yZGluZ1xcclxcbiAgICAgICAgaWYgKHByZWZpeCkge1xcclxcbiAgICAgICAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luLm5vcm1hbGl6ZSkge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luLm5vcm1hbGl6ZShuYW1lLCBtYWtlTm9ybWFsaXplKHJlbE5hbWUpKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcXHJcXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpO1xcclxcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xcclxcbiAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcXHJcXG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XFxyXFxuICAgICAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL1VzaW5nIHJpZGljdWxvdXMgcHJvcGVydHkgbmFtZXMgZm9yIHNwYWNlIHJlYXNvbnNcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgZjogcHJlZml4ID8gcHJlZml4ICsgXFwnIVxcJyArIG5hbWUgOiBuYW1lLCAvL2Z1bGxOYW1lXFxyXFxuICAgICAgICAgICAgbjogbmFtZSxcXHJcXG4gICAgICAgICAgICBwcjogcHJlZml4LFxcclxcbiAgICAgICAgICAgIHA6IHBsdWdpblxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbWFrZUNvbmZpZyhuYW1lKSB7XFxyXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiAoY29uZmlnICYmIGNvbmZpZy5jb25maWcgJiYgY29uZmlnLmNvbmZpZ1tuYW1lXSkgfHwge307XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGhhbmRsZXJzID0ge1xcclxcbiAgICAgICAgcmVxdWlyZTogZnVuY3Rpb24gKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUobmFtZSk7XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgZXhwb3J0czogZnVuY3Rpb24gKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgZSA9IGRlZmluZWRbbmFtZV07XFxyXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlICE9PSBcXCd1bmRlZmluZWRcXCcpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkZWZpbmVkW25hbWVdID0ge30pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb2R1bGU6IGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgaWQ6IG5hbWUsXFxyXFxuICAgICAgICAgICAgICAgIHVyaTogXFwnXFwnLFxcclxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBkZWZpbmVkW25hbWVdLFxcclxcbiAgICAgICAgICAgICAgICBjb25maWc6IG1ha2VDb25maWcobmFtZSlcXHJcXG4gICAgICAgICAgICB9O1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICBtYWluID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKSB7XFxyXFxuICAgICAgICB2YXIgY2pzTW9kdWxlLCBkZXBOYW1lLCByZXQsIG1hcCwgaSxcXHJcXG4gICAgICAgICAgICBhcmdzID0gW10sXFxyXFxuICAgICAgICAgICAgY2FsbGJhY2tUeXBlID0gdHlwZW9mIGNhbGxiYWNrLFxcclxcbiAgICAgICAgICAgIHVzaW5nRXhwb3J0cztcXHJcXG5cXHJcXG4gICAgICAgIC8vVXNlIG5hbWUgaWYgbm8gcmVsTmFtZVxcclxcbiAgICAgICAgcmVsTmFtZSA9IHJlbE5hbWUgfHwgbmFtZTtcXHJcXG5cXHJcXG4gICAgICAgIC8vQ2FsbCB0aGUgY2FsbGJhY2sgdG8gZGVmaW5lIHRoZSBtb2R1bGUsIGlmIG5lY2Vzc2FyeS5cXHJcXG4gICAgICAgIGlmIChjYWxsYmFja1R5cGUgPT09IFxcJ3VuZGVmaW5lZFxcJyB8fCBjYWxsYmFja1R5cGUgPT09IFxcJ2Z1bmN0aW9uXFwnKSB7XFxyXFxuICAgICAgICAgICAgLy9QdWxsIG91dCB0aGUgZGVmaW5lZCBkZXBlbmRlbmNpZXMgYW5kIHBhc3MgdGhlIG9yZGVyZWRcXHJcXG4gICAgICAgICAgICAvL3ZhbHVlcyB0byB0aGUgY2FsbGJhY2suXFxyXFxuICAgICAgICAgICAgLy9EZWZhdWx0IHRvIFtyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGVdIGlmIG5vIGRlcHNcXHJcXG4gICAgICAgICAgICBkZXBzID0gIWRlcHMubGVuZ3RoICYmIGNhbGxiYWNrLmxlbmd0aCA/IFtcXCdyZXF1aXJlXFwnLCBcXCdleHBvcnRzXFwnLCBcXCdtb2R1bGVcXCddIDogZGVwcztcXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkgKz0gMSkge1xcclxcbiAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTWFwKGRlcHNbaV0sIHJlbE5hbWUpO1xcclxcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gbWFwLmY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vRmFzdCBwYXRoIENvbW1vbkpTIHN0YW5kYXJkIGRlcGVuZGVuY2llcy5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGRlcE5hbWUgPT09IFxcXCJyZXF1aXJlXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLnJlcXVpcmUobmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXFxcImV4cG9ydHNcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxcclxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLmV4cG9ydHMobmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB1c2luZ0V4cG9ydHMgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFxcXCJtb2R1bGVcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxcclxcbiAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlID0gYXJnc1tpXSA9IGhhbmRsZXJzLm1vZHVsZShuYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNQcm9wKGRlZmluZWQsIGRlcE5hbWUpIHx8XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcCh3YWl0aW5nLCBkZXBOYW1lKSB8fFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb3AoZGVmaW5pbmcsIGRlcE5hbWUpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gY2FsbERlcChkZXBOYW1lKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAucCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWFwLnAubG9hZChtYXAubiwgbWFrZVJlcXVpcmUocmVsTmFtZSwgdHJ1ZSksIG1ha2VMb2FkKGRlcE5hbWUpLCB7fSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gZGVmaW5lZFtkZXBOYW1lXTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXFwnIG1pc3NpbmcgXFwnICsgZGVwTmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0ID0gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseShkZWZpbmVkW25hbWVdLCBhcmdzKSA6IHVuZGVmaW5lZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobmFtZSkge1xcclxcbiAgICAgICAgICAgICAgICAvL0lmIHNldHRpbmcgZXhwb3J0cyB2aWEgXFxcIm1vZHVsZVxcXCIgaXMgaW4gcGxheSxcXHJcXG4gICAgICAgICAgICAgICAgLy9mYXZvciB0aGF0IG92ZXIgcmV0dXJuIHZhbHVlIGFuZCBleHBvcnRzLiBBZnRlciB0aGF0LFxcclxcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIGEgbm9uLXVuZGVmaW5lZCByZXR1cm4gdmFsdWUgb3ZlciBleHBvcnRzIHVzZS5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNqc01vZHVsZSAmJiBjanNNb2R1bGUuZXhwb3J0cyAhPT0gdW5kZWYgJiZcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUuZXhwb3J0cyAhPT0gZGVmaW5lZFtuYW1lXSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNqc01vZHVsZS5leHBvcnRzO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gdW5kZWYgfHwgIXVzaW5nRXhwb3J0cykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy9Vc2UgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSByZXQ7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcXHJcXG4gICAgICAgICAgICAvL01heSBqdXN0IGJlIGFuIG9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgbW9kdWxlLiBPbmx5XFxyXFxuICAgICAgICAgICAgLy93b3JyeSBhYm91dCBkZWZpbmluZyBpZiBoYXZlIGEgbW9kdWxlIG5hbWUuXFxyXFxuICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNhbGxiYWNrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICByZXF1aXJlanMgPSByZXF1aXJlID0gcmVxID0gZnVuY3Rpb24gKGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lLCBmb3JjZVN5bmMsIGFsdCkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1tkZXBzXSkge1xcclxcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGluIHRoaXMgY2FzZSBpcyByZWFsbHkgcmVsTmFtZVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnNbZGVwc10oY2FsbGJhY2spO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAvL0p1c3QgcmV0dXJuIHRoZSBtb2R1bGUgd2FudGVkLiBJbiB0aGlzIHNjZW5hcmlvLCB0aGVcXHJcXG4gICAgICAgICAgICAvL2RlcHMgYXJnIGlzIHRoZSBtb2R1bGUgbmFtZSwgYW5kIHNlY29uZCBhcmcgKGlmIHBhc3NlZClcXHJcXG4gICAgICAgICAgICAvL2lzIGp1c3QgdGhlIHJlbE5hbWUuXFxyXFxuICAgICAgICAgICAgLy9Ob3JtYWxpemUgbW9kdWxlIG5hbWUsIGlmIGl0IGNvbnRhaW5zIC4gb3IgLi5cXHJcXG4gICAgICAgICAgICByZXR1cm4gY2FsbERlcChtYWtlTWFwKGRlcHMsIGNhbGxiYWNrKS5mKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoIWRlcHMuc3BsaWNlKSB7XFxyXFxuICAgICAgICAgICAgLy9kZXBzIGlzIGEgY29uZmlnIG9iamVjdCwgbm90IGFuIGFycmF5LlxcclxcbiAgICAgICAgICAgIGNvbmZpZyA9IGRlcHM7XFxyXFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZXBzKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJlcShjb25maWcuZGVwcywgY29uZmlnLmNhbGxiYWNrKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5zcGxpY2UpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpcyBhbiBhcnJheSwgd2hpY2ggbWVhbnMgaXQgaXMgYSBkZXBlbmRlbmN5IGxpc3QuXFxyXFxuICAgICAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xcclxcbiAgICAgICAgICAgICAgICBkZXBzID0gY2FsbGJhY2s7XFxyXFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcmVsTmFtZTtcXHJcXG4gICAgICAgICAgICAgICAgcmVsTmFtZSA9IG51bGw7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgZGVwcyA9IHVuZGVmO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vU3VwcG9ydCByZXF1aXJlKFtcXCdhXFwnXSlcXHJcXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XFxyXFxuXFxyXFxuICAgICAgICAvL0lmIHJlbE5hbWUgaXMgYSBmdW5jdGlvbiwgaXQgaXMgYW4gZXJyYmFjayBoYW5kbGVyLFxcclxcbiAgICAgICAgLy9zbyByZW1vdmUgaXQuXFxyXFxuICAgICAgICBpZiAodHlwZW9mIHJlbE5hbWUgPT09IFxcJ2Z1bmN0aW9uXFwnKSB7XFxyXFxuICAgICAgICAgICAgcmVsTmFtZSA9IGZvcmNlU3luYztcXHJcXG4gICAgICAgICAgICBmb3JjZVN5bmMgPSBhbHQ7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvL1NpbXVsYXRlIGFzeW5jIGNhbGxiYWNrO1xcclxcbiAgICAgICAgaWYgKGZvcmNlU3luYykge1xcclxcbiAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgLy9Vc2luZyBhIG5vbi16ZXJvIHZhbHVlIGJlY2F1c2Ugb2YgY29uY2VybiBmb3Igd2hhdCBvbGQgYnJvd3NlcnNcXHJcXG4gICAgICAgICAgICAvL2RvLCBhbmQgbGF0ZXN0IGJyb3dzZXJzIFxcXCJ1cGdyYWRlXFxcIiB0byA0IGlmIGxvd2VyIHZhbHVlIGlzIHVzZWQ6XFxyXFxuICAgICAgICAgICAgLy9odHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aW1lcnMuaHRtbCNkb20td2luZG93dGltZXJzLXNldHRpbWVvdXQ6XFxyXFxuICAgICAgICAgICAgLy9JZiB3YW50IGEgdmFsdWUgaW1tZWRpYXRlbHksIHVzZSByZXF1aXJlKFxcJ2lkXFwnKSBpbnN0ZWFkIC0tIHNvbWV0aGluZ1xcclxcbiAgICAgICAgICAgIC8vdGhhdCB3b3JrcyBpbiBhbG1vbmQgb24gdGhlIGdsb2JhbCBsZXZlbCwgYnV0IG5vdCBndWFyYW50ZWVkIGFuZFxcclxcbiAgICAgICAgICAgIC8vdW5saWtlbHkgdG8gd29yayBpbiBvdGhlciBBTUQgaW1wbGVtZW50YXRpb25zLlxcclxcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XFxyXFxuICAgICAgICAgICAgfSwgNCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICByZXR1cm4gcmVxO1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogSnVzdCBkcm9wcyB0aGUgY29uZmlnIG9uIHRoZSBmbG9vciwgYnV0IHJldHVybnMgcmVxIGluIGNhc2VcXHJcXG4gICAgICogdGhlIGNvbmZpZyByZXR1cm4gdmFsdWUgaXMgdXNlZC5cXHJcXG4gICAgICovXFxyXFxuICAgIHJlcS5jb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XFxyXFxuICAgICAgICByZXR1cm4gcmVxKGNmZyk7XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBFeHBvc2UgbW9kdWxlIHJlZ2lzdHJ5IGZvciBkZWJ1Z2dpbmcgYW5kIHRvb2xpbmdcXHJcXG4gICAgICovXFxyXFxuICAgIHJlcXVpcmVqcy5fZGVmaW5lZCA9IGRlZmluZWQ7XFxyXFxuXFxyXFxuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xcclxcblxcclxcbiAgICAgICAgLy9UaGlzIG1vZHVsZSBtYXkgbm90IGhhdmUgZGVwZW5kZW5jaWVzXFxyXFxuICAgICAgICBpZiAoIWRlcHMuc3BsaWNlKSB7XFxyXFxuICAgICAgICAgICAgLy9kZXBzIGlzIG5vdCBhbiBhcnJheSwgc28gcHJvYmFibHkgbWVhbnNcXHJcXG4gICAgICAgICAgICAvL2FuIG9iamVjdCBsaXRlcmFsIG9yIGZhY3RvcnkgZnVuY3Rpb24gZm9yXFxyXFxuICAgICAgICAgICAgLy90aGUgdmFsdWUuIEFkanVzdCBhcmdzLlxcclxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcXHJcXG4gICAgICAgICAgICBkZXBzID0gW107XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcXHJcXG4gICAgICAgICAgICB3YWl0aW5nW25hbWVdID0gW25hbWUsIGRlcHMsIGNhbGxiYWNrXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgZGVmaW5lLmFtZCA9IHtcXHJcXG4gICAgICAgIGpRdWVyeTogdHJ1ZVxcclxcbiAgICB9O1xcclxcbn0oKSk7XFxyXFxuXFxuLy8jIHNvdXJjZVVSTD0vLi4vdmVuZG9yL2FsbW9uZC5qc1wiKTtcblxuZGVmaW5lKFwiLi4vdmVuZG9yL2FsbW9uZFwiLCBmdW5jdGlvbigpe30pO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwndW5zYWZlV2luZG93XFwnLFtdLCBmdW5jdGlvbigpe1xcclxcbiAgcmV0dXJuIHdpbmRvdztcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS91bnNhZmVXaW5kb3cuanNcIik7XG5cbiIsCiAgICAiZXZhbChcIi8qKlxcclxcbiogQSBoZWxwZXIgY2xhc3MgdG8gaGVscCBjaGVja2luZyBmb3IgZmVhdHVyZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlxcclxcbiogQG5hbWVzcGFjZSBoZWxwZXJcXHJcXG4qIEBjbGFzcyBTdXBwb3J0XFxyXFxuKiovXFxyXFxuZGVmaW5lKFxcJ2hlbHBlci9zdXBwb3J0XFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCJ1bnNhZmVXaW5kb3dcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgdXcpe1xcclxcbiAgLyoqXFxyXFxuICAqIFBlcmZvcm1pbmcgYSBzaW1wbGUgTG9jYWxTdG9yYWdlIHNldCwgZ2V0IHRlc3QuXFxyXFxuICAqXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBsb2NhbFN0b3JhZ2VUZXN0XFxyXFxuICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBMb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxcclxcbiAgKiovXFxyXFxuICBmdW5jdGlvbiBsb2NhbFN0b3JhZ2VUZXN0KCkge1xcclxcbiAgICB2YXIgbW9kID0gXFxcInN1cHBvcnQudGVzdFxcXCI7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xcclxcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XFxyXFxuICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgIH0gY2F0Y2ggKGUpIHtcXHJcXG4gICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIGB3ZWJraXRVUkxgIGlzIGFuIG9iamVjdC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgaXNXZWJraXRVUkxcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgaXNXZWJraXRVUkwgPSB0eXBlb2YgdXcud2Via2l0VVJMID09PSBcXFwib2JqZWN0XFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIGBVUkxgIGlzIGFuIG9iamVjdC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgaXNVUkxcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgaXNVUkwgPSB0eXBlb2YgdXcuVVJMID09PSBcXFwib2JqZWN0XFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIE1heHRob24gcnVudGltZSBpcyBhY2Nlc3NpYmxlLlxcclxcbiAgKlxcclxcbiAgKiBAcHJpdmF0ZVxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBtYXh0aG9uUnVudGltZVxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIHZhciBtYXh0aG9uUnVudGltZSA9IHdpbmRvdyAmJiB3aW5kb3cuZXh0ZXJuYWwgJiYgd2luZG93LmV4dGVybmFsLm14R2V0UnVudGltZSAmJiB0eXBlb2Ygd2luZG93LmV4dGVybmFsLm14R2V0UnVudGltZSA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIGBjcmVhdGVPYmplY3RVUkxgIGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgaXNDcmVhdGVPYmplY3RVUkxcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgaXNDcmVhdGVPYmplY3RVUkwgPSBmYWxzZTtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIGByZXZva2VPYmplY3RVUkxgIGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHByaXZhdGVcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgaXNSZXZva2VPYmplY3RVUkxcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICB2YXIgaXNSZXZva2VPYmplY3RVUkwgPSBmYWxzZTtcXHJcXG4gIGlmIChpc1dlYmtpdFVSTCkge1xcclxcbiAgICBpc0NyZWF0ZU9iamVjdFVSTCA9IHR5cGVvZiB1dy53ZWJraXRVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgICBpc1Jldm9rZU9iamVjdFVSTCA9IHR5cGVvZiB1dy53ZWJraXRVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgfSBlbHNlIGlmIChpc1VSTCkge1xcclxcbiAgICBpc0NyZWF0ZU9iamVjdFVSTCA9IHR5cGVvZiB1dy5VUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgICBpc1Jldm9rZU9iamVjdFVSTCA9IHR5cGVvZiB1dy5VUkwucmV2b2tlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tpbmcgaWYgTG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgbG9jYWxTdG9yYWdlXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VUZXN0KCk7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiB0aGUgR3JlYXNlbW9ua2V5IEFQSSBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IEdyZWFzZW1vbmtleVxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMuR3JlYXNlbW9ua2V5ID0gKHR5cGVvZiBHTV9zZXRWYWx1ZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgKHR5cGVvZiBHTV9zZXRWYWx1ZS50b1N0cmluZyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgR01fc2V0VmFsdWUudG9TdHJpbmcoKS5pbmRleE9mKFxcXCJub3Qgc3VwcG9ydGVkXFxcIikgPT09IC0xKSk7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBgY3JlYXRlT2JqZWN0VVJgIGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgY3JlYXRlT2JqZWN0VVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5jcmVhdGVPYmplY3RVUkwgPSBpc0NyZWF0ZU9iamVjdFVSTDtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIGByZXZva2VPYmplY3RVUkxgIGlzIHN1cHBvcnRlZC5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAcHJvcGVydHkgcmV2b2tlT2JqZWN0VVJMXFxyXFxuICAqIEB0eXBlIEJvb2xlYW5cXHJcXG4gICoqL1xcclxcbiAgZXhwb3J0cy5yZXZva2VPYmplY3RVUkwgPSBpc1Jldm9rZU9iamVjdFVSTDtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIHRoZSBgd2Via2l0VVJMYCBvYmplY3QgaXMgc3VwcG9ydGVkLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSB3ZWJraXRVUkxcXHJcXG4gICogQHR5cGUgQm9vbGVhblxcclxcbiAgKiovXFxyXFxuICBleHBvcnRzLndlYmtpdFVSTCA9IGlzV2Via2l0VVJMO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tpbmcgaWYgdGhlIGBVUkxgIG9iamVjdCBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IFVSTFxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMuVVJMID0gaXNVUkw7XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBDaGVja2luZyBpZiBNYXh0aG9uIHJ1bnRpbWUgaXMgc3VwcG9ydGVkLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBtYXh0aG9uUnVudGltZVxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMubWF4dGhvblJ1bnRpbWUgPSBtYXh0aG9uUnVudGltZTtcXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENoZWNraW5nIGlmIE1heHRob24gcnVudGltZSBTdG9yYWdlIG9iamVjdCBpcyBzdXBwb3J0ZWQuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQHByb3BlcnR5IG1heHRob25SdW50aW1lU3RvcmFnZVxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMubWF4dGhvblJ1bnRpbWVTdG9yYWdlID0gbWF4dGhvblJ1bnRpbWUgJiYgd2luZG93LmV4dGVybmFsLm14R2V0UnVudGltZSgpICYmIHdpbmRvdy5leHRlcm5hbC5teEdldFJ1bnRpbWUoKS5zdG9yYWdlO1xcclxcbiAgXFxyXFxuICAvKipcXHJcXG4gICogQ2hlY2tpbmcgaWYgRmlyZWZveCBleHRlbnNpb24gcG9ydCBpcyBhY2Nlc3NpYmxlLlxcclxcbiAgKlxcclxcbiAgKiBAc3RhdGljXFxyXFxuICAqIEBwcm9wZXJ0eSBmaXJlZm94UG9ydFxcclxcbiAgKiBAdHlwZSBCb29sZWFuXFxyXFxuICAqKi9cXHJcXG4gIGV4cG9ydHMuZmlyZWZveFBvcnQgPSB0aGlzLnBvcnQgJiYgdHlwZW9mIHRoaXMucG9ydC5yZXF1ZXN0ID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHRoaXMucG9ydC5zdG9yYWdlICYmIHR5cGVvZiB0aGlzLnBvcnQub24gPT09IFxcXCJmdW5jdGlvblxcXCI7XFxyXFxuICBcXHJcXG4gIHJldHVybiBleHBvcnRzO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L2hlbHBlci9zdXBwb3J0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCIvKipcXHJcXG4qIEBjbGFzcyBVdGlsc1xcclxcbioqL1xcclxcbmRlZmluZShcXCd1dGlsc1xcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwiLi9oZWxwZXIvc3VwcG9ydFxcXCIsIFxcXCJ1bnNhZmVXaW5kb3dcXFwiXSwgZnVuY3Rpb24oZXhwb3J0cywgc3VwcG9ydCwgdXcpe1xcclxcbiAgZnVuY3Rpb24gZWFjaChvYmosIGNhbGxiYWNrKSB7XFxyXFxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgaWYgKGNhbGxiYWNrKGksIG9ialtpXSkgPT09IHRydWUpIGJyZWFrO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxyXFxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGtleSwgb2JqW2tleV0pID09PSB0cnVlKSBicmVhaztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcXHJcXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcXFwiW29iamVjdCBBcnJheV1cXFwiO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBhc3luY0NhbGwoc2NvcGUsIGNhbGxiYWNrKSB7XFxyXFxuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmQuYXBwbHkobnVsbCwgW3Njb3BlLCBjYWxsYmFja10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKSwgMCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGJpbmQoc2NvcGUsIGZ1bmMpIHtcXHJcXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcXHJcXG4gICAgICByZXR1cm4gZnVuYy5hcHBseShzY29wZSwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpXFxyXFxuICAgIH07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRyaW1MZWZ0KG9iail7XFxyXFxuICAgIHJldHVybiBvYmoucmVwbGFjZSgvXlxcXFxzKy8sIFxcXCJcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdHJpbVJpZ2h0KG9iail7XFxyXFxuICAgIHJldHVybiBvYmoucmVwbGFjZSgvXFxcXHMrJC8sIFxcXCJcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbWFwKG9iaiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvYmoubGVuZ3RoLCBhID0gW107IGkgPCBuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoaSBpbiBvYmopIGFbaV0gPSBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIG9ialtpXSk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGE7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBEZWZpbmUgYSBwcm9wZXJ0eSB3aXRoIGEgZ2V0dGVyIGFuZCBhIHNldHRlci5cXHJcXG4gICpcXHJcXG4gICogQG1ldGhvZCBkZWZpbmVQcm9wZXJ0eVxcclxcbiAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Qgd2hlcmUgdGhlIHByb3BlcnR5IHJlc2lkZXMgaW4uXFxyXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxcclxcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXQgVGhlIGdldHRlciBmdW5jdGlvbi5cXHJcXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0IFRoZSBzZXR0ZXIgZnVuY3Rpb24uXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwga2V5LCBnZXQsIHNldCkge1xcclxcbiAgICBpZiAoT2JqZWN0ICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcXHJcXG4gICAgICAgIFxcXCJnZXRcXFwiOiBnZXQsXFxyXFxuICAgICAgICBcXFwic2V0XFxcIjogc2V0XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBnZXQpO1xcclxcbiAgICAgIG9iai5fX2RlZmluZVNldHRlcl9fKGtleSwgc2V0KTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBkZWZpbmVMb2NrZWRQcm9wZXJ0eShvYmosIGtleSwgc2V0dGVyLCBnZXR0ZXIpIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFxcXCJvYmplY3RcXFwiKSBvYmogPSB7fTtcXHJcXG4gICAgaWYgKHN1cHBvcnQuaWUgfHwgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcclxcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xcclxcbiAgICAgICAgZ2V0OiBnZXR0ZXIsXFxyXFxuICAgICAgICBzZXQ6IHNldHRlclxcclxcbiAgICAgIH0pO1xcclxcbiAgICAgIHJldHVybiBvYmo7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBnZXR0ZXIpO1xcclxcbiAgICAgIG9iai5fX2RlZmluZVNldHRlcl9fKGtleSwgc2V0dGVyKTtcXHJcXG4gICAgICByZXR1cm4gb2JqO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWxtLCBldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcXHJcXG4gICAgaWYgKGVsbS5hZGRFdmVudExpc3RlbmVyKSB7XFxyXFxuICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcXHJcXG4gICAgfSBlbHNlIGlmIChlbG0uYXR0YWNoRXZlbnQpIHtcXHJcXG4gICAgICBlbG0uYXR0YWNoRXZlbnQoXFxcIm9uXFxcIiArIGV2ZW50LCBjYWxsYmFjayk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbG0sIGV2ZW50LCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xcclxcbiAgICBpZiAoZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXHJcXG4gICAgICBlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xcclxcbiAgICB9IGVsc2UgaWYgKGVsbS5kZXRhY2hFdmVudCkge1xcclxcbiAgICAgIGVsbS5kZXRhY2hFdmVudChcXFwib25cXFwiICsgZXZlbnQsIGNhbGxiYWNrKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xcclxcbiAgICByZXR1cm4gK25ldyBEYXRlO1xcclxcbiAgfTtcXHJcXG4gIFxcclxcbiAgLyogQ29va2llcyAqL1xcclxcbiAgZnVuY3Rpb24gc2V0Q29va2llKG5hbWUsIHZhbHVlLCBkb21haW4sIHBhdGgsIGV4cGlyZXMpIHtcXHJcXG4gICAgZG9tYWluID0gZG9tYWluID8gXFxcIjtkb21haW49XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChkb21haW4pIDogXFxcIlxcXCI7XFxyXFxuICAgIHBhdGggPSBwYXRoID8gXFxcIjtwYXRoPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQocGF0aCkgOiBcXFwiXFxcIjtcXHJcXG4gICAgZXhwaXJlcyA9IDAgPiBleHBpcmVzID8gXFxcIlxcXCIgOiAwID09IGV4cGlyZXMgPyBcXFwiO2V4cGlyZXM9XFxcIiArIChuZXcgRGF0ZSgxOTcwLCAxLCAxKSkudG9VVENTdHJpbmcoKSA6IFxcXCI7ZXhwaXJlcz1cXFwiICsgKG5ldyBEYXRlKG5vdygpICsgMUUzICogZXhwaXJlcykpLnRvVVRDU3RyaW5nKCk7XFxyXFxuICAgIFxcclxcbiAgICBkb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyBcXFwiPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZG9tYWluICsgcGF0aCArIGV4cGlyZXM7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldENvb2tpZShrZXkpIHtcXHJcXG4gICAgcmV0dXJuIGdldENvb2tpZXMoKVtrZXldO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRDb29raWVzKCkge1xcclxcbiAgICB2YXIgYyA9IGRvY3VtZW50LmNvb2tpZSwgdiA9IDAsIGNvb2tpZXMgPSB7fTtcXHJcXG4gICAgaWYgKGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvXlxcXFxzKlxcXFwkVmVyc2lvbj0oPzpcXFwiMVxcXCJ8MSk7XFxcXHMqKC4qKS8pKSB7XFxyXFxuICAgICAgYyA9IFJlZ0V4cC4kMTtcXHJcXG4gICAgICB2ID0gMTtcXHJcXG4gICAgfVxcclxcbiAgICBpZiAodiA9PT0gMCkge1xcclxcbiAgICAgIG1hcChjLnNwbGl0KC9bLDtdLyksIGZ1bmN0aW9uKGNvb2tpZSkge1xcclxcbiAgICAgICAgdmFyIHBhcnRzID0gY29va2llLnNwbGl0KC89LywgMiksXFxyXFxuICAgICAgICAgICAgbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0cmltTGVmdChwYXJ0c1swXSkpLFxcclxcbiAgICAgICAgICAgIHZhbHVlID0gcGFydHMubGVuZ3RoID4gMSA/IGRlY29kZVVSSUNvbXBvbmVudCh0cmltUmlnaHQocGFydHNbMV0pKSA6IG51bGw7XFxyXFxuICAgICAgICBjb29raWVzW25hbWVdID0gdmFsdWU7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgbWFwKGMubWF0Y2goLyg/Ol58XFxcXHMrKShbISMkJSZcXCcqK1xcXFwtLjAtOUEtWl5gYS16fH5dKyk9KFshIyQlJlxcJyorXFxcXC0uMC05QS1aXmBhLXp8fl0qfFxcXCIoPzpbXFxcXHgyMC1cXFxceDdFXFxcXHg4MFxcXFx4RkZdfFxcXFxcXFxcW1xcXFx4MDAtXFxcXHg3Rl0pKlxcXCIpKD89XFxcXHMqWyw7XXwkKS9nKSwgZnVuY3Rpb24oJDAsICQxKSB7XFxyXFxuICAgICAgICB2YXIgbmFtZSA9ICQwLCB2YWx1ZSA9ICQxLmNoYXJBdCgwKSA9PT0gXFwnXFxcIlxcJyA/ICQxLnN1YnN0cigxLCAtMSkucmVwbGFjZSgvXFxcXFxcXFwoLikvZywgXFxcIiQxXFxcIikgOiAkMTtcXHJcXG4gICAgICAgIGNvb2tpZXNbbmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gY29va2llcztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcXHJcXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaW5qZWN0KGZ1bmMpIHtcXHJcXG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLFxcclxcbiAgICAgICAgcCA9IChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcXHJcXG4gICAgaWYgKCFwKSB7XFxyXFxuICAgICAgdGhyb3cgXFxcIkNvdWxkIG5vdCBpbmplY3QhISFcXFwiO1xcclxcbiAgICB9XFxyXFxuICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwidGV4dC9qYXZhc2NyaXB0XFxcIik7XFxyXFxuICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcXFwiKFxcXCIgKyBmdW5jICsgXFxcIikoXFxcIiArIGJ1aWxkQXJndW1lbnRMaXN0LmFwcGx5KG51bGwsIFtmYWxzZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKSArIFxcXCIpO1xcXCIpKTtcXHJcXG4gICAgcC5hcHBlbmRDaGlsZChzY3JpcHQpO1xcclxcbiAgICBwLnJlbW92ZUNoaWxkKHNjcmlwdCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGJ1aWxkQXJndW1lbnRMaXN0KHdyYXApIHtcXHJcXG4gICAgdmFyIGxpc3QgPSBbXTtcXHJcXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goXFxcIlxcXFxcXFwiXFxcIiArIGFyZ3NbaV0ucmVwbGFjZSgvXFxcXFxcXFwvLCBcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcXCIvZywgXFxcIlxcXFxcXFxcXFxcXFxcXCJcXFwiKSArIFxcXCJcXFxcXFxcIlxcXCIpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goSlNPTi5zdHJpbmdpZnkoYXJnc1tpXSkpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxyXFxuICAgICAgICBsaXN0LnB1c2goXFxcIm51bGxcXFwiKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgbGlzdC5wdXNoKGFyZ3NbaV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBpZiAod3JhcCkge1xcclxcbiAgICAgIHJldHVybiBcXFwiKFxcXCIgKyBsaXN0LmpvaW4oXFxcIixcXFwiKSArIFxcXCIpXFxcIjtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICByZXR1cm4gbGlzdC5qb2luKFxcXCIsXFxcIik7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaXNKU09OU3RyaW5nKGpzb24pIHtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICBKU09OLnBhcnNlKGpzb24pO1xcclxcbiAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiB0cnVlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiB4aHIoZGV0YWlscykge1xcclxcbiAgICB2YXIgeG1saHR0cDtcXHJcXG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXHJcXG4gICAgICB4bWxodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxyXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wZXJhICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0eXBlb2Ygb3BlcmEuWE1MSHR0cFJlcXVlc3QgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxyXFxuICAgICAgeG1saHR0cCA9IG5ldyBvcGVyYS5YTUxIdHRwUmVxdWVzdCgpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGlmIChkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0pIHtcXHJcXG4gICAgICAgIGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSgpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICBcXHJcXG4gICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG4gICAgeG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xcclxcbiAgICAgIHZhciByZXNwb25zZVN0YXRlID0ge1xcclxcbiAgICAgICAgcmVzcG9uc2VYTUw6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5yZXNwb25zZVhNTCA6IFxcJ1xcJyksXFxyXFxuICAgICAgICByZXNwb25zZVRleHQ6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5yZXNwb25zZVRleHQgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgcmVhZHlTdGF0ZTp4bWxodHRwLnJlYWR5U3RhdGUsXFxyXFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSA6IFxcJ1xcJyksXFxyXFxuICAgICAgICBzdGF0dXM6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5zdGF0dXMgOiAwKSxcXHJcXG4gICAgICAgIHN0YXR1c1RleHQ6KHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5zdGF0dXNUZXh0IDogXFwnXFwnKSxcXHJcXG4gICAgICAgIGZpbmFsVXJsOih4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuZmluYWxVcmwgOiBcXCdcXCcpXFxyXFxuICAgICAgfTtcXHJcXG4gICAgICBpZiAoZGV0YWlsc1tcXFwib25yZWFkeXN0YXRlY2hhbmdlXFxcIl0pIHtcXHJcXG4gICAgICAgIGRldGFpbHNbXFxcIm9ucmVhZHlzdGF0ZWNoYW5nZVxcXCJdKHJlc3BvbnNlU3RhdGUpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICBpZiAoeG1saHR0cC5yZWFkeVN0YXRlID09IDQpIHtcXHJcXG4gICAgICAgIGlmIChkZXRhaWxzW1xcXCJvbmxvYWRcXFwiXSAmJiB4bWxodHRwLnN0YXR1cyA+PSAyMDAgJiYgeG1saHR0cC5zdGF0dXMgPCAzMDApIHtcXHJcXG4gICAgICAgICAgZGV0YWlsc1tcXFwib25sb2FkXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAoZGV0YWlsc1tcXFwib25lcnJvclxcXCJdICYmICh4bWxodHRwLnN0YXR1cyA8IDIwMCB8fCB4bWxodHRwLnN0YXR1cyA+PSAzMDApKSB7XFxyXFxuICAgICAgICAgIGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH07XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgeG1saHR0cC5vcGVuKGRldGFpbHMubWV0aG9kLCBkZXRhaWxzLnVybCk7XFxyXFxuICAgIH0gY2F0Y2goZSkge1xcclxcbiAgICAgIGlmKGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSkge1xcclxcbiAgICAgICAgZGV0YWlsc1tcXFwib25lcnJvclxcXCJdKHtyZXNwb25zZVhNTDpcXCdcXCcscmVzcG9uc2VUZXh0OlxcJ1xcJyxyZWFkeVN0YXRlOjQscmVzcG9uc2VIZWFkZXJzOlxcJ1xcJyxzdGF0dXM6NDAzLHN0YXR1c1RleHQ6XFwnRm9yYmlkZGVuXFwnfSk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcbiAgICBpZiAoZGV0YWlscy5oZWFkZXJzKSB7XFxyXFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZXRhaWxzLmhlYWRlcnMpIHtcXHJcXG4gICAgICAgIHhtbGh0dHAuc2V0UmVxdWVzdEhlYWRlcihwcm9wLCBkZXRhaWxzLmhlYWRlcnNbcHJvcF0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB4bWxodHRwLnNlbmQoKHR5cGVvZihkZXRhaWxzLmRhdGEpICE9IFxcJ3VuZGVmaW5lZFxcJykgPyBkZXRhaWxzLmRhdGEgOiBudWxsKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gVXNlZCBmb3IgdGhlIG1lc3NhZ2UgbW9kdWxlIChzaG91bGQgcHJvYmFibHkgbW92ZSB0byBhbm90aGVyIHBsYWNlKVxcclxcbiAgLy8gSXQgcmVwbGFjZXMgYSBwcm9wZXJ0eSBpbiB0aGUgb2JqIHRvIGEgcHJlZGVmaW5lZCBmdW5jdGlvbiwgd2hlcmUgdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGNhbGxiYWNrSWQsIHRhcmdldCwgcmVmZXJlclxcclxcbiAgZnVuY3Rpb24gYmluZEZ1bmN0aW9uQ2FsbGJhY2tzKG9iaiwgZnVuYywgdGFyZ2V0LCByZWZlcmVyKSB7XFxyXFxuICAgIGZvciAoa2V5IGluIG9iaikge1xcclxcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXFxcIm9ialxcXCIpIHtcXHJcXG4gICAgICAgICAgYmluZEZ1bmN0aW9uQ2FsbGJhY2tzKG9ialtrZXldKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSBcXFwic3RyaW5nXFxcIikge1xcclxcbiAgICAgICAgICBpZiAob2JqW2tleV0uaW5kZXhPZihcXFwiQC8obWVzc2FnZS5jYWxsYmFjaykvXFxcIikgPT09IDApIHtcXHJcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tJZCA9IG9ialtrZXldLnNwbGl0KFxcXCJALyhtZXNzYWdlLmNhbGxiYWNrKS9cXFwiKVsxXTtcXHJcXG4gICAgICAgICAgICBvYmpba2V5XSA9IGJpbmQobnVsbCwgZnVuYywgY2FsbGJhY2tJZCwgdGFyZ2V0LCByZWZlcmVyKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBleHRlbmQob2JqLCBkZWZhdWx0cywgZGVlcCkge1xcclxcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIG9iai5cXFwiKTtcXHJcXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0cyAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIGRlZmF1bHRzLlxcXCIpO1xcclxcbiAgICBcXHJcXG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XFxyXFxuICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcXHJcXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBkZWZhdWx0c1trZXldID09PSBcXFwib2JqZWN0XFxcIiAmJiBkZWVwKSB7XFxyXFxuICAgICAgICAgIGV4dGVuZChvYmpba2V5XSwgZGVmYXVsdHNba2V5XSwgZGVlcCk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcclxcbiAgICAgICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBvYmo7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluQXJyYXkoa2V5LCBhcnIpIHtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmIChhcnJbaV0gPT09IGtleSkge1xcclxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBmYWxzZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbGlzdENsYXNzZXMoZWwpIHtcXHJcXG4gICAgaWYgKCFlbCB8fCAhZWwuY2xhc3NOYW1lKSByZXR1cm4gW107XFxyXFxuICAgIHJldHVybiBlbC5jbGFzc05hbWUuc3BsaXQoXFxcIiBcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xcclxcbiAgICB2YXIgY2xhc3NlcyA9IGxpc3RDbGFzc2VzKGVsKTtcXHJcXG4gICAgdmFyIGFkZExpc3QgPSBjbGFzc05hbWUuc3BsaXQoXFxcIiBcXFwiKTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhZGRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgaWYgKCFpbkFycmF5KGFkZExpc3RbaV0sIGNsYXNzZXMpKSB7XFxyXFxuICAgICAgICBlbC5jbGFzc05hbWUgKz0gXFxcIiBcXFwiICsgYWRkTGlzdFtpXTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xcclxcbiAgICB2YXIgY2xhc3NlcyA9IGxpc3RDbGFzc2VzKGVsKTtcXHJcXG4gICAgdmFyIHJlbW92ZUxpc3QgPSBjbGFzc05hbWUuc3BsaXQoXFxcIiBcXFwiKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBidWZmZXIgPSBbXTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoIWluQXJyYXkoY2xhc3Nlc1tpXSwgcmVtb3ZlTGlzdCkpIHtcXHJcXG4gICAgICAgIGJ1ZmZlci5wdXNoKGNsYXNzZXNbaV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lID0gYnVmZmVyLmpvaW4oXFxcIiBcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xcclxcbiAgICByZXR1cm4gaW5BcnJheShjbGFzc05hbWUsIGxpc3RDbGFzc2VzKGVsKSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGRlbGF5LCBvcHRpb25zKXtcXHJcXG4gICAgZnVuY3Rpb24gdGltZW91dCgpIHtcXHJcXG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogbmV3IERhdGU7XFxyXFxuICAgICAgdGltZXIgPSBudWxsO1xcclxcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XFxyXFxuICAgIH1cXHJcXG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdCwgdGltZXIgPSBudWxsLCBwcmV2aW91cyA9IDA7XFxyXFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcXHJcXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUsIGR0O1xcclxcbiAgICAgIFxcclxcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xcclxcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XFxyXFxuICAgICAgXFxyXFxuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcXHJcXG4gICAgICBkdCA9IGRlbGF5IC0gKG5vdyAtIHByZXZpb3VzKTtcXHJcXG4gICAgICBcXHJcXG4gICAgICBpZiAoZHQgPD0gMCkge1xcclxcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXHJcXG4gICAgICAgIHRpbWVyID0gbnVsbDtcXHJcXG4gICAgICAgIHByZXZpb3VzID0gbm93O1xcclxcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKCF0aW1lciAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xcclxcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVvdXQsIGR0KTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgfTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XFxyXFxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycikge1xcclxcbiAgICB2YXIgdW5pcXVlQXJyID0gW107XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoIWluQXJyYXkodW5pcXVlQXJyLCBhcnJbaV0pKSB7XFxyXFxuICAgICAgICB1bmlxdWVBcnIucHVzaChhcnJbaV0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHVuaXF1ZUFycjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xcclxcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXFxcLVxcXFxbXFxcXF1cXFxcL1xcXFx7XFxcXH1cXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFw/XFxcXC5cXFxcXFxcXFxcXFxeXFxcXCRcXFxcfF0vZywgXFxcIlxcXFxcXFxcJCZcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gdG9CbG9iKGJ5dGVzLCBjb250ZW50VHlwZSkge1xcclxcbiAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8IFxcXCJ0ZXh0L3BsYWluXFxcIjtcXHJcXG4gICAgdmFyIHNsaWNlU2l6ZSA9IDUxMjtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBieXRlc0xlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcXHJcXG4gICAgdmFyIHNsaWNlc0NvdW50ID0gTWF0aC5jZWlsKGJ5dGVzTGVuZ3RoIC8gc2xpY2VTaXplKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBieXRlQXJyYXlzID0gbmV3IEFycmF5KHNsaWNlc0NvdW50KTtcXHJcXG4gICAgXFxyXFxuICAgIGZvciAodmFyIHNsaWNlSW5kZXggPSAwOyBzbGljZUluZGV4IDwgc2xpY2VzQ291bnQ7ICsrc2xpY2VJbmRleCkge1xcclxcbiAgICAgIHZhciBiZWdpbiA9IHNsaWNlSW5kZXggKiBzbGljZVNpemU7XFxyXFxuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGJlZ2luICsgc2xpY2VTaXplLCBieXRlc0xlbmd0aCk7XFxyXFxuICAgICAgXFxyXFxuICAgICAgdmFyIHNsaWNlQnl0ZXMgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pO1xcclxcbiAgICAgIGZvciAodmFyIG9mZnNldCA9IGJlZ2luLCBpID0gMCA7IG9mZnNldCA8IGVuZDsgKytpLCArK29mZnNldCkge1xcclxcbiAgICAgICAgc2xpY2VCeXRlc1tpXSA9IGJ5dGVzW29mZnNldF0uY2hhckNvZGVBdCgwKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgYnl0ZUFycmF5c1tzbGljZUluZGV4XSA9IG5ldyBVaW50OEFycmF5KHNsaWNlQnl0ZXMpO1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbiAgICByZXR1cm4gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBjb250ZW50VHlwZSB9KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKGJsb2IpIHtcXHJcXG4gICAgaWYgKHN1cHBvcnQuY3JlYXRlT2JqZWN0VVJMKSB7XFxyXFxuICAgICAgaWYgKHN1cHBvcnQud2Via2l0VVJMKSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIHV3LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHRocm93IFxcXCJjcmVhdGVPYmplY3RVUkwgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciFcXFwiO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIHJldm9rZU9iamVjdFVSTCh1cmwpIHtcXHJcXG4gICAgaWYgKHN1cHBvcnQucmV2b2tlT2JqZWN0VVJMKSB7XFxyXFxuICAgICAgaWYgKHN1cHBvcnQud2Via2l0VVJMKSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcud2Via2l0VVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICByZXR1cm4gdXcuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICB0aHJvdyBcXFwicmV2b2tlT2JqZWN0VVJMIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIhXFxcIjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICAvLyBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XFxyXFxuICBmdW5jdGlvbiBnZXRSYW5kb21BcmJpdHJhcnkobWluLCBtYXgpIHtcXHJcXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIChpbmNsdWRlZCkgYW5kIG1heCAoZXhjbHVkZWQpXFxyXFxuICBmdW5jdGlvbiBnZXRSYW5kb21JbnQobWluLCBtYXgpIHtcXHJcXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLy8gUmV0dXJucyBhIHJhbmRvbSBzdHJpbmcgb2YgY2hhcmFjdGVycyBvZiBjaGFycyB3aXRoIHRoZSBsZW5ndGggb2YgbGVuZ3RoXFxyXFxuICBmdW5jdGlvbiBnZW5lcmF0ZVRva2VuKGNoYXJzLCBsZW5ndGgpIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBjaGFycyAhPT0gXFxcInN0cmluZ1xcXCIpIGNoYXJzID0gXFxcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5LV9cXFwiO1xcclxcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gXFxcIm51bWJlclxcXCIpIGxlbmd0aCA9IDY0O1xcclxcbiAgICBcXHJcXG4gICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xcclxcbiAgICBcXHJcXG4gICAgdmFyIHRva2VuID0gXFxcIlxcXCI7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICB0b2tlbiArPSBjaGFyc1tnZXRSYW5kb21JbnQoMCwgY2hhcnNMZW5ndGgpXTtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHRva2VuO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBlc2NhcGVFQ01BVmFyaWFibGUoa2V5LCBkZWZhdWx0S2V5KSB7XFxyXFxuICAgIGtleSA9IGtleS5yZXBsYWNlKC9bXjAtOWEtekEtWl9cXFxcJF0vZywgXFxcIlxcXCIpO1xcclxcbiAgICB3aGlsZSAoLyRbMC05XS9nLnRlc3Qoa2V5KSAmJiBrZXkubGVuZ3RoID4gMCkge1xcclxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJcXFwiKSByZXR1cm4gZGVmYXVsdEtleTtcXHJcXG4gICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDEpO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBrZXk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluZGV4T2ZBcnJheSh2YWx1ZSwgYXJyKSB7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICBpZiAoYXJyW2ldID09PSB2YWx1ZSkge1xcclxcbiAgICAgICAgcmV0dXJuIGk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiAtMTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0S2V5cyhvYmopIHtcXHJcXG4gICAgdmFyIGtleXMgPSBbXTtcXHJcXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKGtleSl7XFxyXFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxyXFxuICAgIH0pO1xcclxcbiAgICByZXR1cm4ga2V5cztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gc2V0UHJvcGVydHkodGFyZ2V0LCBwYXRoLCB2YWx1ZSwgY3JlYXRlUGF0aCkge1xcclxcbiAgICB2YXIgdG9rZW5zID0gcGF0aC5zcGxpdChcXFwiLlxcXCIpO1xcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIGlmICh0YXJnZXRbdG9rZW5zW2ldXSkge1xcclxcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3Rva2Vuc1tpXV07XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGlmIChjcmVhdGVQYXRoKSB7XFxyXFxuICAgICAgICAgIHRhcmdldFt0b2tlbnNbaV1dID0ge307XFxyXFxuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFt0b2tlbnNbaV1dO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgdGhyb3cgXFxcIlBhdGggXFxcIiArIHBhdGggKyBcXFwiIGRvZXMgbm90IGV4aXN0IGZvclxcXCIsIHRhcmdldDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgdGFyZ2V0W3Rva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1dID0gdmFsdWU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8qKlxcclxcbiAgKiBSZXBsYWNlcyBlYWNoIGZvcm1hdCBpdGVtIGluIGEgc3BlY2lmaWVkIHN0cmluZyB3aXRoIHRoZSB0ZXh0IGVxdWl2YWxlbnQgb2YgYSBjb3JyZXNwb25kaW5nIG9iamVjdFxcJ3MgdmFsdWUuXFxyXFxuICAqXFxyXFxuICAqIEBzdGF0aWNcXHJcXG4gICogQG1ldGhvZCBmb3JtYXRcXHJcXG4gICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBBIGNvbXBvc2l0ZSBmb3JtYXQgc3RyaW5nIHRoYXQgaW5jbHVkZXMgb25lIG9yIG1vcmUgZm9ybWF0IGl0ZW1zLlxcclxcbiAgKiBAcGFyYW0ge2FueX0gW2FyZ3NdKiBUaGUgb2JqZWN0IHRvIGZvcm1hdC5cXHJcXG4gICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHdpdGggZWFjaCBmb3JtYXQgaXRlbSBpbnNlcnRlZC5cXHJcXG4gICoqL1xcclxcbiAgLyoqXFxyXFxuICAqIFJlcGxhY2VzIGVhY2ggdG9rZW4gaW4gYSBzcGVjaWZpZWQgc3RyaW5nIHdpdGggdGhlIHRleHQgZXF1aXZhbGVudCBvZiBhIGNvcnJlc3BvbmRpbmcga2V5XFwncyB2YWx1ZS5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGZvcm1hdFxcclxcbiAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IEEgY29tcG9zaXRlIGZvcm1hdCBzdHJpbmcgdGhhdCBpbmNsdWRlcyBvbmUgb3IgbW9yZSB0b2tlbiBpdGVtcy5cXHJcXG4gICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUga2V5LCB2YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmUgcmVwbGFjaW5nIHRoZSB0b2tlbnMuXFxyXFxuICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXFxyXFxuICAqKi9cXHJcXG4gIGZ1bmN0aW9uIGZvcm1hdChmb3JtYXQpIHtcXHJcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXHJcXG4gICAgICB2YXIgbWFwID0gYXJndW1lbnRzWzFdO1xcclxcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvXFxcXCR7KFtcXFxcd1xcXFwtXFxcXF9dKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHsgXFxyXFxuICAgICAgICByZXR1cm4gdHlwZW9mIG1hcFtrZXldICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IG1hcFtrZXldIDogbWF0Y2g7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcclxcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgveyhcXFxcZCspfS9nLCBmdW5jdGlvbihtYXRjaCwgaW5kZXgpIHsgXFxyXFxuICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3NbaW5kZXhdICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGFyZ3NbaW5kZXhdIDogbWF0Y2g7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLyoqXFxyXFxuICAqIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudC5cXHJcXG4gICpcXHJcXG4gICogQHN0YXRpY1xcclxcbiAgKiBAbWV0aG9kIGdldEFic29sdXRlUG9zaXRpb25cXHJcXG4gICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQuXFxyXFxuICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgbGVmdCBhbmQgdG9wXFxyXFxuICAqICAgICAgICAgICAgICAgICAgd2hlcmUgdG9wIGFuZCBsZWZ0IHRlbGwgdGhlIHBvc2l0aW9uIG9mIHRoZVxcclxcbiAgKiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgZnJvbSB0aGUgdG9wLWxlZnQgY29ybmVyIGluIHBpeGVscy5cXHJcXG4gICoqL1xcclxcbiAgZnVuY3Rpb24gZ2V0QWJzb2x1dGVQb3NpdGlvbihlbCkge1xcclxcbiAgICB2YXIgbGVmdCA9IGVsLm9mZnNldExlZnQgfHwgMDtcXHJcXG4gICAgdmFyIHRvcCA9IGVsLm9mZnNldFRvcCB8fCAwO1xcclxcbiAgICBcXHJcXG4gICAgaWYgKGVsLm9mZnNldFBhcmVudCkge1xcclxcbiAgICAgIHZhciBwYXJlbnRBYnNvbHV0ZVBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihlbC5vZmZzZXRQYXJlbnQpO1xcclxcbiAgICAgIGxlZnQgKz0gcGFyZW50QWJzb2x1dGVQb3NpdGlvbi5sZWZ0O1xcclxcbiAgICAgIHRvcCArPSBwYXJlbnRBYnNvbHV0ZVBvc2l0aW9uLnRvcDtcXHJcXG4gICAgfVxcclxcbiAgICBcXHJcXG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTsgXFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC8vIEV4cG9zZSBmdW5jdGlvbnNcXHJcXG4gIGV4cG9ydHMuZ2V0QWJzb2x1dGVQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb247XFxyXFxuICBleHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcXHJcXG4gIGV4cG9ydHMuaGFzQ2xhc3MgPSBoYXNDbGFzcztcXHJcXG4gIGV4cG9ydHMucmVtb3ZlQ2xhc3MgPSByZW1vdmVDbGFzcztcXHJcXG4gIGV4cG9ydHMuYWRkQ2xhc3MgPSBhZGRDbGFzcztcXHJcXG4gIGV4cG9ydHMuZWFjaCA9IGVhY2g7XFxyXFxuICBleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcclxcbiAgZXhwb3J0cy5pbkFycmF5ID0gaW5BcnJheTtcXHJcXG4gIGV4cG9ydHMuYmluZCA9IGJpbmQ7XFxyXFxuICBleHBvcnRzLmFzeW5jQ2FsbCA9IGFzeW5jQ2FsbDtcXHJcXG4gIGV4cG9ydHMuZGVmaW5lTG9ja2VkUHJvcGVydHkgPSBkZWZpbmVMb2NrZWRQcm9wZXJ0eTtcXHJcXG4gIGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XFxyXFxuICBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xcclxcbiAgZXhwb3J0cy5ub3cgPSBub3c7XFxyXFxuICBleHBvcnRzLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XFxyXFxuICBleHBvcnRzLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcXHJcXG4gIGV4cG9ydHMubWFwID0gbWFwO1xcclxcbiAgZXhwb3J0cy5zZXRDb29raWUgPSBzZXRDb29raWU7XFxyXFxuICBleHBvcnRzLmdldENvb2tpZSA9IGdldENvb2tpZTtcXHJcXG4gIGV4cG9ydHMuZ2V0Q29va2llcyA9IGdldENvb2tpZXM7XFxyXFxuICBleHBvcnRzLmVuZHNXaXRoID0gZW5kc1dpdGg7XFxyXFxuICBleHBvcnRzLmluamVjdCA9IGluamVjdDtcXHJcXG4gIGV4cG9ydHMuaXNKU09OU3RyaW5nID0gaXNKU09OU3RyaW5nO1xcclxcbiAgZXhwb3J0cy54aHIgPSB4aHI7XFxyXFxuICBleHBvcnRzLmJ1aWxkQXJndW1lbnRMaXN0ID0gYnVpbGRBcmd1bWVudExpc3Q7XFxyXFxuICBleHBvcnRzLmJpbmRGdW5jdGlvbkNhbGxiYWNrcyA9IGJpbmRGdW5jdGlvbkNhbGxiYWNrcztcXHJcXG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xcclxcbiAgZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xcclxcbiAgZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xcclxcbiAgZXhwb3J0cy5yZW1vdmVEdXBsaWNhdGVzID0gcmVtb3ZlRHVwbGljYXRlcztcXHJcXG4gIGV4cG9ydHMuZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xcclxcbiAgZXhwb3J0cy50b0Jsb2IgPSB0b0Jsb2I7XFxyXFxuICBleHBvcnRzLmNyZWF0ZU9iamVjdFVSTCA9IGNyZWF0ZU9iamVjdFVSTDtcXHJcXG4gIGV4cG9ydHMucmV2b2tlT2JqZWN0VVJMID0gcmV2b2tlT2JqZWN0VVJMO1xcclxcbiAgZXhwb3J0cy5nZXRSYW5kb21BcmJpdHJhcnkgPSBnZXRSYW5kb21BcmJpdHJhcnk7XFxyXFxuICBleHBvcnRzLmdldFJhbmRvbUludCA9IGdldFJhbmRvbUludDtcXHJcXG4gIGV4cG9ydHMuZ2VuZXJhdGVUb2tlbiA9IGdlbmVyYXRlVG9rZW47XFxyXFxuICBleHBvcnRzLmVzY2FwZUVDTUFWYXJpYWJsZSA9IGVzY2FwZUVDTUFWYXJpYWJsZTtcXHJcXG4gIGV4cG9ydHMuaW5kZXhPZkFycmF5ID0gaW5kZXhPZkFycmF5O1xcclxcbiAgZXhwb3J0cy5nZXRLZXlzID0gZ2V0S2V5cztcXHJcXG4gIGV4cG9ydHMuc2V0UHJvcGVydHkgPSBzZXRQcm9wZXJ0eTtcXHJcXG4gIGV4cG9ydHMuZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eTtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vdXRpbHMuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdzdG9yYWdlL2xvY2FsU3RvcmFnZVxcJyxbXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKHV0aWxzKXtcXHJcXG4gIGZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaywgcHJlZmVyU3luYykge1xcclxcbiAgICB2YXIgaXRlbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XFxyXFxuICAgIGlmIChwcmVmZXJTeW5jKSB7XFxyXFxuICAgICAgY2FsbGJhY2soaXRlbSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdXRpbHMuYXN5bmNDYWxsKG51bGwsIGNhbGxiYWNrLCBpdGVtKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICByZXR1cm4ge1xcclxcbiAgICBzZXRJdGVtOiB1dGlscy5iaW5kKGxvY2FsU3RvcmFnZSwgbG9jYWxTdG9yYWdlLnNldEl0ZW0pLFxcclxcbiAgICBnZXRJdGVtOiBnZXRJdGVtLFxcclxcbiAgICByZW1vdmVJdGVtOiB1dGlscy5iaW5kKGxvY2FsU3RvcmFnZSwgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0pXFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3N0b3JhZ2UvbG9jYWxTdG9yYWdlLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnc3RvcmFnZS9jb29raWVzXFwnLFtcXFwidXRpbHNcXFwiXSwgZnVuY3Rpb24odXRpbHMpe1xcclxcbiAgZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlKSB7XFxyXFxuICAgIHV0aWxzLnNldENvb2tpZShwcmVmaXggKyBrZXksIHZhbHVlLCBudWxsLCBcXFwiL1xcXCIsIDEwMDAqMjQqNjAqNjAqMTAwMCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaywgcHJlZmVyU3luYykge1xcclxcbiAgICB2YXIgaXRlbSA9IHV0aWxzLmdldENvb2tpZShwcmVmaXggKyBrZXkpO1xcclxcbiAgICBpZiAocHJlZmVyU3luYykge1xcclxcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHV0aWxzLmFzeW5jQ2FsbChudWxsLCBjYWxsYmFjaywgaXRlbSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXkpIHtcXHJcXG4gICAgdXRpbHMuc2V0Q29va2llKHByZWZpeCArIGtleSwgXFxcIlxcXCIsIG51bGwsIFxcXCIvXFxcIiwgMCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBwcmVmaXggPSBcXFwieXRjZW50ZXIuXFxcIjtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgc2V0SXRlbTogc2V0SXRlbSxcXHJcXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSxcXHJcXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbVxcclxcbiAgfTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9zdG9yYWdlL2Nvb2tpZXMuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdjb25zb2xlXFwnLFtcXFwiZXhwb3J0c1xcXCIsIFxcXCJ1dGlsc1xcXCJdLCBmdW5jdGlvbihleHBvcnRzLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBzZXRFbmFibGVkKGIpIHtcXHJcXG4gICAgZW5hYmxlZCA9IGI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGxvZygpIHtcXHJcXG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4gZnVuY3Rpb24oKXt9O1xcclxcbiAgICByZXR1cm4gY29uc29sZS5sb2cuYmluZChjb25zb2xlLCBcXFwidXNlcnNjcmlwdFtcXFwiICsgc2Vzc2lvblRva2VuICsgXFxcIl1cXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXJyb3IoKSB7XFxyXFxuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcXHJcXG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlLCBcXFwidXNlcnNjcmlwdFtcXFwiICsgc2Vzc2lvblRva2VuICsgXFxcIl1cXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gd2FybigpIHtcXHJcXG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4gZnVuY3Rpb24oKXt9O1xcclxcbiAgICByZXR1cm4gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSwgXFxcInVzZXJzY3JpcHRbXFxcIiArIHNlc3Npb25Ub2tlbiArIFxcXCJdXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xcclxcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBmdW5jdGlvbigpe307XFxyXFxuICAgIHJldHVybiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSwgXFxcInVzZXJzY3JpcHRbXFxcIiArIHNlc3Npb25Ub2tlbiArIFxcXCJdXFxcIik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciBzZXNzaW9uVG9rZW4gPSAodHlwZW9mIGNvbnNvbGVTZXNzaW9uVG9rZW4gPT09IFxcXCJzdHJpbmdcXFwiID8gY29uc29sZVNlc3Npb25Ub2tlbiA6IHV0aWxzLmdlbmVyYXRlVG9rZW4obnVsbCwgOCkpO1xcclxcbiAgXFxyXFxuICB2YXIgZW5hYmxlZCA9IHRydWU7XFxyXFxuICBcXHJcXG4gIGV4cG9ydHMuc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xcclxcbiAgXFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShleHBvcnRzLCBcXFwibG9nXFxcIiwgZnVuY3Rpb24oKXt9LCBsb2cpO1xcclxcbiAgdXRpbHMuZGVmaW5lTG9ja2VkUHJvcGVydHkoZXhwb3J0cywgXFxcImVycm9yXFxcIiwgZnVuY3Rpb24oKXt9LCBlcnJvcik7XFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShleHBvcnRzLCBcXFwid2FyblxcXCIsIGZ1bmN0aW9uKCl7fSwgd2Fybik7XFxyXFxuICB1dGlscy5kZWZpbmVMb2NrZWRQcm9wZXJ0eShleHBvcnRzLCBcXFwiZGVidWdcXFwiLCBmdW5jdGlvbigpe30sIGRlYnVnKTtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vY29uc29sZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3N0b3JhZ2UvYnJvd3NlclxcJyxbXFxcIi4uL2hlbHBlci9zdXBwb3J0XFxcIiwgXFxcIi4vbG9jYWxTdG9yYWdlXFxcIiwgXFxcIi4vY29va2llc1xcXCIsIFxcXCJjb25zb2xlXFxcIl0sIGZ1bmN0aW9uKHN1cHBvcnQsIGxvY2FsU3RvcmFnZSwgY29va2llcyl7XFxyXFxuICBpZiAoc3VwcG9ydC5sb2NhbFN0b3JhZ2UpIHtcXHJcXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcXHJcXG4gIH0gZWxzZSB7XFxyXFxuICAgIHJldHVybiBjb29raWVzO1xcclxcbiAgfVxcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3N0b3JhZ2UvYnJvd3Nlci5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3N0b3JhZ2UvdXNlcnNjcmlwdFxcJyxbXFxcIi4uL2hlbHBlci9zdXBwb3J0XFxcIiwgXFxcIi4vYnJvd3NlclxcXCIsIFxcXCIuLi91dGlsc1xcXCJdLCBmdW5jdGlvbihzdXBwb3J0LCBicm93c2VyLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBzZXRJdGVtKGtleSwgdmFsdWUpIHtcXHJcXG4gICAgR01fc2V0VmFsdWUoa2V5LCB2YWx1ZSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaywgcHJlZmVyU3luYykge1xcclxcbiAgICB2YXIgaXRlbSA9IEdNX2dldFZhbHVlKGtleSk7XFxyXFxuICAgIGlmIChwcmVmZXJTeW5jKSB7XFxyXFxuICAgICAgY2FsbGJhY2soaXRlbSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdXRpbHMuYXN5bmNDYWxsKG51bGwsIGNhbGxiYWNrLCBpdGVtKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVJdGVtKGtleSkge1xcclxcbiAgICBHTV9kZWxldGVWYWx1ZShrZXkpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBpZiAoc3VwcG9ydC5HcmVhc2Vtb25rZXkpIHtcXHJcXG4gICAgcmV0dXJuIHtcXHJcXG4gICAgICBzZXRJdGVtOiBzZXRJdGVtLFxcclxcbiAgICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0sXFxyXFxuICAgICAgZ2V0SXRlbTogZ2V0SXRlbVxcclxcbiAgICB9O1xcclxcbiAgfSBlbHNlIHtcXHJcXG4gICAgcmV0dXJuIGJyb3dzZXI7XFxyXFxuICB9XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vc3RvcmFnZS91c2Vyc2NyaXB0LmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnc3RvcmFnZVxcJyxbXFxcImV4cG9ydHNcXFwiLCBcXFwic3RvcmFnZS91c2Vyc2NyaXB0XFxcIiwgXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKGV4cG9ydHMsIHN0b3JhZ2VIYW5kbGVyLCB1dGlscyl7XFxyXFxuICBmdW5jdGlvbiBzZXRJdGVtKGtleSwgdmFsdWUpIHtcXHJcXG4gICAgY2FjaGVba2V5XSA9IHZhbHVlO1xcclxcbiAgICBzdG9yYWdlSGFuZGxlci5zZXRJdGVtKGtleSwgdmFsdWUpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZW1vdmVJdGVtKGtleSkge1xcclxcbiAgICBkZWxldGUgY2FjaGVba2V5XTtcXHJcXG4gICAgc3RvcmFnZUhhbmRsZXIucmVtb3ZlSXRlbShrZXkpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiBnZXRJdGVtQ2FsbGJhY2soY2FsbGJhY2ssIGtleSwgdmFsdWUpIHtcXHJcXG4gICAgY2FjaGVba2V5XSA9IHZhbHVlO1xcclxcbiAgICBjYWxsYmFjayhjYWNoZVtrZXldKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0SXRlbShrZXksIGNhbGxiYWNrLCBzeW5jKSB7XFxyXFxuICAgIGlmICghKGtleSBpbiBjYWNoZSkpIHtcXHJcXG4gICAgICBzdG9yYWdlSGFuZGxlci5nZXRJdGVtKGtleSwgdXRpbHMuYmluZChudWxsLCBnZXRJdGVtQ2FsbGJhY2ssIGNhbGxiYWNrLCBrZXkpKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICBpZiAoc3luYykge1xcclxcbiAgICAgICAgY2FsbGJhY2soY2FjaGVba2V5XSk7XFxyXFxuICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdXRpbHMuYXN5bmNDYWxsKG51bGwsIGNhbGxiYWNrLCBjYWNoZVtrZXldKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIGNhY2hlID0ge307XFxyXFxuICBcXHJcXG4gIC8qIEV4cG9ydHMgKi9cXHJcXG4gIGV4cG9ydHMuc2V0SXRlbSA9IHNldEl0ZW07XFxyXFxuICBleHBvcnRzLnJlbW92ZUl0ZW0gPSByZW1vdmVJdGVtO1xcclxcbiAgZXhwb3J0cy5nZXRJdGVtID0gZ2V0SXRlbTtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIGV4cG9ydHM7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vc3RvcmFnZS5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ1VzZXJQcm94eS9DdXN0b21FdmVudFxcJyxbXFxcInV0aWxzXFxcIl0sIGZ1bmN0aW9uKHV0aWxzKXtcXHJcXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XFxyXFxuICAgIGlmICghZXZlbnRzW2V2ZW50XSkge1xcclxcbiAgICAgIC8vIENyZWF0aW5nIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIGV2ZW50XFxyXFxuICAgICAgZXZlbnRzW2V2ZW50XSA9IFtdO1xcclxcbiAgICAgIFxcclxcbiAgICAgIGRvY0xpc3RlbmVyc1tldmVudF0gPSB1dGlscy5iaW5kKG51bGwsIGV2ZW50TGlzdGVuZXIsIGV2ZW50LCBldmVudHNbZXZlbnRdKTtcXHJcXG4gICAgICBcXHJcXG4gICAgICAvLyBBZGRpbmcgdGhlIGV2ZW50IGxpc3RlbmVyLlxcclxcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBkb2NMaXN0ZW5lcnNbZXZlbnRdLCBmYWxzZSk7XFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIC8vIEFkZGluZyBsaXN0ZW5lciB0byBhcnJheS5cXHJcXG4gICAgZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcXHJcXG4gICAgaWYgKGV2ZW50IGluIGV2ZW50cykge1xcclxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudHNbZXZlbnRdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICBpZiAoZXZlbnRzW2V2ZW50XVtpXSA9PT0gbGlzdGVuZXIpIHtcXHJcXG4gICAgICAgICAgZXZlbnRzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XFxyXFxuICAgICAgICAgIGktLTsgbGVuLS07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmIChldmVudHNbZXZlbnRdLmxlbmd0aCA9PT0gMCkge1xcclxcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGRvY0xpc3RlbmVyc1tldmVudF0sIGZhbHNlKTtcXHJcXG4gICAgICAgIFxcclxcbiAgICAgICAgZXZlbnRzW2V2ZW50XSA9IG51bGw7XFxyXFxuICAgICAgICBkb2NMaXN0ZW5lcnNbZXZlbnRdID0gbnVsbDtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLCBlKSB7XFxyXFxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFBhcnNlIHRoZSBkZXRhaWwgdG8gdGhlIG9yaWdpbmFsIG9iamVjdC5cXHJcXG4gICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGUuZGV0YWlsKTtcXHJcXG4gICAgXFxyXFxuICAgIGlmICh0eXBlb2YgZGF0YS5kZXRhaWwgPT09IFxcXCJvYmplY3RcXFwiICYmIGRhdGEudG9rZW4gIT09IHRva2VuKSB7XFxyXFxuICAgICAgdmFyIGRldGFpbCA9IGRhdGEuZGV0YWlsO1xcclxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIC8vIENhbGwgdGhlIGxpc3RlbmVyIHdpdGggdGhlIGV2ZW50IG5hbWUgYW5kIHRoZSBwYXJzZWQgZGV0YWlsLlxcclxcbiAgICAgICAgbGlzdGVuZXJzW2ldKGRldGFpbCk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIFxcclxcbiAgICAgIC8vIFByZXZlbnQgcHJvcGFnYXRpb25cXHJcXG4gICAgICBpZiAoZSAmJiB0eXBlb2YgZS5zdG9wUHJvcGFnYXRpb24gPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudCwgZGV0YWlsKSB7XFxyXFxuICAgIC8vIENyZWF0aW5nIHRoZSBldmVudFxcclxcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFxcXCJDdXN0b21FdmVudFxcXCIpO1xcclxcbiAgICBlLmluaXRDdXN0b21FdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSwgSlNPTi5zdHJpbmdpZnkoeyBkZXRhaWw6IGRldGFpbCwgdG9rZW46IHRva2VuIH0pKTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIEZpcmluZyB0aGUgZXZlbnRcXHJcXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZSk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHZhciB0b2tlbiA9IHV0aWxzLmdlbmVyYXRlVG9rZW4oKTsgLy8gVGhlIHRva2VuIGlzIHVzZWQgdG8gaWRlbnRpZnkgaXRzZWxmIGFuZCBwcmV2ZW50IGNhbGxpbmcgaXRzIG93biBsaXN0ZW5lcnMuXFxyXFxuICB2YXIgZXZlbnRzID0ge307XFxyXFxuICB2YXIgZG9jTGlzdGVuZXJzID0ge307XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXFxyXFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXFxyXFxuICAgIGZpcmVFdmVudDogZmlyZUV2ZW50XFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L1VzZXJQcm94eS9DdXN0b21FdmVudC5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ1VzZXJQcm94eS9NZXNzYWdlXFwnLFtcXFwidXRpbHNcXFwiXSwgZnVuY3Rpb24odXRpbHMpe1xcclxcbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcXHJcXG4gICAgaW5pdE1lc3NhZ2UoKTsgLy8gSW5pdCB0aGUgbWVzc2FnZSBldmVudCBsaXN0ZW5lciBpZiBub3QgYWxyZWFkeSBpbml0aWFsaXplZC5cXHJcXG4gICAgXFxyXFxuICAgIGlmICghZXZlbnRzW2V2ZW50XSkgZXZlbnRzW2V2ZW50XSA9IFtdO1xcclxcbiAgICBcXHJcXG4gICAgLy8gQmluZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbGlzdGVuZXIgYXMgYW4gYXJndW1lbnQuXFxyXFxuICAgIHZhciBib3VuZExpc3RlbmVyID0gdXRpbHMuYmluZChudWxsLCBsaXN0ZW5lciwgZXZlbnQpO1xcclxcbiAgICBcXHJcXG4gICAgLy8gQWRkIHRoZSBib3VuZExpc3RlbmVyIHRvIHRoZSBldmVudFxcclxcbiAgICBldmVudHNbZXZlbnRdLnB1c2goYm91bmRMaXN0ZW5lcik7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudCwgZGV0YWlsKSB7XFxyXFxuICAgIHdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7IHRva2VuOiB0b2tlbiwgZXZlbnQ6IGV2ZW50LCBkZXRhaWw6IGRldGFpbCB9KSwgXFxcIipcXFwiKTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbWVzc2FnZUxpc3RlbmVyKGUpIHtcXHJcXG4gICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xcclxcbiAgICBcXHJcXG4gICAgLy8gUGFyc2UgdGhlIGRldGFpbCB0byB0aGUgb3JpZ2luYWwgb2JqZWN0LlxcclxcbiAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcXHJcXG4gICAgXFxyXFxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSByZXRyaWV2ZWQgaW5mb3JtYXRpb24gaXMgY29ycmVjdCBhbmQgdGhhdCBpdCBkaWRuXFwndCBjYWxsIGl0c2VsZi5cXHJcXG4gICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50ID09PSBcXFwic3RyaW5nXFxcIiAmJiB0eXBlb2YgZGF0YS5kZXRhaWwgPT09IFxcXCJvYmplY3RcXFwiICYmIGRhdGEudG9rZW4gIT09IHRva2VuKSB7XFxyXFxuICAgICAgXFxyXFxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IGxpc3RlbmVyIGZvciBkYXRhLmV2ZW50LlxcclxcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGV2ZW50c1tkYXRhLmV2ZW50XSkpIHtcXHJcXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZGF0YS5ldmVudF07XFxyXFxuICAgICAgICBcXHJcXG4gICAgICAgIHZhciBkZXRhaWwgPSBkYXRhLmRldGFpbDtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgbGlzdGVuZXJzKGRldGFpbCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIFxcclxcbiAgICAgICAgLy8gUHJldmVudCBwcm9wYWdhdGlvbiBvbmx5IGlmIGV2ZXJ5dGhpbmcgd2VudCB3ZWxsLlxcclxcbiAgICAgICAgaWYgKGUgJiYgdHlwZW9mIGUuc3RvcFByb3BhZ2F0aW9uID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGluaXRNZXNzYWdlKCkge1xcclxcbiAgICBpZiAoIW1lc3NhZ2VFdmVudEFkZGVkKSB7XFxyXFxuICAgICAgLy8gQWRkaW5nIHRoZSBtZXNzYWdlIGV2ZW50IGxpc3RlbmVyLlxcclxcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIiwgbWVzc2FnZUxpc3RlbmVyLCBmYWxzZSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIG1lc3NhZ2VFdmVudEFkZGVkID0gZmFsc2U7XFxyXFxuICB2YXIgdG9rZW4gPSB1dGlscy5nZW5lcmF0ZVRva2VuKCk7IC8vIFRoZSB0b2tlbiBpcyB1c2VkIHRvIGlkZW50aWZ5IGl0c2VsZiBhbmQgcHJldmVudCBjYWxsaW5nIGl0cyBvd24gbGlzdGVuZXJzLlxcclxcbiAgXFxyXFxuICB2YXIgZXZlbnRzID0ge307XFxyXFxuICBcXHJcXG4gIHJldHVybiB7XFxyXFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXFxyXFxuICAgIGZpcmVFdmVudDogZmlyZUV2ZW50XFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L1VzZXJQcm94eS9NZXNzYWdlLmpzXCIpO1xuXG4iLAogICAgImV2YWwoXCJkZWZpbmUoXFwnVXNlclByb3h5L3N1cHBvcnRcXCcsW10sIGZ1bmN0aW9uKCl7XFxyXFxuICBmdW5jdGlvbiBjdXN0b21FdmVudCgpIHtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFxcJ0N1c3RvbUV2ZW50XFwnKTtcXHJcXG4gICAgICBpZiAoZSAmJiB0eXBlb2YgZS5pbml0Q3VzdG9tRXZlbnQgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KG1vZCwgdHJ1ZSwgdHJ1ZSwgeyBtb2Q6IG1vZCB9KTtcXHJcXG4gICAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH0gY2F0Y2ggKGUpIHtcXHJcXG4gICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgdmFyIG1vZCA9IFxcXCJzdXBwb3J0LnRlc3RcXFwiO1xcclxcbiAgXFxyXFxuICByZXR1cm4ge1xcclxcbiAgICBDdXN0b21FdmVudDogY3VzdG9tRXZlbnRcXHJcXG4gIH07XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vVXNlclByb3h5L3N1cHBvcnQuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdVc2VyUHJveHkvbWVtRnVuY3Rpb25cXCcsW1xcXCJ1dGlsc1xcXCIsIFxcXCIuL0N1c3RvbUV2ZW50XFxcIiwgXFxcIi4vTWVzc2FnZVxcXCIsIFxcXCIuL3N1cHBvcnRcXFwiXSwgZnVuY3Rpb24odXRpbHMsIGN1c3RvbUV2ZW50LCBtZXNzYWdlLCBzdXBwb3J0KXtcXHJcXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaiwgdG9rZW4sIHR5cGUpIHtcXHJcXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgdXRpbHMuZWFjaChvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXHJcXG4gICAgICAgICAgb2JqW2tleV0gPSBwYXJzZU9iamVjdCh2YWx1ZSwgdG9rZW4sIHR5cGUpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICAgIG9ialtrZXldID0gcGFyc2VTdHJpbmcodmFsdWUpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICAgICAgdmFyIGlkID0gY2FjaGUucHVzaCh2YWx1ZSkgLSAxO1xcclxcbiAgICAgICAgICBvYmpba2V5XSA9IFxcXCIke1xcXCIgKyB0b2tlbiArIFxcXCIvXFxcIiArIHR5cGUgKyBcXFwiL1xcXCIgKyBpZCArIFxcXCJ9XFxcIjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgb2JqID0gcGFyc2VTdHJpbmcob2JqKTtcXHJcXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxyXFxuICAgICAgdmFyIGlkID0gY2FjaGUucHVzaChvYmopIC0gMTtcXHJcXG4gICAgICBvYmogPSBcXFwiJHtcXFwiICsgdG9rZW4gKyBcXFwiL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwifVxcXCI7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIG9iajtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XFxyXFxuICAgIGlmICgvXlxcXFwkW1xcXFxcXFxcXSpcXFxceyhbMC05YS16QS1aXFxcXC5cXFxcLV9cXFxcL1xcXFxcXFxcXSspXFxcXH0kL2cudGVzdChzdHIpKSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCIkXFxcXFxcXFxcXFwiICsgc3RyLnN1YnN0cmluZygxKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gc3RyO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiByZXN0b3JlU3RyaW5nKHN0ciwgdG9rZW4sIHR5cGUpIHtcXHJcXG4gICAgaWYgKC9eXFxcXCRcXFxceyhbMC05YS16QS1aXFxcXC5cXFxcLV9dKylcXFxcLyhbMC05YS16QS1aXFxcXC5cXFxcLV9dKylcXFxcLyhbMC05XSspXFxcXH0kL2cudGVzdChzdHIpKSB7XFxyXFxuICAgICAgdmFyIHBhcnNlZCA9IHN0ci5zdWJzdHJpbmcoMiwgc3RyLmxlbmd0aCAtIDEpLnNwbGl0KFxcXCIvXFxcIik7IC8vIFxcXCIgKyB0b2tlbiArIFxcXCIvXFxcIiArIHR5cGUgKyBcXFwiL1xcXCIgKyBpZCArIFxcXCJcXHJcXG4gICAgICB2YXIgaWQgPSBwYXJzZUludChwYXJzZWRbMl0sIDEwKTtcXHJcXG4gICAgICBpZiAocGFyc2VkWzBdID09PSB0b2tlbiAmJiBwYXJzZWRbMV0gPT09IHR5cGUpIHtcXHJcXG4gICAgICAgIHJldHVybiBjYWNoZVtpZF07XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJldHVybiB1dGlscy5iaW5kKG51bGwsIGZ1bmN0aW9uUGxhY2Vob2xkZXIsIHBhcnNlZFswXSArIFxcXCItXFxcIiArIHBhcnNlZFsxXSwgaWQpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSBlbHNlIGlmICgvXlxcXFwkW1xcXFxcXFxcXStcXFxceyhbMC05YS16QS1aXFxcXC5cXFxcLV9cXFxcL1xcXFxcXFxcXSspXFxcXH0kL2cudGVzdChzdHIpKSB7XFxyXFxuICAgICAgcmV0dXJuIFxcXCIkXFxcIiArIHN0ci5zdWJzdHJpbmcoMik7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHN0cjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gcmVzdG9yZU9iamVjdChvYmosIHRva2VuLCB0eXBlKSB7XFxyXFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcXFwib2JqZWN0XFxcIikge1xcclxcbiAgICAgIHV0aWxzLmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbHVlKXtcXHJcXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxyXFxuICAgICAgICAgIG9ialtrZXldID0gcmVzdG9yZU9iamVjdCh2YWx1ZSwgdG9rZW4sIHR5cGUpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICAgIG9ialtrZXldID0gcmVzdG9yZVN0cmluZyh2YWx1ZSwgdG9rZW4sIHR5cGUpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXFxcIkZ1bmN0aW9uIHdhcyBmb3VuZCFcXFwiKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgcmV0dXJuIHJlc3RvcmVTdHJpbmcodmFsdWUsIHRva2VuLCB0eXBlKTtcXHJcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXHJcXG4gICAgICB0aHJvdyBFcnJvcihcXFwiRnVuY3Rpb24gd2FzIGZvdW5kIVxcXCIpO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBvYmo7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uUGxhY2Vob2xkZXIoZXZlbnQsIGlkKSB7XFxyXFxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcXHJcXG4gICAgaWYgKHN1cHBvcnQuQ3VzdG9tRXZlbnQpIHtcXHJcXG4gICAgICByZXR1cm4gY3VzdG9tRXZlbnQuZmlyZUV2ZW50KGV2ZW50LCB7IGNhbGxiYWNrSWQ6IGlkLCBhcmdzOiBhcmdzLCBtZW06IHRydWUgfSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgcmV0dXJuIG1lc3NhZ2UuZmlyZUV2ZW50KGV2ZW50LCB7IGNhbGxiYWNrSWQ6IGlkLCBhcmdzOiBhcmdzLCBtZW06IHRydWUgfSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVGdW5jdGlvbihpZCkge1xcclxcbiAgICByZXR1cm4gY2FjaGVbaWRdO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICB2YXIgY2FjaGUgPSBbXTtcXHJcXG4gIFxcclxcbiAgcmV0dXJuIHtcXHJcXG4gICAgcGFyc2VPYmplY3Q6IHBhcnNlT2JqZWN0LFxcclxcbiAgICByZXN0b3JlT2JqZWN0OiByZXN0b3JlT2JqZWN0LFxcclxcbiAgICBnZXRDYWNoZUZ1bmN0aW9uOiBnZXRDYWNoZUZ1bmN0aW9uXFxyXFxuICB9O1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L1VzZXJQcm94eS9tZW1GdW5jdGlvbi5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ1VzZXJQcm94eS9Db25uZWN0aW9uXFwnLFtcXFwiLi9DdXN0b21FdmVudFxcXCIsIFxcXCIuL01lc3NhZ2VcXFwiLCBcXFwidXRpbHNcXFwiLCBcXFwiLi9zdXBwb3J0XFxcIiwgXFxcIi4vbWVtRnVuY3Rpb25cXFwiXSwgZnVuY3Rpb24oY3VzdG9tRXZlbnQsIG1lc3NhZ2UsIHV0aWxzLCBzdXBwb3J0LCBtZW0pe1xcclxcbiAgZnVuY3Rpb24gbGlzdGVuZXJQcm94eShmdW5jdGlvbnMsIHRva2VuLCB0eXBlLCBkZXRhaWwpIHtcXHJcXG4gICAgc2V0VGltZW91dCh1dGlscy5iaW5kKG51bGwsIGxpc3RlbmVyLCBmdW5jdGlvbnMsIHRva2VuLCB0eXBlLCBkZXRhaWwpLCA0KTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgZnVuY3Rpb24gbGlzdGVuZXIoZnVuY3Rpb25zLCB0b2tlbiwgdHlwZSwgZGV0YWlsKSB7XFxyXFxuICAgIHZhciBrZXlzID0gdXRpbHMuZ2V0S2V5cyhmdW5jdGlvbnMpO1xcclxcbiAgICB2YXIgaW5kZXggPSB1dGlscy5pbmRleE9mQXJyYXkoZGV0YWlsLm1ldGhvZCwga2V5cyk7XFxyXFxuICAgIGlmIChpbmRleCA+IC0xKSB7XFxyXFxuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uc1trZXlzW2luZGV4XV0uYXBwbHkobnVsbCwgbWVtLnJlc3RvcmVPYmplY3QoZGV0YWlsLmFyZ3MsIHRva2VuLCB0eXBlKSk7XFxyXFxuICAgICAgaWYgKHR5cGVvZiBkZXRhaWwuaWQgPT09IFxcXCJudW1iZXJcXFwiKSB7XFxyXFxuICAgICAgICB2YXIgbWVtUmVzdWx0ID0gbWVtLnBhcnNlT2JqZWN0KHJlc3VsdCwgdG9rZW4sIHR5cGUpO1xcclxcbiAgICAgICAgdmFyIGRldGFpbCA9IHsgY2FsbGJhY2tJZDogZGV0YWlsLmlkLCBhcmdzOiBbIG1lbVJlc3VsdCBdIH07XFxyXFxuICAgICAgICBpZiAoc3VwcG9ydC5DdXN0b21FdmVudCkge1xcclxcbiAgICAgICAgICBjdXN0b21FdmVudC5maXJlRXZlbnQodG9rZW4gKyBcXFwiLXBhZ2VcXFwiLCBkZXRhaWwpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgbWVzc2FnZS5hZGRFdmVudExpc3RlbmVyKHRva2VuICsgXFxcIi1wYWdlXFxcIiwgZGV0YWlsKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgdGhyb3cgXFxcIk1ldGhvZCBcXFwiICsgZGV0YWlsLm1ldGhvZCArIFxcXCIgaGFzIG5vdCBiZWVuIHNldCFcXFwiO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZ1bmN0aW9uIENvbm5lY3Rpb24ocGFnZVByb3h5KSB7XFxyXFxuICAgIHRoaXMudG9rZW4gPSB1dGlscy5nZW5lcmF0ZVRva2VuKCk7XFxyXFxuICAgIHRoaXMuZnVuY3Rpb25zID0ge307XFxyXFxuICAgIHRoaXMubmFtZXNwYWNlID0gXFxcIlVzZXJQcm94eVxcXCI7XFxyXFxuICAgIHRoaXMucGFnZVByb3h5ID0gcGFnZVByb3h5O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRGdW5jdGlvbnMgPSBmdW5jdGlvbiBzZXRGdW5jdGlvbnMoZnVuY3Rpb25zKSB7XFxyXFxuICAgIHRoaXMuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5zZXROYW1lc3BhY2UgPSBmdW5jdGlvbiBzZXRGdW5jdGlvbnMobmFtZXNwYWNlKSB7XFxyXFxuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbiBpbmplY3QoY29kZSkge1xcclxcbiAgICB2YXIgcGFyZW50ID0gKGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xcclxcbiAgICBpZiAoIXBhcmVudCkgdGhyb3cgXFxcIlBhcmVudCB3YXMgbm90IGZvdW5kIVxcXCI7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIilcXHJcXG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJ0ZXh0L2phdmFzY3JpcHRcXFwiKTtcXHJcXG5cXHJcXG4gICAgdGhpcy5jb25uZWN0KCk7XFxyXFxuICAgIFxcclxcbiAgICB2YXIgYXJncyA9IFsgZmFsc2UsIHRoaXMudG9rZW4sIHV0aWxzLmdldEtleXModGhpcy5mdW5jdGlvbnMpIF07XFxyXFxuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcXHJcXG4gICAgXFxyXFxuICAgIHZhciBjb250ZW50ID0gXFxcIihcXFwiICsgY29kZSArIFxcXCIpKFxcXCIgKyB1dGlscy5idWlsZEFyZ3VtZW50TGlzdC5hcHBseShudWxsLCBhcmdzKSArIFxcXCIpO1xcXCI7XFxyXFxuICAgIFxcclxcbiAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xcclxcbiAgICBcXHJcXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XFxyXFxuICAgIHBhcmVudC5yZW1vdmVDaGlsZChzY3JpcHQpO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdCgpIHtcXHJcXG4gICAgaWYgKHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uTGlzdGVuZXIpIHRoaXMuZGlzY29ubmVjdCgpO1xcclxcbiAgICBcXHJcXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lciA9IHV0aWxzLmJpbmQobnVsbCwgbGlzdGVuZXJQcm94eSwgdGhpcy5mdW5jdGlvbnMsIHRoaXMudG9rZW4sIFxcXCJjb250ZW50XFxcIik7XFxyXFxuICAgIGlmIChzdXBwb3J0LkN1c3RvbUV2ZW50KSB7XFxyXFxuICAgICAgY3VzdG9tRXZlbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnRva2VuICsgXFxcIi1jb250ZW50XFxcIiwgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lcik7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgbWVzc2FnZS5hZGRFdmVudExpc3RlbmVyKHRoaXMudG9rZW4gKyBcXFwiLWNvbnRlbnRcXFwiLCB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbkxpc3RlbmVyKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdCgpIHtcXHJcXG4gICAgaWYgKCF0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbkxpc3RlbmVyKSByZXR1cm47XFxyXFxuICAgIGlmIChzdXBwb3J0LkN1c3RvbUV2ZW50KSB7XFxyXFxuICAgICAgY3VzdG9tRXZlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLnRva2VuICsgXFxcIi1jb250ZW50XFxcIiwgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25MaXN0ZW5lcik7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgbWVzc2FnZS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMudG9rZW4gKyBcXFwiLWNvbnRlbnRcXFwiLCB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbkxpc3RlbmVyKTtcXHJcXG4gICAgfVxcclxcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbkxpc3RlbmVyID0gbnVsbDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgcmV0dXJuIENvbm5lY3Rpb247XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vVXNlclByb3h5L0Nvbm5lY3Rpb24uanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCdleHRlbnNpb25zLWNvbm5lY3Rpb24vdXNlcnNjcmlwdFxcJyxbXSwgZnVuY3Rpb24oKXtcXHJcXG4gIGZ1bmN0aW9uIGVtcHR5KCkgeyB9XFxyXFxuICByZXR1cm4ge1xcclxcbiAgICBzZXRQYWdlQ29ubmVjdGlvbjogZW1wdHlcXHJcXG4gIH07XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0vZXh0ZW5zaW9ucy1jb25uZWN0aW9uL3VzZXJzY3JpcHQuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCd4aHIvYnJvd3NlclxcJyxbXSwgZnVuY3Rpb24oKXtcXHJcXG4gIGZ1bmN0aW9uIHhocihkZXRhaWxzKSB7XFxyXFxuICAgIHZhciB4bWxodHRwO1xcclxcbiAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxyXFxuICAgICAgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgfVxcclxcbiAgICB4bWxodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XFxyXFxuICAgICAgdmFyIHJlc3BvbnNlU3RhdGUgPSB7XFxyXFxuICAgICAgICByZXNwb25zZVhNTDogXFwnXFwnLFxcclxcbiAgICAgICAgcmVzcG9uc2VUZXh0OiAoeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLnJlc3BvbnNlVGV4dCA6IFxcJ1xcJyksXFxyXFxuICAgICAgICByZWFkeVN0YXRlOiB4bWxodHRwLnJlYWR5U3RhdGUsXFxyXFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6ICh4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCA/IHhtbGh0dHAuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgOiBcXCdcXCcpLFxcclxcbiAgICAgICAgc3RhdHVzOiAoeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLnN0YXR1cyA6IDApLFxcclxcbiAgICAgICAgc3RhdHVzVGV4dDogKHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ID8geG1saHR0cC5zdGF0dXNUZXh0IDogXFwnXFwnKSxcXHJcXG4gICAgICAgIGZpbmFsVXJsOiAoeG1saHR0cC5yZWFkeVN0YXRlID09IDQgPyB4bWxodHRwLmZpbmFsVXJsIDogXFwnXFwnKVxcclxcbiAgICAgIH07XFxyXFxuICAgICAgaWYgKGRldGFpbHNbXFxcIm9ucmVhZHlzdGF0ZWNoYW5nZVxcXCJdKSB7XFxyXFxuICAgICAgICBkZXRhaWxzW1xcXCJvbnJlYWR5c3RhdGVjaGFuZ2VcXFwiXShyZXNwb25zZVN0YXRlKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0KSB7XFxyXFxuICAgICAgICBpZiAoZGV0YWlsc1tcXFwib25sb2FkXFxcIl0gJiYgeG1saHR0cC5zdGF0dXMgPj0gMjAwICYmIHhtbGh0dHAuc3RhdHVzIDwgMzAwKSB7XFxyXFxuICAgICAgICAgIGRldGFpbHNbXFxcIm9ubG9hZFxcXCJdKHJlc3BvbnNlU3RhdGUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGRldGFpbHNbXFxcIm9uZXJyb3JcXFwiXSAmJiAoeG1saHR0cC5zdGF0dXMgPCAyMDAgfHwgeG1saHR0cC5zdGF0dXMgPj0gMzAwKSkge1xcclxcbiAgICAgICAgICBkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0ocmVzcG9uc2VTdGF0ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9O1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgIHhtbGh0dHAub3BlbihkZXRhaWxzLm1ldGhvZCwgZGV0YWlscy51cmwpO1xcclxcbiAgICB9IGNhdGNoKGUpIHtcXHJcXG4gICAgICBkZXRhaWxzW1xcXCJvbmVycm9yXFxcIl0oKTtcXHJcXG4gICAgfVxcclxcbiAgICBpZiAoZGV0YWlscy5oZWFkZXJzKSB7XFxyXFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZXRhaWxzLmhlYWRlcnMpIHtcXHJcXG4gICAgICAgIHhtbGh0dHAuc2V0UmVxdWVzdEhlYWRlcihwcm9wLCBkZXRhaWxzLmhlYWRlcnNbcHJvcF0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICB4bWxodHRwLnNlbmQoKHR5cGVvZihkZXRhaWxzLmRhdGEpICE9PSBcXCd1bmRlZmluZWRcXCcpID8gZGV0YWlscy5kYXRhIDogbnVsbCk7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIHJldHVybiB4aHI7XFxyXFxufSk7XFxuLy8jIHNvdXJjZVVSTD0veGhyL2Jyb3dzZXIuanNcIik7XG5cbiIsCiAgICAiZXZhbChcImRlZmluZShcXCd4aHIvdXNlcnNjcmlwdFxcJyxbXFxcIi4uL2hlbHBlci9zdXBwb3J0XFxcIiwgXFxcIi4vYnJvd3NlclxcXCJdLCBmdW5jdGlvbihzdXBwb3J0LCBicm93c2VyKXtcXHJcXG4gIGlmIChzdXBwb3J0LkdyZWFzZW1vbmtleSkge1xcclxcbiAgICByZXR1cm4gR01feG1saHR0cFJlcXVlc3Q7XFxyXFxuICB9IGVsc2Uge1xcclxcbiAgICByZXR1cm4gYnJvd3NlcjtcXHJcXG4gIH1cXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS94aHIvdXNlcnNjcmlwdC5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ3hoclxcJyxbXFxcInhoci91c2Vyc2NyaXB0XFxcIl0sIGZ1bmN0aW9uKHhocil7XFxyXFxuICByZXR1cm4geGhyO1xcclxcbn0pO1xcbi8vIyBzb3VyY2VVUkw9L3hoci5qc1wiKTtcblxuIiwKICAgICJldmFsKFwiZGVmaW5lKFxcJ21haW4td3JhcHBlclxcJyxbXFxcInN0b3JhZ2VcXFwiLCBcXFwiVXNlclByb3h5L0Nvbm5lY3Rpb25cXFwiLCBcXFwiZXh0ZW5zaW9ucy1jb25uZWN0aW9uL3VzZXJzY3JpcHRcXFwiLCBcXFwieGhyXFxcIiwgXFxcImNvbnNvbGVcXFwiXSwgZnVuY3Rpb24oc3RvcmFnZSwgQ29ubmVjdGlvbiwgZXh0ZW5zaW9uLCB4aHIsIGNvbil7XFxyXFxuICB2YXIgZnVuY3Rpb25NYXAgPSB7XFxyXFxuICAgIFxcXCJzZXRJdGVtXFxcIjogc3RvcmFnZS5zZXRJdGVtLFxcclxcbiAgICBcXFwiZ2V0SXRlbVxcXCI6IHN0b3JhZ2UuZ2V0SXRlbSxcXHJcXG4gICAgXFxcInJlbW92ZUl0ZW1cXFwiOiBzdG9yYWdlLnJlbW92ZUl0ZW0sXFxyXFxuICAgIFxcXCJ4aHJcXFwiOiB4aHIsXFxyXFxuICAgIFxcXCJsb2dcXFwiOiBjb24ubG9nXFxyXFxuICB9O1xcclxcbiAgXFxyXFxuICB2YXIgY29ubmVjdGlvbiA9IG51bGw7XFxyXFxuICBcXHJcXG4gIHN0b3JhZ2UuZ2V0SXRlbShcXFwiWW91VHViZUNlbnRlclNldHRpbmdzXFxcIiwgZnVuY3Rpb24oc2V0dGluZ3Mpe1xcclxcbiAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSBcXFwib2JqZWN0XFxcIikgc2V0dGluZ3MgPSBKU09OLnBhcnNlKHNldHRpbmdzIHx8IFxcXCJ7fVxcXCIpO1xcclxcbiAgICBcXHJcXG4gICAgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKCk7XFxyXFxuICAgIGNvbm5lY3Rpb24uc2V0RnVuY3Rpb25zKGZ1bmN0aW9uTWFwKTtcXHJcXG4gICAgXFxyXFxuICAgIGV4dGVuc2lvbi5zZXRQYWdlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcXHJcXG4gICAgXFxyXFxuICAgIGNvbm5lY3Rpb24uaW5qZWN0KG1haW5QYWdlLCBzZXR0aW5ncywgY29uLnNlc3Npb25Ub2tlbik7XFxyXFxuICB9LCB0cnVlKTtcXHJcXG59KTtcXG4vLyMgc291cmNlVVJMPS9tYWluLXdyYXBwZXIuanNcIik7XG5cbiIKICBdCn0=
})();